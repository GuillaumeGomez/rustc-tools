<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Determine the set of places that have to be stable across match guards."><title>collect_fake_borrows in rustc_mir_build::build::matches::util - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-49344e4802b2d48a.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="rustc_mir_build" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-dev" data-channel="nightly" data-search-js="search-e056c65ede92db13.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../../../../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../rustc_mir_build/index.html">rustc_<wbr>mir_<wbr>build</a><span class="version">1.83.0-dev</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In rustc_<wbr>mir_<wbr>build::<wbr>build::<wbr>matches::<wbr>util</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../../index.html">rustc_mir_build</a>::<wbr><a href="../../index.html">build</a>::<wbr><a href="../index.html">matches</a>::<wbr><a href="index.html">util</a></span><h1>Function <span class="fn">collect_fake_borrows</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/rustc_mir_build/build/matches/util.rs.html#68-98">source</a> </span></div><pre class="rust item-decl"><code>pub(super) fn collect_fake_borrows&lt;'tcx&gt;(
    cx: &amp;mut <a class="struct" href="../../struct.Builder.html" title="struct rustc_mir_build::build::Builder">Builder</a>&lt;'_, 'tcx&gt;,
    candidates: &amp;[<a class="struct" href="../struct.Candidate.html" title="struct rustc_mir_build::build::matches::Candidate">Candidate</a>&lt;'_, 'tcx&gt;],
    temp_span: <a class="struct" href="../../../../rustc_span/span_encoding/struct.Span.html" title="struct rustc_span::span_encoding::Span">Span</a>,
    scrutinee_base: <a class="enum" href="../../expr/as_place/enum.PlaceBase.html" title="enum rustc_mir_build::build::expr::as_place::PlaceBase">PlaceBase</a>,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;(<a class="struct" href="../../../../rustc_middle/mir/syntax/struct.Place.html" title="struct rustc_middle::mir::syntax::Place">Place</a>&lt;'tcx&gt;, <a class="struct" href="../../../../rustc_middle/mir/struct.Local.html" title="struct rustc_middle::mir::Local">Local</a>, <a class="enum" href="../../../../rustc_middle/mir/syntax/enum.FakeBorrowKind.html" title="enum rustc_middle::mir::syntax::FakeBorrowKind">FakeBorrowKind</a>)&gt;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Determine the set of places that have to be stable across match guards.</p>
<p>Returns a list of places that need a fake borrow along with a local to store it.</p>
<p>Match exhaustiveness checking is not able to handle the case where the place being matched on is
mutated in the guards. We add “fake borrows” to the guards that prevent any mutation of the
place being matched. There are a some subtleties:</p>
<ol>
<li>Borrowing <code>*x</code> doesn’t prevent assigning to <code>x</code>. If <code>x</code> is a shared reference, the borrow
isn’t even tracked. As such we have to add fake borrows of any prefixes of a place.</li>
<li>We don’t want <code>match x { (Some(_), _) =&gt; (), .. }</code> to conflict with mutable borrows of <code>x.1</code>, so we
only add fake borrows for places which are bound or tested by the match.</li>
<li>We don’t want <code>match x { Some(_) =&gt; (), .. }</code> to conflict with mutable borrows of <code>(x as Some).0</code>, so the borrows are a special shallow borrow that only affects the place and not its
projections.
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>x = (<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="bool-val">true</span>);
<span class="kw">match </span>x {
    (<span class="prelude-val">Some</span>(<span class="kw">_</span>), <span class="bool-val">false</span>) =&gt; {}
    <span class="kw">_ if </span>{ <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">ref mut </span>y) = x.<span class="number">0 </span>{ <span class="kw-2">*</span>y += <span class="number">1 </span>}; <span class="bool-val">true </span>} =&gt; {}
    <span class="kw">_ </span>=&gt; {}
}</code></pre></div>
</li>
<li>The fake borrows may be of places in inactive variants, e.g. here we need to fake borrow <code>x</code>
and <code>(x as Some).0</code>, but when we reach the guard <code>x</code> may not be <code>Some</code>.
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>x = (<span class="prelude-val">Some</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>)), <span class="bool-val">true</span>);
<span class="kw">match </span>x {
    (<span class="prelude-val">Some</span>(<span class="prelude-val">Some</span>(<span class="kw">_</span>)), <span class="bool-val">false</span>) =&gt; {}
    <span class="kw">_ if </span>{ <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="prelude-val">Some</span>(<span class="kw-2">ref mut </span>y)) = x.<span class="number">0 </span>{ <span class="kw-2">*</span>y += <span class="number">1 </span>}; <span class="bool-val">true </span>} =&gt; {}
    <span class="kw">_ </span>=&gt; {}
}</code></pre></div>
So it would be UB to generate code for the fake borrows. They therefore have to be removed by
a MIR pass run after borrow checking.</li>
</ol>
</div></details></section></div></main></body></html>