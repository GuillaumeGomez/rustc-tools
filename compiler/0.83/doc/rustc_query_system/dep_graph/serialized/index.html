<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The data that we will serialize and deserialize."><title>rustc_query_system::dep_graph::serialized - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-49344e4802b2d48a.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rustc_query_system" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-dev" data-channel="nightly" data-search-js="search-e056c65ede92db13.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../../../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../rustc_query_system/index.html">rustc_<wbr>query_<wbr>system</a><span class="version">1.83.0-dev</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module serialized</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In rustc_<wbr>query_<wbr>system::<wbr>dep_<wbr>graph</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">rustc_query_system</a>::<wbr><a href="../index.html">dep_graph</a></span><h1>Module <span>serialized</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/rustc_query_system/dep_graph/serialized.rs.html#1-731">source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The data that we will serialize and deserialize.</p>
<p>Notionally, the dep-graph is a sequence of NodeInfo with the dependencies
specified inline. The total number of nodes and edges are stored as the last
16 bytes of the file, so we can find them easily at decoding time.</p>
<p>The serialisation is performed on-demand when each node is emitted. Using this
scheme, we do not need to keep the current graph in memory.</p>
<p>The deserialization is performed manually, in order to convert from the stored
sequence of NodeInfos to the different arrays in SerializedDepGraph. Since the
node and edge count are stored at the end of the file, all the arrays can be
pre-allocated with the right length.</p>
<p>The encoding of the de-pgraph is generally designed around the fact that fixed-size
reads of encoded data are generally faster than variable-sized reads. Ergo we adopt
essentially the same varint encoding scheme used in the rmeta format; the edge lists
for each node on the graph store a 2-bit integer which is the number of bytes per edge
index in that nodeâ€™s edge list. We effectively ignore that an edge index of 0 could be
encoded with 0 bytes in order to not require 3 bits to store the byte width of the edges.
The overhead of calculating the correct byte width for each edge is mitigated by
building edge lists with <a href="../edges/struct.EdgesVec.html" title="struct rustc_query_system::dep_graph::edges::EdgesVec"><code>EdgesVec</code></a> which keeps a running max of the edges in a node.</p>
<p>When we decode this data, we do not immediately create <a href="struct.SerializedDepNodeIndex.html" title="struct rustc_query_system::dep_graph::serialized::SerializedDepNodeIndex"><code>SerializedDepNodeIndex</code></a> and
instead keep the data in its denser serialized form which lets us turn our on-disk size
efficiency directly into a peak memory reduction. When we convert these encoded-in-memory
values into their fully-deserialized type, we use a fixed-size read of the encoded array
then mask off any errant bytes we read. The array of edge index bytes is padded to permit this.</p>
<p>We also encode and decode the entire rest of each node using <a href="struct.SerializedNodeHeader.html" title="struct rustc_query_system::dep_graph::serialized::SerializedNodeHeader"><code>SerializedNodeHeader</code></a>
to let this encoding and decoding be done in one fixed-size operation. These headers contain
two <a href="../../../rustc_data_structures/fingerprint/struct.Fingerprint.html" title="struct rustc_data_structures::fingerprint::Fingerprint"><code>Fingerprint</code></a>s along with the serialized <a href="../dep_node/struct.DepKind.html" title="struct rustc_query_system::dep_graph::dep_node::DepKind"><code>DepKind</code></a>, and the number of edge indices
in the node and the number of bytes used to encode the edge indices for this node. The
<a href="../dep_node/struct.DepKind.html" title="struct rustc_query_system::dep_graph::dep_node::DepKind"><code>DepKind</code></a>, number of edges, and bytes per edge are all bit-packed together, if they fit.
If the number of edges in this node does not fit in the bits available in the header, we
store it directly after the header with leb128.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.EdgeHeader.html" title="struct rustc_query_system::dep_graph::serialized::EdgeHeader">Edge<wbr>Header</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">A packed representation of an edgeâ€™s start index and byte width.</div></li><li><div class="item-name"><a class="struct" href="struct.EncoderState.html" title="struct rustc_query_system::dep_graph::serialized::EncoderState">Encoder<wbr>State</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.GraphEncoder.html" title="struct rustc_query_system::dep_graph::serialized::GraphEncoder">Graph<wbr>Encoder</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.NodeInfo.html" title="struct rustc_query_system::dep_graph::serialized::NodeInfo">Node<wbr>Info</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.SerializedDepGraph.html" title="struct rustc_query_system::dep_graph::serialized::SerializedDepGraph">Serialized<wbr>DepGraph</a></div><div class="desc docblock-short">Data for use when recompiling the <strong>current crate</strong>.</div></li><li><div class="item-name"><a class="struct" href="struct.SerializedDepNodeIndex.html" title="struct rustc_query_system::dep_graph::serialized::SerializedDepNodeIndex">Serialized<wbr>DepNode<wbr>Index</a></div></li><li><div class="item-name"><a class="struct" href="struct.SerializedNodeHeader.html" title="struct rustc_query_system::dep_graph::serialized::SerializedNodeHeader">Serialized<wbr>Node<wbr>Header</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">A packed representation of all the fixed-size fields in a <code>NodeInfo</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Stat.html" title="struct rustc_query_system::dep_graph::serialized::Stat">Stat</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.Unpacked.html" title="struct rustc_query_system::dep_graph::serialized::Unpacked">Unpacked</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.DEP_NODE_PAD.html" title="constant rustc_query_system::dep_graph::serialized::DEP_NODE_PAD">DEP_<wbr>NODE_<wbr>PAD</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Amount of padding we need to add to the edge list data so that we can retrieve every
SerializedDepNodeIndex with a fixed-size read then mask.</div></li><li><div class="item-name"><a class="constant" href="constant.DEP_NODE_SIZE.html" title="constant rustc_query_system::dep_graph::serialized::DEP_NODE_SIZE">DEP_<wbr>NODE_<wbr>SIZE</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="constant" href="constant.DEP_NODE_WIDTH_BITS.html" title="constant rustc_query_system::dep_graph::serialized::DEP_NODE_WIDTH_BITS">DEP_<wbr>NODE_<wbr>WIDTH_<wbr>BITS</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Number of bits we need to store the number of used bytes in a SerializedDepNodeIndex.
Note that wherever we encode byte widths like this we actually store the number of bytes used
minus 1; for a 4-byte value we technically would have 5 widths to store, but using one byte to
store zeroes (which are relatively rare) is a decent tradeoff to save a bit in our bitfields.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.mask.html" title="fn rustc_query_system::dep_graph::serialized::mask">mask</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul></section></div></main></body></html>