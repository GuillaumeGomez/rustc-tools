<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Checks that meta-variables in macro definition are correctly declared and used."><title>rustc_expand::mbe::macro_check - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-49344e4802b2d48a.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rustc_expand" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-dev" data-channel="nightly" data-search-js="search-e056c65ede92db13.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../../../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../rustc_expand/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../rustc_expand/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2><a href="../../../rustc_expand/index.html">rustc_<wbr>expand</a><span class="version">1.83.0-dev</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module macro_<wbr>check</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#what-is-checked" title="What is checked">What is checked</a><ul><li><a href="#meta-variables-must-not-be-bound-twice" title="Meta-variables must not be bound twice">Meta-variables must not be bound twice</a></li><li><a href="#meta-variables-must-not-be-free" title="Meta-variables must not be free">Meta-variables must not be free</a></li><li><a href="#meta-variables-must-repeat-at-least-as-many-times-as-their-binder" title="Meta-variables must repeat at least as many times as their binder">Meta-variables must repeat at least as many times as their binder</a></li><li><a href="#meta-variables-must-repeat-with-the-same-kleene-operators-as-their-binder" title="Meta-variables must repeat with the same Kleene operators as their binder">Meta-variables must repeat with the same Kleene operators as their binder</a></li></ul></li><li><a href="#disclaimer" title="Disclaimer">Disclaimer</a><ul><li><a href="#examples-of-false-positive" title="Examples of false positive">Examples of false positive</a></li><li><a href="#examples-of-false-negative" title="Examples of false negative">Examples of false negative</a></li></ul></li><li><a href="#how-it-is-checked" title="How it is checked">How it is checked</a><ul><li><a href="#environments" title="Environments">Environments</a></li></ul></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In rustc_<wbr>expand::<wbr>mbe</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">rustc_expand</a>::<wbr><a href="../index.html">mbe</a></span><h1>Module <span>macro_check</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/rustc_expand/mbe/macro_check.rs.html#1-661">source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Checks that meta-variables in macro definition are correctly declared and used.</p>
<h2 id="what-is-checked"><a class="doc-anchor" href="#what-is-checked">Â§</a>What is checked</h2><h3 id="meta-variables-must-not-be-bound-twice"><a class="doc-anchor" href="#meta-variables-must-not-be-bound-twice">Â§</a>Meta-variables must not be bound twice</h3>
<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">â“˜</a><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> foo { (<span class="macro-nonterminal">$x</span>:tt <span class="macro-nonterminal">$x</span>:tt) =&gt; { <span class="macro-nonterminal">$x </span>}; }</code></pre></div>
<p>This check is sound (no false-negative) and complete (no false-positive).</p>
<h3 id="meta-variables-must-not-be-free"><a class="doc-anchor" href="#meta-variables-must-not-be-free">Â§</a>Meta-variables must not be free</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> foo { () =&gt; { <span class="macro-nonterminal">$x </span>}; }</code></pre></div>
<p>This check is also done at macro instantiation but only if the branch is taken.</p>
<h3 id="meta-variables-must-repeat-at-least-as-many-times-as-their-binder"><a class="doc-anchor" href="#meta-variables-must-repeat-at-least-as-many-times-as-their-binder">Â§</a>Meta-variables must repeat at least as many times as their binder</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> foo { ($(<span class="macro-nonterminal">$x</span>:tt)<span class="kw-2">*</span>) =&gt; { <span class="macro-nonterminal">$x </span>}; }</code></pre></div>
<p>This check is also done at macro instantiation but only if the branch is taken.</p>
<h3 id="meta-variables-must-repeat-with-the-same-kleene-operators-as-their-binder"><a class="doc-anchor" href="#meta-variables-must-repeat-with-the-same-kleene-operators-as-their-binder">Â§</a>Meta-variables must repeat with the same Kleene operators as their binder</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> foo { ($(<span class="macro-nonterminal">$x</span>:tt)+) =&gt; { $(<span class="macro-nonterminal">$x</span>)* }; }</code></pre></div>
<p>This check is not done at macro instantiation.</p>
<h2 id="disclaimer"><a class="doc-anchor" href="#disclaimer">Â§</a>Disclaimer</h2>
<p>In the presence of nested macros (a macro defined in a macro), those checks may have false
positives and false negatives. We try to detect those cases by recognizing potential macro
definitions in RHSes, but nested macros may be hidden through the use of particular values of
meta-variables.</p>
<h3 id="examples-of-false-positive"><a class="doc-anchor" href="#examples-of-false-positive">Â§</a>Examples of false positive</h3>
<p>False positives can come from cases where we donâ€™t recognize a nested macro, because it depends
on particular values of meta-variables. In the following example, we think both instances of
<code>$x</code> are free, which is a correct statement if <code>$name</code> is anything but <code>macro_rules</code>. But when
<code>$name</code> is <code>macro_rules</code>, like in the instantiation below, then <code>$x:tt</code> is actually a binder of
the nested macro and <code>$x</code> is bound to it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> foo { (<span class="macro-nonterminal">$name</span>:ident) =&gt; { <span class="macro-nonterminal">$</span><span class="macro">name!</span> <span class="macro-nonterminal">bar </span>{ (<span class="macro-nonterminal">$x</span>:tt) =&gt; { <span class="macro-nonterminal">$x </span>}; } }; }
<span class="macro">foo!</span>(macro_rules);</code></pre></div>
<p>False positives can also come from cases where we think there is a nested macro while there
isnâ€™t. In the following example, we think <code>$x</code> is free, which is incorrect because <code>bar</code> is not
a nested macro since it is not evaluated as code by <code>stringify!</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> foo { () =&gt; { <span class="macro">stringify!</span>(<span class="macro">macro_rules!</span> bar { () =&gt; { <span class="macro-nonterminal">$x </span>}; }) }; }</code></pre></div>
<h3 id="examples-of-false-negative"><a class="doc-anchor" href="#examples-of-false-negative">Â§</a>Examples of false negative</h3>
<p>False negatives can come from cases where we donâ€™t recognize a meta-variable, because it depends
on particular values of meta-variables. In the following examples, we donâ€™t see that if <code>$d</code> is
instantiated with <code>$</code> then <code>$d z</code> becomes <code>$z</code> in the nested macro definition and is thus a free
meta-variable. Note however, that if <code>foo</code> is instantiated, then we would check the definition
of <code>bar</code> and would see the issue.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">macro_rules!</span> foo { (<span class="macro-nonterminal">$d</span>:tt) =&gt; { <span class="macro">macro_rules!</span> bar { (<span class="macro-nonterminal">$y</span>:tt) =&gt; { <span class="macro-nonterminal">$d </span>z }; } }; }</code></pre></div>
<h2 id="how-it-is-checked"><a class="doc-anchor" href="#how-it-is-checked">Â§</a>How it is checked</h2>
<p>There are 3 main functions: <code>check_binders</code>, <code>check_occurrences</code>, and <code>check_nested_macro</code>. They
all need some kind of environment.</p>
<h3 id="environments"><a class="doc-anchor" href="#environments">Â§</a>Environments</h3>
<p>Environments are used to pass information.</p>
<h4 id="from-lhs-to-rhs"><a class="doc-anchor" href="#from-lhs-to-rhs">Â§</a>From LHS to RHS</h4>
<p>When checking a LHS with <code>check_binders</code>, we produce (and use) an environment for binders,
namely <code>Binders</code>. This is a mapping from binder name to information about that binder: the span
of the binder for error messages and the stack of Kleene operators under which it was bound in
the LHS.</p>
<p>This environment is used by both the LHS and RHS. The LHS uses it to detect duplicate binders.
The RHS uses it to detect the other errors.</p>
<h4 id="from-outer-macro-to-inner-macro"><a class="doc-anchor" href="#from-outer-macro-to-inner-macro">Â§</a>From outer macro to inner macro</h4>
<p>When checking the RHS of an outer macro and we detect a nested macro definition, we push the
current state, namely <code>MacroState</code>, to an environment of nested macro definitions. Each state
stores the LHS binders when entering the macro definition as well as the stack of Kleene
operators under which the inner macro is defined in the RHS.</p>
<p>This environment is a stack representing the nesting of macro definitions. As such, the stack of
Kleene operators under which a meta-variable is repeating is the concatenation of the stacks
stored when entering a macro definition starting from the state in which the meta-variable is
bound.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BinderInfo.html" title="struct rustc_expand::mbe::macro_check::BinderInfo">Binder<wbr>Info</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Information attached to a meta-variable binder in LHS.</div></li><li><div class="item-name"><a class="struct" href="struct.MacroState.html" title="struct rustc_expand::mbe::macro_check::MacroState">Macro<wbr>State</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">The state at which we entered a macro definition in the RHS of another macro definition.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.NestedMacroState.html" title="enum rustc_expand::mbe::macro_check::NestedMacroState">Nested<wbr>Macro<wbr>State</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Represents the processed prefix of a nested macro.</div></li><li><div class="item-name"><a class="enum" href="enum.Stack.html" title="enum rustc_expand::mbe::macro_check::Stack">Stack</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Stack represented as linked list.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.buffer_lint.html" title="fn rustc_expand::mbe::macro_check::buffer_lint">buffer_<wbr>lint</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="fn" href="fn.check_binders.html" title="fn rustc_expand::mbe::macro_check::check_binders">check_<wbr>binders</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Checks <code>lhs</code> as part of the LHS of a macro definition, extends <code>binders</code> with new binders, and
sets <code>valid</code> to false in case of errors.</div></li><li><div class="item-name"><a class="fn" href="fn.check_meta_variables.html" title="fn rustc_expand::mbe::macro_check::check_meta_variables">check_<wbr>meta_<wbr>variables</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Checks that meta-variables are used correctly in a macro definition.</div></li><li><div class="item-name"><a class="fn" href="fn.check_nested_macro.html" title="fn rustc_expand::mbe::macro_check::check_nested_macro">check_<wbr>nested_<wbr>macro</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Checks the body of nested macro, returns where the check stopped, and sets <code>valid</code> to false in
case of errors.</div></li><li><div class="item-name"><a class="fn" href="fn.check_nested_occurrences.html" title="fn rustc_expand::mbe::macro_check::check_nested_occurrences">check_<wbr>nested_<wbr>occurrences</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Checks <code>tts</code> as part of the RHS of a macro definition, tries to recognize nested macro
definitions, and sets <code>valid</code> to false in case of errors.</div></li><li><div class="item-name"><a class="fn" href="fn.check_occurrences.html" title="fn rustc_expand::mbe::macro_check::check_occurrences">check_<wbr>occurrences</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Checks <code>rhs</code> as part of the RHS of a macro definition and sets <code>valid</code> to false in case of
errors.</div></li><li><div class="item-name"><a class="fn" href="fn.check_ops_is_prefix.html" title="fn rustc_expand::mbe::macro_check::check_ops_is_prefix">check_<wbr>ops_<wbr>is_<wbr>prefix</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Checks that a meta-variable occurrence is valid.</div></li><li><div class="item-name"><a class="fn" href="fn.get_binder_info.html" title="fn rustc_expand::mbe::macro_check::get_binder_info">get_<wbr>binder_<wbr>info</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Returns the binder information of a meta-variable.</div></li><li><div class="item-name"><a class="fn" href="fn.ops_is_prefix.html" title="fn rustc_expand::mbe::macro_check::ops_is_prefix">ops_<wbr>is_<wbr>prefix</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Returns whether <code>binder_ops</code> is a prefix of <code>occurrence_ops</code>.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Binders.html" title="type rustc_expand::mbe::macro_check::Binders">Binders</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">An environment of meta-variables to their binder information.</div></li></ul></section></div></main></body></html>