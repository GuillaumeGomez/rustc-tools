searchState.loadedDescShard("rustc_pattern_analysis", 0, "Analysis of patterns, notably match exhaustiveness …\nExtra data to store in a match arm.\nRaw content of Fluent resource for this crate, generated …\nErrors that can abort analysis.\nRepresents some newtyped <code>usize</code> wrapper.\nAn owned contiguous collection of <code>T</code>s, indexed by <code>I</code> rather …\nThe arm of a match expression.\nContext that provides type information about constructors.\nExtra data to store in a pattern.\n<code>bool</code> newtype that indicates whether this is a privately …\nA string literal\nThe type of a pattern.\nThe index of an enum variant.\nRaise a bug.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe maximum pattern complexity limit was reached.\nAs explained in <code>crate::usefulness</code>, values and patterns are …\nThe number of fields for this constructor.\nThe types of the fields for this constructor. The result …\nThe set of all the constructors for <code>ty</code>.\nGrows the index vector so that it contains an entry for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new vector with a copy of <code>elem</code> for each index in …\nCreates a new IndexVec with n copies of the <code>elem</code>.\nCreate an <code>IndexVec</code> with <code>n</code> elements, where the value of each\nConstructs a new <code>IndexVec&lt;I, T&gt;</code> from a <code>Vec&lt;T&gt;</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLint that there is a gap <code>gap</code> between <code>pat</code> and all of …\nLint that the range <code>pat</code> overlapped with all the ranges in …\nConstructs a new, empty <code>IndexVec&lt;I, T&gt;</code>.\nAs explained in <code>crate::usefulness</code>, values and patterns are …\nPushes an element to the array returning the index where …\nMatch exhaustiveness and redundancy algorithm\nWrite the name of the variant represented by <code>pat</code>. Used for …\nBooleans\nBooleans.\nA value can be decomposed into a constructor applied to …\nDescribes the set of all constructors for a type. For …\nVariant that matches no value. E.g. <code>Some::&lt;Option&lt;!&gt;&gt;</code> if …\nRanges of floating-point literal values (<code>2.0..=5.2</code>).\nEncoded value. DO NOT CONSTRUCT BY HAND; use …\nPatterns of length <code>n</code> (<code>[x, y]</code>).\nFake extra constructor for variants that should not be …\nVariant behind an unstable gate or with the <code>#[doc(hidden)]</code> …\nAn exclusive interval, used for precise integer …\nRanges of integer literal values (<code>2</code>, <code>2..=5</code> or <code>2..5</code>).\nThe type is spanned by integer values. The range or ranges …\nA possibly infinite integer. Values are encoded such that …\nFake extra constructor for constructors that are not seen …\nNever pattern. Only used in <code>WitnessPat</code>. An actual never …\nThe type has no constructors (not even empty ones). This …\nFake extra constructor for enums that aren’t allowed to …\nConstants that must not be matched structurally. They are …\nA globally unique id to distinguish <code>Opaque</code> patterns.\nOr-pattern.\nWhether we have seen a constructor in the column or not.\nFake extra constructor that indicates and empty field that …\nReferences\nThe type is <code>&amp;T</code>.\nA constructor for array and slice patterns.\nArray and slice patterns.\nThe type is matched by slices. <code>array_len</code> is the …\nDescribes the result of analyzing the constructors in a …\nString literals. Strings are not quite the same as <code>&amp;[u8]</code> …\nTuples and structs.\nThe type is a tuple or struct. <code>empty</code> tracks whether the …\nThe type is a union.\nUnion field accesses.\nThe constructors cannot be listed, and the type cannot be …\nPatterns using the <code>..</code> notation (<code>[x, .., y]</code>). Captures any …\nEnum variants.\nThis type has the following list of constructors. If …\nVariant that doesn’t fit the other cases, i.e. most …\nWildcard pattern.\nWhether this set only contains empty constructors.\nThe number of fields for this constructor. This must be …\n<code>None</code> if the matched value is a slice, <code>Some(n)</code> if it is an …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nWhether this pattern includes patterns of length <code>other_len</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a range with these boundaries. <code>lo</code> must not be …\nConstruct a singleton range. <code>x</code> must be a <code>Finite(_)</code> value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSee <code>Constructor::is_covered_by</code>\nReturns whether <code>self</code> is covered by <code>other</code>, i.e. whether <code>self</code>…\nBest effort; will not know that e.g. <code>255u8..</code> is a …\nThe kind of pattern it is: fixed-length <code>[x, y]</code> or variable …\nNote: this will not turn a finite value into an infinite …\nNote: this will turn <code>u128::MAX</code> into <code>PosInfinity</code>. This …\nPartition a range of integers into disjoint subranges. …\nThis computes constructor splitting for variable-length …\nThis analyzes a column of constructors to 1/ determine …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThis is an exclusive range that looks like <code>lo..max</code> (i.e. …\nThis is an exclusive range that looks like <code>lo..gap</code> (i.e. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAll these ranges skipped over <code>gap</code> which we think is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSuggest <code>lo..=max</code> instead.\nSuggest <code>lo..=gap</code> instead.\nTraverse the patterns to collect any variants of a …\nValues and patterns can be represented as a constructor …\nA pattern with an index denoting which field it …\nA user-provided pattern.\nA globally unique id to distinguish patterns.\nRepresents either a pattern obtained from user input or a …\nA non-user-provided wildcard, created during …\nSame idea as <code>DeconstructedPat</code>, except this is a fictitious …\nThe number of fields in this pattern. E.g. if the pattern …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the extra data stored in a pattern.\nExtra data to store in a pattern.\nExpand this or-pattern into its alternatives. This only …\nRecursively expand this (possibly-nested) or-pattern into …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSpecialize this pattern with a constructor. <code>other_ctor</code> can …\nSpecialize this pattern with a constructor. <code>other_ctor</code> can …\nGlobally-unique id used to track usefulness at the level …\nWalk top-down and call <code>it</code> in each place where a pattern …\nConstruct a pattern that matches everything that starts …\nCreate a wildcard pattern for this type. If the type is …\nA column of patterns in a match, where a column is the …\nDo constructor splitting on the constructors of the column.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nPushes a pattern onto the column, expanding any …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis must not contain an or-pattern. <code>expand_and_push</code> takes …\nDoes specialization: given a constructor, this takes the …\nBooleans\nBooleans.\nRanges of floating-point literal values (<code>2.0..=5.2</code>).\nFake extra constructor for variants that should not be …\nRanges of integer literal values (<code>2</code>, <code>2..=5</code> or <code>2..5</code>).\nThe type is spanned by integer values. The range or ranges …\nFake extra constructor for constructors that are not seen …\nNever pattern. Only used in <code>WitnessPat</code>. An actual never …\nThe type has no constructors (not even empty ones). This …\nFake extra constructor for enums that aren’t allowed to …\nConstants that must not be matched structurally. They are …\nOr-pattern.\nFake extra constructor that indicates and empty field that …\nThe arm is redundant and can be removed without changing …\nReferences\nThe type is <code>&amp;T</code>.\nA type which has gone through <code>cx.reveal_opaque_ty</code>, i.e. if …\nArray and slice patterns.\nThe type is matched by slices. <code>array_len</code> is the …\nString literals. Strings are not quite the same as <code>&amp;[u8]</code> …\nTuples and structs.\nThe type is a tuple or struct. <code>empty</code> tracks whether the …\nThe type is a union.\nUnion field accesses.\nThe constructors cannot be listed, and the type cannot be …\nThe arm is useful. This additionally carries a set of …\nEnum variants.\nThis type has the following list of constructors. If …\nWildcard pattern.\nThe entrypoint for this crate. Computes whether a match is …\nThe number of fields in this pattern. E.g. if the pattern …\nFor each arm, a set of indices of arms above it that have …\nFor each arm of the input, whether that arm is useful …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAll the values matched by this pattern are already matched …\nThe number of fields for this constructor.\nReturns the types of the fields for a given constructor. …\nCreates a set that represents all the constructors of <code>ty</code>.\nExtra data to store in a pattern.\nTo allocate the result of <code>self.ctor_sub_tys()</code>\nRecursively expand this pattern into its subpatterns. Only …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert back to a <code>thir::PatRangeBoundary</code> for diagnostic …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the given type is an enum from another …\nWhether the range denotes the fictitious values before …\nWhether the data at the scrutinee is known to be valid. …\nNote: the input patterns must have been lowered through …\nLint level at the match.\nThe module in which the match occurs. This is necessary for\nIf the match is exhaustive, this is empty. If not, this …\nPattern analysis sometimes wants to print patterns as part …\nPrints an <code>IntRange</code> to a string for diagnostic purposes.\nPrints a <code>WitnessPat</code> to an owned string, for diagnostic …\nOnly produce <code>NON_EXHAUSTIVE_OMITTED_PATTERNS</code> lint on …\nReturns the hidden type corresponding to this key if the …\nType inference occasionally gives us opaque types in …\nSpan of the scrutinee.\nGlobally-unique id used to track usefulness at the level …\nThe span of the whole match, if applicable.\nReturns <code>true</code> if the given pattern would be printed as a …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a closure that will return <code>&quot;&quot;</code> when called the …\nA pattern is a “branch” if it is the immediate child …\nA 2D matrix. Represents a list of pattern-tuples under …\nA row of the matrix.\nRepresents a pattern-tuple under investigation.\nContext that provides information local to a place under …\nData about a place under investigation. Its methods …\nTrack whether a given place (aka column) is known to …\nIndicates why a given pattern is considered redundant.\nThe arm is redundant and can be removed without changing …\nThe arm is useful. This additionally carries a set of …\nIndicates whether or not a given arm is useful.\nContext that provides information for usefulness checking.\nThe output of checking a match for exhaustiveness and arm …\nRepresents a set of pattern-tuples that are witnesses of …\nA witness-tuple of non-exhaustiveness for error reporting, …\nReverses specialization. Given a witness obtained after …\nReverses specialization by <code>ctor</code>. See the section on …\nFor each arm, a set of indices of arms above it that have …\nFor each arm of the input, whether that arm is useful …\nTrack information about the usefulness of branch patterns …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCollect ranges that have a singleton gap between them.\nCollect ranges that overlap like <code>lo..=overlap</code>/<code>overlap..=hi</code>…\nThe core of the algorithm.\nComputes whether a match is exhaustive and which of its …\nA set of patterns that:\nAll the values matched by this pattern are already matched …\nNew matrix with no witnesses.\nMerges the witnesses of two matrices. Their column types …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether the head pattern is a branch (see definition of “…\nIterate over the first pattern of each row.\nTracks some rows above this one that have an intersection …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this has any witnesses.\nCheck whether this pattern is redundant, and if so explain …\nWhether the place is the scrutinee itself or a subplace of …\nWhether the original arm had a guard. This is inherited …\nBuild a new matrix from an iterator of <code>MatchArm</code>s.\nIf the match is exhaustive, this is empty. If not, this …\nWhen we specialize, we remember which row of the original …\nTrack info about each place. Each place corresponds to a …\nThis computes <code>specialize(ctor, self)</code>. See top of the file …\nThis computes <code>specialize(ctor, self)</code>. See top of the file …\nWhether the place is a private uninhabited field. If so we …\nPushes a new row to the matrix. Internal method, prefer …\nReverses specialization by the <code>Missing</code> constructor by …\nReverses specialization by the <code>Missing</code> constructor by …\nSometimes we know that as far as this row is concerned, …\nVector of rows. The rows must form a rectangular 2D array. …\nAsserts that there is a single column and returns the …\nAsserts that the witness contains a single pattern, and …\nGiven a constructor for the current place, we return one …\nIf the place has validity given by <code>self</code> and we read that …\nThis computes <code>specialize(ctor, self)</code>. See top of the file …\nThis analyzes a column of constructors corresponding to …\nType of the place under investigation.\nThe type of the place.\nThe context for type information.\nNew matrix with one <code>()</code> witness, i.e. with no columns.\nRecover row usefulness and intersection information from a …\nUpdate <code>self</code> with the usefulness information found in <code>row</code>.\nWhether this pattern is useful.\nFalse when the matrix is just built. This is set to <code>true</code> by\nWhether the place is known to contain valid data.\nTrack whether the virtual wildcard row used to compute …")