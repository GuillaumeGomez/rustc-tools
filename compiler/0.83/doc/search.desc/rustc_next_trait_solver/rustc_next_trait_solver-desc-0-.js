searchState.loadedDescShard("rustc_next_trait_solver", 0, "Crate containing the implementation of the next-generation …\nThe next-generation trait solver, currently still WIP.\nWhether we’re canonicalizing a query input or the query …\nFIXME: We currently return region constraints referring to …\nWe only use the debruijn index during lookup. We don’t …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe highest universe nameable by the caller.\nImproper orphan check for backward compatibility.\nWhether we do the orphan check relative to this crate or …\nProper orphan check.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether a trait-ref is potentially implementable by …\nIgnore orphan check failures and exclusively search for …\nReturns whether all impls which would apply to the …\nAll possible values for a constant parameter already exist …\nResolves ty, region, and const vars to their inferred …\nWe’re able to use a cache here as the folder does not …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf the self type is an alias type, e.g. an opaque type or …\nAt codegen time, all monomorphic projections will succeed. …\nWe failed due to ambiguity. This ambiguity can either be a …\nA builtin impl generated by the compiler. When adding a …\nPossible ways the given goal can be proven.\nTrait solving during coherence. There are a few notable …\nA candidate that is registered only during coherence to …\nContains the error value\nAdditional constraints returned on success.\nHow many fixpoint iterations we should attempt inside of …\nA goal is a statement, i.e. <code>predicate</code>, we want to prove …\nWhy a specific goal has to be proven.\nWhether evaluating this goal ended up changing the …\nA user written impl.\nWe’re proving a where-bound of an impl.\nInstantiating a higher-ranked goal and re-proving it.\nWhy we failed to evaluate a goal.\nSome built-in impl we don’t need to differentiate. This …\nOrdinary trait solving, using everywhere except for …\nA built-in impl for trait objects. The index is only used …\nContains the success value\nWe gave up due to an overflow, most often by hitting the …\nAn assumption from the environment.\nOpaques that are defined in the inference context before a …\nThe result of evaluating a canonical query.\nDepending on the stage of compilation, we want projection …\nA built-in implementation of <code>Upcast</code> for trait objects to …\nUnsizing a tuple like <code>(A, B, ..., X)</code> to <code>(A, B, ..., Y)</code> if <code>X</code>…\nAt type-checking time, we refuse to project any associated …\nImplements the <code>AliasRelate</code> goal, which is used when …\nCode shared by trait and projection goals for candidate …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe inference context that backs (mostly) inference and …\nEvaluates a goal from <strong>outside</strong> of the trait solver.\nAdditional constraints returned by this query.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether we’re currently computing a <code>NormalizesTo</code> goal. …\nThe highest universe index nameable by the caller.\nCheck whether evaluating <code>goal</code> with a depth of <code>root_depth</code> …\nDealing with trait goals, i.e. <code>T: Trait&lt;&#39;a, U&gt;</code>.\nUse this function to merge the certainty of multiple …\nThe variable info for the <code>var_values</code>, only used to make an …\nUpdates the goal to one with a different <code>predicate</code> but the …\nA candidate is a possible way to prove a goal.\nMethods used to assemble candidates for either trait or …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nA type implements an <code>auto trait</code> if its components do as …\nCompute the built-in logic of the <code>AsyncFnKindHelper</code> helper …\nAn async closure is known to implement the <code>AsyncFn&lt;A&gt;</code> …\nA type is <code>Copy</code> or <code>Clone</code> if its components are <code>Copy</code> or <code>Clone</code>…\nA coroutine (that doesn’t come from an <code>async</code> or <code>gen</code> …\nA type is a <code>FnPtr</code> if it is of <code>FnPtr</code> type.\nA callable type (a closure, fn def, or fn ptr) is known to …\nA coroutine (that comes from a <code>gen</code> desugaring) is known to …\nA coroutine (that comes from an <code>async</code> desugaring) is known …\nA coroutine (that comes from a <code>gen</code> desugaring) is known to …\n<code>Pointee</code> is always implemented.\nA type is <code>PointerLike</code> if we can compute its layout, and …\nA type is <code>Sized</code> if its tail component is <code>Sized</code>.\n<code>Tuple</code> is implemented if the <code>Self</code> type is a tuple.\nIf the predicate contained an error, we want to avoid …\nConsider (possibly several) candidates to upcast or unsize …\nA trait alias holds if the RHS traits and <code>where</code> clauses …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConsider a clause, which consists of a “assumption” …\nConsider a clause specifically for a <code>dyn Trait</code> self type. …\nTry equating an assumption predicate against a goal’s …\nCode which is used by built-in goals that match “…\nRelevant types for an async callable, including its …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nGiven a coroutine-closure, project to its returned …\nGiven a coroutine-closure, project to its returned …\nType returned by <code>await</code>ing the output i.e. <code>f().await</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nType returned by calling the closure i.e. <code>f()</code>.\nAssemble a list of predicates that would be present on a …\nEagerly replace aliases with inference variables, emitting …\nFor some deeply nested <code>&lt;T&gt;::A::B::C::D</code> rigid associated …\nCanonicalization is used to separate some goal from its …\nCanonicalizes the goal remembering the original values for …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nComputes the region constraints and <em>new</em> opaque types …\nThis returns the canonical variable values to instantiate …\nWe have the following builtin impls for arrays:\nTrait upcasting allows for coercions between trait objects:\nWe generate a builtin <code>Unsize</code> impls for structs with …\nWe generate the following builtin impl for tuples of all …\nIn coherence we have to not only care about all impls we …\nThe inference context that backs (mostly) inference and …\nIf there’s a where-bound for the current goal, do not …\nCreates a nested evaluation context that shares the same …\n<code>enter_forall</code>, but takes <code>&amp;mut self</code> and passes it back …\nCreates a root evaluation context and search graph. This …\nEquates two values returning the nested goals without …\nThis sohuld only be used when we’re either instantiating …\nTo return the constraints of a canonical query to the …\nIterate over all added goals: returning <code>Ok(Some(_))</code> in …\nThe entry point of the solver.\nRecursively evaluates <code>goal</code>, returning whether any …\nRecursively evaluates <code>goal</code>, returning the nested goals in …\nEvaluates a goal from <strong>outside</strong> of the trait solver.\nIf we fail to merge responses we flounder and return …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe rest of the goals which have not yet processed or …\nAfter calling a canonical query, we apply the constraints …\nWhen normalizing an associated item, constrain the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether we’re currently computing a <code>NormalizesTo</code> goal. …\nConstructs a totally unconstrained, ambiguous response to …\nThe highest universe index nameable by the caller.\nIf there are multiple ways to prove a trait or projection …\nReturns a ty infer or a const infer depending on whether …\nNormalize the given alias by at least one step. If the …\nThese normalizes-to goals are treated specially during the …\n<code>probe_kind</code> is only called when proof tree building is …\nConvenience function for traits that are structural, i.e. …\nRecord impl args in the proof tree for later access by …\nThis should be used when relating a rigid alias with …\nCheck whether evaluating <code>goal</code> with a depth of <code>root_depth</code> …\nNormalize a type for when it is structurally matched on.\nIs the projection predicate is of the form …\nTry to merge multiple possible ways to prove a goal, if …\nUnify the <code>original_values</code> with the <code>var_values</code> returned by …\nThe variable info for the <code>var_values</code>, only used to make an …\nComputes the list of goals required for <code>arg</code> to be …\nUsed by proof trees to be able to recompute intermediate …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWe added a goal to the <code>EvalCtxt</code> which will get proven the …\nWhen evaluating a goal we also store the original values …\nA call to …\nA call to <code>probe</code> while proving the current goal. This is …\nProbe entered when normalizing the self ty during …\nTry to unify an opaque type with an existing key in the …\nA self-contained computation during trait solving. This …\nWhat kind of probe we’re in. In case the probe …\nA trait goal was satisfied by an impl candidate.\nThe root inference context while proving a goal.\nLooking for param-env candidates that satisfy the trait …\nSome <code>data</code> together with information about how they relate …\nA candidate for proving a trait or alias-relate goal.\nTrying to normalize an alias by at least one step in …\nUsed in the probe that wraps normalizing the non-self type …\nDuring upcasting from some source object to target object …\nBuilding proof trees incrementally during trait solving.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe actual evaluation of the goal, always <code>ProbeKind::Root</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhat happened inside of this probe in chronological order.\nThe current state of the proof tree builder, at most places\nThe core data structure when building proof trees.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nOnly used for uncached goals. After we finished evaluating …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnlike <code>EvalCtxt::var_values</code>, we append a new generic arg …\nComputes a normalizes-to (projection) goal for inherent …\nComputes a normalizes-to (projection) goal for opaque …\nComputes a normalizes-to (projection) goal for inherent …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nChecks whether each generic argument is simply a unique …\nThis type is never constructed. We only use it to …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")