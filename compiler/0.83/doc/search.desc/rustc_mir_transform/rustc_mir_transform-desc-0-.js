searchState.loadedDescShard("rustc_mir_transform", 0, "Raw content of Fluent resource for this crate, generated …\nThis pass adds validation calls (AcquireValid, …\nThis module provides a pass that removes parts of MIR that …\nThis is the implementation of the pass which transforms …\nA pass that inserts the <code>ConstEvalCounter</code> instruction into …\nA constant propagation optimization pass based on dataflow …\nThis module implements a dead store elimination (DSE) …\nDeduces supplementary parameter attributes from MIR.\nThis pass finds basic blocks that are completely equal, …\nPropagates assignment destinations backwards in the CFG to …\nThis pass just dumps MIR at a specified point.\nThis pass transforms derefs of Box into a deref of the …\nGlobal value numbering.\nInlining pass for MIR functions.\nPerforms various peephole optimizations.\nA jump threading optimization.\nA lint that checks for known panics like overflows, …\nThis pass statically detects code which has undefined …\nLowers intrinsic calls\nThis pass lowers calls to core::slice::len to just …\nObtain just the main MIR (no promoteds) and run some …\nCompute the MIR that is used during CTFE (and thus has no …\nFinds the full set of <code>DefId</code>s within the current crate that …\nCompute the main MIR body and the list of MIR bodies of …\nThis pass removes jumps to basic blocks containing only a …\nSee the docs for <code>RenameReturnPlace</code>.\nOptimize the MIR and prepare it for codegen.\nThese two passes provide no value to the compiler, so are …\nA pass that promotes borrows of constant rvalues.\nFetch all the promoteds of an item and prepare their MIR …\nThis pass removes <code>PlaceMention</code> statement, which has no …\nThis pass removes storage markers if they won’t be …\nThis pass replaces a drop of a type that does not need …\nRemoves operations on ZST places, and convert ZST operands …\nNormalizes MIR in RevealAll mode.\nAfter this series of passes, no lifetime analysis based on …\nReturns the sequence of passes that do the initial cleanup …\nReturns the sequence of passes that lowers analysis to …\nA number of passes which remove various redundancies in …\nWe denote as “SSA” the set of locals that verify the …\nA pass that eliminates branches on uninhabited or …\nA pass that propagates the unreachable terminator of a …\nValidates the MIR to ensure that invariants are upheld.\nA pass that runs which is targeted at ensuring that …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis pass moves values being dropped that are within a …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDetermine whether this type may contain a reference (or …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf we should lint on this usage, return the <code>HirId</code>, source …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck for transmutes that exhibit undefined behavior. For …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUnify locals that copy each other.\nUtility to help performing substitution of <code>*pattern</code> by …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>SsaLocals</code> computed equivalence classes between locals …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe set of <code>Local</code>s that must be saved across yield points.\nLooks for any assignments between locals (e.g., <code>_4 = _5</code>) …\nAn operation that can be performed on a coroutine.\nA <code>yield</code> point in the coroutine.\nThis pass constructs a second coroutine body sufficient …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nFor every saved local, looks for which locals are …\nWhich block to jump to if the coroutine is dropped in this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReplaces the entry point of <code>body</code> with a block that …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over each <code>CoroutineSavedLocal</code> along …\nThe set of saved locals live at each suspension point.\nComputes which locals have to be stored in the …\nTransforms a <code>BitSet&lt;Local&gt;</code> that contains only locals saved …\nAllocates a new local and replaces all references of <code>local</code> …\nThe block to jump to after resumption.\nWhere to move the resume argument after resumption.\nWhich locals are live across any suspension point.\nParallel vec to the above with SourceInfo for each yield …\nState discriminant used when suspending or resuming at …\nFor every saved local, the set of other saved locals that …\nSet of locals that have live storage while at this …\nFor every suspending block, the locals which are …\nTransforms the <code>body</code> of the coroutine applying the …\nTransforms the <code>body</code> of the coroutine applying the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nVerify that the callee body is compatible with the caller.\nAdd function-level costs not well-represented by the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFunction information extracted from HIR by the coverage …\nInserts <code>StatementKind::Coverage</code> statements that either …\nIf <code>llvm-cov</code> sees a source region that is improperly …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nFor each coverage span extracted from MIR, create a …\nThe span of the function’s signature, extended to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\n“Holes” are regions within the body span that should …\nFor each BCB node or BCB edge that has an associated …\nGiven two basic blocks that have a control-flow edge …\nFor each conditions inject statements to update condition …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the Span into its file name, start line and …\nThe coverage counter or counter expression associated with …\nGenerates and stores coverage counter and coverage …\nHelper struct that allows counter creation to inspect the …\nCoverage counters/expressions that are associated with …\nCoverage counters/expressions that are associated with the …\nReturns an iterator over the subset of BCB nodes that have …\nGiven a set of candidate out-edges (represented by their …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns an iterator over all the nodes/edges in the …\nList of places where a counter-increment statement should …\nTable of expression data, associating each expression ID …\nRemember expressions that have already been created (or …\nGiven a set of candidate out-edges (represented by their …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnsures that each BCB node needing a counter has one, by …\nShared helper used by <code>Self::make_phys_node_counter</code> and …\nThis is an associated function so that we can call it …\nMake sure the given node has a node counter, and then make …\nCreates a new physical counter attached to a BCB edge. The …\nCreates a new physical counter attached a BCB node. The …\nCreates a counter that is the sum of the given counters.\nA node in the control-flow graph of CoverageGraph.\n<code>BasicCoverageBlockData</code> holds the data indexed by a …\nThe terminator has exactly one straight-line successor, so …\nA coverage-specific simplification of the MIR control flow …\nHolds the coverage-relevant successors of a basic block’…\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nThe block cannot be combined into the same BCB as its …\nMaintains separate worklists for each loop in the …\nYield terminators are not chainable, and their execution …\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the terminator itself is assumed to have …\nIf true, this node’s execution count can be assumed to …\nBCB with one or more incoming loop backedges, indicating …\nFor each loop on the loop context stack (top-down), yields …\nReturns the target of this node’s sole out-edge, if it …\nReturns the source of this node’s sole in-edge, if it …\nWorklist of BCBs to be processed in this context.\nThis is separate from <code>MCDCBranch</code> to help prepare for …\nAssociates an ordinary executable code span with its …\nAssociates an MC/DC branch span with condition info …\nAssociates an MC/DC decision with its join BCBs.\nReturns the set of BCBs that have one or more <code>Code</code> …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nExtracts coverage-relevant spans from MIR, and associates …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStore our own copy of <code>CoverageGraph::num_nodes</code>, so that we …\nQuery implementation for <code>coverage_attr_on</code>.\nQuery implementation for <code>coverage_ids_info</code>.\nHook implementation for <code>TyCtxt::is_eligible_for_coverage</code>.\nRegisters query/hook implementations related to coverage.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCompares two spans in (lo ascending, hi descending) order.\nUses the holes to divide the given covspans into buckets, …\nSimilar to <code>.drain(..)</code>, but stops just before it would …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf <code>self</code> and <code>other</code> can be merged (i.e. they have the same …\nMacros that expand into branches (e.g. <code>assert!</code>, <code>trace!</code>) …\nTakes one of the buckets of (sorted) spans extracted from …\nSplits this covspan into 0-2 parts:\nWhen a span corresponds to a macro invocation that is …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nTraverses the MIR body to produce an initial collection of …\nIf the MIR <code>Statement</code> has a span contributive to computing …\nIf the MIR <code>Terminator</code> has a span contributive to computing …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA span that has been extracted from MIR and then “…\nWalks through the expansion ancestors of <code>original_span</code> to …\nWalks through the expansion ancestors of <code>original_span</code> to …\nWalks through the expansion ancestors of <code>original_span</code> to …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe caller must have flooded <code>place</code>.\nThe caller must have flooded <code>place</code>.\nStores the assigned values for assignments where the …\nFor a given MIR location, this stores the values of the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nPerforms the optimization on the body\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA visitor that determines which arguments have been …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the deduced parameter attributes for a function.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEach bit is indexed by argument number, starting at zero …\nReturns a new DeduceReadOnly instance.\nReturns true if values of a given type will never be …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDescribes where a statement/terminator writes to\nThe set of candidates we are considering in this …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\n<code>vec_filter_candidates</code> but for an <code>Entry</code>\nFor all candidates <code>(p, q)</code> or <code>(q, p)</code> removes the candidate …\nFilters the set of candidates to remove those that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSome locals are part of the function’s interface and can …\nIf the pair of places is being considered for merging, …\nCollects the candidates for merging.\nA reverse index of the <code>c</code> set; if the <code>c</code> set contains …\nIf this pair of locals is a candidate pair, completely …\nJust <code>Vec::retain</code>, but the condition is inverted and we add …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis pass optimizes something like\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs the projection needed to access a Box’s …\nConstructs the types used when accessing a Box’s pointer\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDuring MIR building, Drop terminators are inserted in …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nRecords unwind edges which are known to be unreachable, …\ncreate a patch that elaborates all drops in the input MIR.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmits a lint for function reference arguments bound by …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf a type is a reference or raw pointer to the anonymous …\nIf the given predicate is the trait <code>fmt::Pointer</code>, returns …\nEmits a lint for function reference arguments bound by …\nThe address of a place.\nAn aggregate value, either tuple/closure/struct/enum. This …\nComputing the aggregate’s type can be quite slow, so we …\nInvariant: this must not be used for an empty array.\nEvaluated or unevaluated constant value.\nDiscriminant of the given value.\nLength of an array or slice.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nUsed to represent values we know nothing about. The <code>usize</code> …\nThis is the <em>value</em> obtained by projecting another value.\nThis corresponds to a <code>[value; count]</code> expression.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nRecord that <code>local</code> is assigned <code>value</code>. <code>local</code> must be SSA.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nValues evaluated as constants if possible.\nCache the value of the <code>unsized_locals</code> features, to avoid …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nValue stored in each local.\nCreate a new <code>Value</code> for which we have no information at …\nCreate a new <code>Value::Address</code> distinct from all the others.\nCounter to generate different values. This is an option to …\nLocals that are assigned that value.\nSimplify the projection chain if we know better.\nRepresent the <em>value</em> which would be read from <code>place</code>, and …\nIf <code>index</code> is a <code>Value::Constant</code>, return the <code>Constant</code> to be …\nIf there is a local which is assigned <code>index</code>, and its …\nIf either <code>Self::try_as_constant</code> as <code>Self::try_as_local</code> …\nNeeded for cast propagation.\nThe data pointer can be anything thin, so doesn’t …\nSome constants do not have a deterministic value. To avoid …\nGive each borrow and pointer a different provenance, so we …\nIntegrator.\nIndicates that the caller is #inline and just calls …\nIndicates that the caller body has been modified.\nReturns an error if inlining is not possible based on …\nReturns inlining decision that is based on the examination …\nCaller codegen attributes.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nIf <code>arg</code> is already a temporary, returns it. Otherwise, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nStack of inlined instances. We only check the <code>DefId</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIntroduces a new temporary into the caller body that is …\nAttempts to inline a callsite into the caller body. When …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransform boolean comparisons into logical operations.\nTransform <code>Len([_; N])</code> ==&gt; <code>N</code>.\nTransform <code>Aggregate(RawPtr, [p, ()])</code> ==&gt; <code>Cast(PtrToPtr, p)</code>.\nTransform <code>&amp;(*a)</code> ==&gt; <code>a</code>.\nRepresent the following statement. If we can prove that …\nApply the opportunities on the graph.\nWe use an arena to avoid cloning the slices when cloning …\nThe list of <code>BasicBlock</code>s from the one that found the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nRecursively walk statements backwards from this bb’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFor each bb, give the TOs in which it appears. The pair …\nCompute the set of loop headers in the given body. We …\nExtract the mutated place from a statement.\nCache the number of predecessors for each block, as we …\nIf we expect <code>lhs ?= A</code>, we have an opportunity if we assume …\nRecursion entry point to find threading opportunities.\nThe <code>SwitchInt</code> will be replaced by <code>Goto { target }</code>.\nA visitor that determines locals in a MIR body that can be …\nThe mode that <code>ConstProp</code> is allowed to run in for a given …\nVisits MIR nodes, performs const propagation and runs lint …\nThe <code>Local</code> can be propagated into and reads of this <code>Local</code> …\nThe maximum number of bytes that we’ll allocate space …\nThe <code>Local</code> cannot be part of propagation at all. Any …\nThe <code>Local</code> can only be propagated into and from its own …\nReturns true if <code>local</code> can be propagated\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the value, if any, of evaluating <code>c</code>.\nReturns the value, if any, of evaluating <code>op</code>. Calls upon …\nReturns the value, if any, of evaluating <code>place</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemove <code>local</code> from the pool of <code>Locals</code>. Allows writing to …\nA pass that seeks to optimize unnecessary moves of large …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEnum variant comparison type.\nIdentical statements.\nAssignment statements have the same value.\nCheck if the cast constant using <code>IntToInt</code> is equal to the …\nCheck that the BBs to be simplified satisfies all distinct …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSimplifies a match statement, returning true if the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis pass looks for MIR that always copies the same local …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMIR that is eligible for the NRVO must fulfill two …\nAn adapter for <code>MirLint</code>s that implements <code>MirPass</code>.\nJust like <code>MirPass</code>, except it cannot mutate <code>Body</code>, and MIR …\nA streamlined trait that you can implement to create a …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this pass is enabled with the current …\nThe optional <code>phase_change</code> is applied after executing all …\nRun the sequence of passes without validating the MIR …\nConverts a MIR pass name into a snake case form to match …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRearranges the basic blocks into a <em>reverse post-order</em>.\nRearranges the locals into <em>use</em> order.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA “root candidate” for promotion, which will become the\nOne direct assignment and any number of direct uses. A …\nA <code>MirPass</code> for promotion.\nThis temp was part of an rvalue which got extracted during …\nState of a temporary during collection and promotion.\nNo references to this temp.\nAny other combination of assignments/uses.\nChecks whether locals that appear in a promotion context (…\nIf true, add the new const (the promoted) to the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the block is “safe” for promotion, …\nIf true, all nested temps are also kept in the source MIR, …\nCopies the initialization of this temp to the promoted …\nComputes the sets of blocks of this MIR that are …\nFor backwards compatibility, we are promoting function …\nUsed to assemble the required_consts list while building …\nWe know the value to be a pointer to this place. The …\nPropagate references using SSA analysis.\nUtility to help performing substitution of <code>*pattern</code> by …\nNot a pointer, or we can’t know.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nFor each local, save the place corresponding to <code>*local</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCompute the set of locals that can be fully replaced.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA pass that removes noop landing pads and replaces jumps …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRemoves <code>Drop</code> terminators whose target is known to be …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA cheap, approximate check to avoid unnecessary <code>layout_of</code> …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWe get passed a reference or a raw pointer to <code>self</code> and …\nCall a known <code>FnDef</code>.\nPass the receiver as-is.\n<code>fn shim(&amp;self) { inner(*self )}</code>.\nCall the <code>FnPtr</code> that was passed as the receiver.\n<code>fn shim(*mut self) { inner(*self )}</code>.\n<code>fn shim(&amp;mut self) { inner(*self )}</code>.\nWe get passed <code>self: Self</code> and call the target with <code>&amp;mut self</code>…\nGives the index of an upcoming BasicBlock, with an offset. …\nBuilds a “call” shim for <code>instance</code>. The shim calls the …\nBuilds a <code>Clone::clone</code> shim for <code>self_ty</code>. Here, <code>def_id</code> is …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuilder for async_drop_in_place shim. Functions as a stack …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven that <code>Self is [ElemTy; N]</code> puts <code>to_drop: *mut [ElemTy]</code> …\nIf given Self is an enum puts <code>to_drop: *mut FieldTy</code> on top …\nIf given Self is a struct puts <code>to_drop: *mut FieldTy</code> on top\nPuts <code>noop: async_drop::Noop</code> on top of the stack\nPuts operand on top of the stack.\nPuts <code>to_drop: *mut Self</code> on top of the stack.\nPuts <code>x: RvalueType</code> on top of the stack.\nIf given Self is an enum puts <code>to_drop: *mut FieldTy</code> on top …\nRuns at the beginning of “analysis to runtime” …\nRuns at the end of “analysis to runtime” lowering, …\nKeeps track of used &amp; unused locals.\nCollapse a goto chain starting from <code>start</code>\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if local is used.\nConstruct the mapping while swapping out unused stuff out …\nDetermines which locals are used &amp; unused in the given …\nRemoves unused definitions. Updates the used locals to …\nUpdates the use counts to reflect the removal of given …\nThis function will return <code>None</code> if\nVisits a left-hand side of an assignment.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPass to convert <code>if</code> conditions on integrals into switches …\nBasic block to apply the optimization\nStatement index of Eq/Ne assignment that can be removed. …\nConstant to use in switch target value\nType of the constant value\nCan remove Eq/Ne assignment\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEither Eq or Ne\nCurrent targets used in the switch\nPlace that needs to be switched on. This place is of type …\nVarious parts of MIR building introduce temporaries that …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is used to check that we are not leaving references …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCompute the replacement of flattened places into locals.\nIdentify all locals that are not eligible for SROA.\nPre-computed list of all “new” locals for each “old…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is only used to compute the type for …\nPerform the replacement computed by <code>compute_flattening</code>.\nWork to do.\nWe visit the body in reverse postorder, to ensure each …\nAssignments to each local. This defines whether the local …\nSet of SSA locals that are immutably borrowed.\nSet of SSA locals that are immutably borrowed.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCompute the equivalence classes for locals, based on copy …\nCopy equivalence classes between locals. See <code>copy_classes</code> …\nNumber of “direct” uses of each local, ie. uses that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a property uniform on a copy equivalence class by …\nReturn the number of uses if a local that are not “Deref…\nSet of “StorageLive” statements for each local.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nIf the basic block terminates by switching on a …\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn whether the current terminator is fully unreachable.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if src can be assigned into dest. This is not …\nThe phase for which we are upholding the dialect. If the …\nCheck that the given predicate definitely holds in the …\nA faster version of the validation pass that only checks …\nDescribes at which point in the pipeline this validation …")