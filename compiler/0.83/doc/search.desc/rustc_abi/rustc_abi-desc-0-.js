searchState.loadedDescShard("rustc_abi", 0, "Describes how values of the type are passed by target ABIs,\nA pair of alignments, ABI-mandated and preferred.\nAn identifier that specifies the address space that some …\nAlignment of a type in bytes (always a power of two).\nA tuple, closure, or univariant which cannot be coerced to …\nStruct-like placement, with precomputed offsets.\nArray/vector-like placement, with all fields of identical …\nBox. <code>unpin</code> indicates the absence of any pinned data. <code>global</code>…\nThe default address space, corresponding to data space.\nThe tag directly stores the discriminant, but possibly …\nA union had no fields.\nEndianness of the target, which must match …\nDescribes how the fields of a type are located in memory.\nFixed-sized integer type, e.g. <code>i8</code>, <code>u32</code>, <code>i128</code>. The bool …\nFloating-point types.\nRequirements for a <code>StableHashingContext</code> to be used in this …\nThe <code>bool</code> is the signedness of the <code>Integer</code> type.\nIntegers, also used for enum discriminants.\nA univariant, the last field of which may be coerced to …\nEnum-likes with more than one variant: each variant comes …\nMutable reference. <code>unpin</code> indicates the absence of any …\nNiche (values invalid for a type) encoding the …\nNote that this information is advisory only, and backends …\nPointer-sized integer type, i.e. <code>isize</code> and <code>usize</code>. The …\nA univariant, but with a prefix of an arbitrary size &amp; …\nFundamental unit of memory access and layout.\nScalar primitives and <code>!</code>, which never have fields.\nRepresents the repr options provided by the user.\nInformation about one scalar component of a Rust type.\nShared reference. <code>frozen</code> indicates the absence of any …\nSingle enum variants, structs/tuples, unions, and all …\nSize of a type in bytes.\nA type was too large for the target platform.\nParsed Data layout for a target, which contains everything …\nAn unsized type was found in a location where a sized type …\nAll fields start at no offset. The <code>usize</code> is the field …\nInclusive wrap-around range of valid values, that is, if …\nThe <code>abi</code> defines how this data is passed between functions, …\nGet a flags value with all known bits set.\nFind the largest integer with the given alignment or less.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nMinimum size of #[repr(C)] enums (default c_int::BITS, …\nReturns <code>true</code> if this type is valid for reordering and …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nReturns <code>true</code> if <code>v</code> is contained in the range.\nCreates an instance of <code>TargetDataLayout</code>.\nThe intersection of a source flags value with the …\nReturns the discriminant type, given these <code>repr</code> options. …\nGet a flags value with all bits unset.\nChecks if these two <code>Layout</code> are equal enough to be …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe seed to be used for randomizing a type’s layout\nSays where the fields are located within the layout.\nFinds the smallest Integer type which can represent the …\nFinds the smallest Integer type which can represent the …\nFinds the smallest integer with the given alignment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the Integer type from an IntegerType.\nConvert from a bits value.\nRounds <code>bits</code> up to the next-higher byte boundary, if <code>bits</code> is\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGets source indices of the fields by increasing offsets.\nReturns the fixed alignment of this ABI, if any is …\nReturns the fixed size of this ABI, if any is mandated.\nReturns <code>true</code> if this <code>#[repr()]</code> should inhabit “smart enum\nReturns <code>true</code> if this <code>#[repr()]</code> guarantees a fixed field …\nReturns <code>true</code> if this <code>#[repr()]</code> should inhibit union ABI …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the type is sized and a 1-ZST (meaning it …\nWhether all known bits in this flags value are set.\nReturns <code>true</code> if all possible numbers are valid, i.e …\nReturns <code>true</code> if this is a bool\nWhether all bits in this flags value are unset.\nReturns <code>true</code> if <code>size</code> completely fills the range.\nReturns <code>true</code> if this is a scalar type\nReturns <code>true</code> if this is a single signed integer scalar\nReturns <code>true</code> if this is an uninhabited type\nReturns <code>true</code> if this type can be left uninit.\nReturns <code>true</code> if the layout corresponds to an unsized type.\nReturns <code>true</code> if the layout corresponds to an unsized type.\nReturns <code>true</code> if the type is a ZST and not unsized.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe leaf scalar with the largest number of invalid values …\nComputes the best alignment possible for the given offset …\nThe largest alignment explicitly requested with <code>repr(align)</code>…\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nReturns <strong>exclusive</strong> upper bound on object size in bytes.\nParse data layout from an llvm data layout string\nGet the primitive representation of this type, ignoring …\nThe intersection of a source flags value with the …\nLower the alignment, if necessary, such that the given …\nIf this is <code>None</code>, then this is a raw pointer, so size and …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nTruncates <code>value</code> to <code>self</code> bits and then sign-extends it to …\nReturns the largest signed value that can be represented …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nDiscard validity range information and allow undef.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nTruncates <code>value</code> to <code>self</code> bits.\nThe alignment the type would have, ignoring any <code>repr(align)</code>…\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nAllows the caller to mutate the valid range. This …\nEncodes information about multi-variant layouts. Even with …\nAlignments for vector types.\nReturns <code>self</code> with replaced <code>end</code>\nReturns <code>self</code> with replaced <code>start</code>\nIf true, the size is exact, otherwise it’s only a lower …\nMaps source order field indices to memory order indices, …\nOffsets for the first byte of each field, ordered to match …\nEven for unions, we need to use the correct registers for …\nA union had no fields.\nContains the error value\nDetermines towards which end of a struct layout …\nContains the success value\nA type was too large for the target platform.\nAn unsized type was found in a location where a sized type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nsingle-variant enums are just structs, if you think about …")