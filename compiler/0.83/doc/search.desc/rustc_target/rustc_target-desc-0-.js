searchState.loadedDescShard("rustc_target", 0, "Some stuff used by rustc that doesn’t have many …\nRequirements for a <code>StableHashingContext</code> to be used in this …\nThe name of rustc’s own place to organize libraries.\nThe name of the directory rustc expects libraries to be …\nReturns a <code>rustlib</code> path for this particular target, …\nFlexible target specification.\nDescribes how values of the type are passed by target ABIs,\nA pair of alignments, ABI-mandated and preferred.\nAn identifier that specifies the address space that some …\nAlignment of a type in bytes (always a power of two).\nA tuple, closure, or univariant which cannot be coerced to …\nStruct-like placement, with precomputed offsets.\nArray/vector-like placement, with all fields of identical …\nBox. <code>unpin</code> indicates the absence of any pinned data. <code>global</code>…\nThe default address space, corresponding to data space.\nThe tag directly stores the discriminant, but possibly …\nA union had no fields.\nEndianness of the target, which must match …\nEquivalent to <code>VariantIdx(0)</code>.\nThe <em>source-order</em> index of a field in a variant.\nDescribes how the fields of a type are located in memory.\nFixed-sized integer type, e.g. <code>i8</code>, <code>u32</code>, <code>i128</code>. The bool …\nFloating-point types.\nFloating-point types.\nRequirements for a <code>StableHashingContext</code> to be used in this …\nThe <code>bool</code> is the signedness of the <code>Integer</code> type.\nIntegers, also used for enum discriminants.\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nA univariant, the last field of which may be coerced to …\nEnum-likes with more than one variant: each variant comes …\nMutable reference. <code>unpin</code> indicates the absence of any …\nNiche (values invalid for a type) encoding the …\nNote that this information is advisory only, and backends …\nPointer-sized integer type, i.e. <code>isize</code> and <code>usize</code>. The …\nA univariant, but with a prefix of an arbitrary size &amp; …\nFundamental unit of memory access and layout.\nScalar primitives and <code>!</code>, which never have fields.\nRepresents the repr options provided by the user.\nInformation about one scalar component of a Rust type.\nShared reference. <code>frozen</code> indicates the absence of any …\nSingle enum variants, structs/tuples, unions, and all …\nSize of a type in bytes.\nA type was too large for the target platform.\nParsed Data layout for a target, which contains everything …\nTrait that needs to be implemented by the higher-level …\nThe layout of a type, alongside the type itself. Provides …\nAn unsized type was found in a location where a sized type …\nAll fields start at no offset. The <code>usize</code> is the field …\nThe <em>source-order</em> index of a variant in a type.\nInclusive wrap-around range of valid values, that is, if …\nZero value of the index.\nZero value of the index.\nThe <code>abi</code> defines how this data is passed between functions, …\nGet a flags value with all known bits set.\nFind the largest integer with the given alignment or less.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nMinimum size of #[repr(C)] enums (default c_int::BITS, …\nReturns <code>true</code> if this type is valid for reordering and …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nReturns <code>true</code> if <code>v</code> is contained in the range.\nCreates an instance of <code>TargetDataLayout</code>.\nThe intersection of a source flags value with the …\nReturns the discriminant type, given these <code>repr</code> options. …\nGet a flags value with all bits unset.\nChecks if these two <code>Layout</code> are equal enough to be …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe seed to be used for randomizing a type’s layout\nSays where the fields are located within the layout.\nFinds the smallest Integer type which can represent the …\nFinds the smallest Integer type which can represent the …\nFinds the smallest integer with the given alignment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the Integer type from an IntegerType.\nConvert from a bits value.\nRounds <code>bits</code> up to the next-higher byte boundary, if <code>bits</code> is\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nReturns <code>Homogeneous</code> if this layout is an aggregate …\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nGets source indices of the fields by increasing offsets.\nReturns the fixed alignment of this ABI, if any is …\nReturns the fixed size of this ABI, if any is mandated.\nReturns <code>true</code> if this <code>#[repr()]</code> should inhabit “smart enum\nReturns <code>true</code> if this <code>#[repr()]</code> guarantees a fixed field …\nReturns <code>true</code> if this <code>#[repr()]</code> should inhibit union ABI …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the type is sized and a 1-ZST (meaning it …\nReturns <code>true</code> if this is an aggregate type (including a …\nWhether all known bits in this flags value are set.\nReturns <code>true</code> if all possible numbers are valid, i.e …\nReturns <code>true</code> if this is a bool\nWhether all bits in this flags value are unset.\nWhether the layout is from a type that implements …\nReturns <code>true</code> if this is a scalar type\nReturns <code>true</code> if this is a single signed integer scalar\nReturns <code>true</code> if this is an uninhabited type\nReturns <code>true</code> if this type can be left uninit.\nReturns <code>true</code> if the layout corresponds to an unsized type.\nReturns <code>true</code> if the layout corresponds to an unsized type.\nReturns <code>true</code> if the type is a ZST and not unsized.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe leaf scalar with the largest number of invalid values …\nComputes the best alignment possible for the given offset …\nThe largest alignment explicitly requested with <code>repr(align)</code>…\nFinds the one field that is not a 1-ZST. Returns <code>None</code> if …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nReturns <strong>exclusive</strong> upper bound on object size in bytes.\nParse data layout from an llvm data layout string\nGet the primitive representation of this type, ignoring …\nThe intersection of a source flags value with the …\nLower the alignment, if necessary, such that the given …\nIf this is <code>None</code>, then this is a raw pointer, so size and …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nTruncates <code>value</code> to <code>self</code> bits and then sign-extends it to …\nReturns the largest signed value that can be represented …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nDiscard validity range information and allow undef.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nTruncates <code>value</code> to <code>self</code> bits.\nThe alignment the type would have, ignoring any <code>repr(align)</code>…\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nAllows the caller to mutate the valid range. This …\nEncodes information about multi-variant layouts. Even with …\nAlignments for vector types.\nIf true, the size is exact, otherwise it’s only a lower …\nMaps source order field indices to memory order indices, …\nOffsets for the first byte of each field, ordered to match …\nEven for unions, we need to use the correct registers for …\nError produced by attempting to adjust a <code>FnAbi</code>, for a “…\nInformation about how to pass an argument to, or return a …\nA compact representation of LLVM attributes (at least …\nSometimes an ABI requires small integers to be extended to …\nPass the argument after casting it. See the <code>CastTarget</code> …\nDescribes the type used for <code>PassMode::Cast</code>.\nPass the argument directly.\nMetadata describing how the arguments to a native function …\nError from the <code>homogeneous_aggregate</code> test function, …\nYes, all the “leaf fields” of this struct are passed …\nReturn value from the <code>homogeneous_aggregate</code> test function.\nIgnore the argument.\nPass the argument indirectly via a hidden pointer.\nThere are no leaf fields at all.\nPass a pair’s elements directly in two arguments.\nAn argument passed entirely registers with the same kind …\nTarget architecture doesn’t support “foreign” (i.e. …\nThe type, layout, and information about how each argument …\nLLVM-frontend specific AVR calling convention …\nMarks this function as variadic (accepting a variable …\nIndicates if an unwind may happen across a call to this …\nPass using one or more consecutive values of the given …\nThe calling convention of this function.\nChecks if these two <code>PassMode</code> are equal enough to be …\nChecks if these two <code>ArgAttributes</code> are equal enough to be …\nChecks if these two <code>CastTarget</code> are equal enough to be …\nChecks if these two <code>ArgAbi</code> are equal enough to be …\nThe count of non-variadic arguments.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndicate that the argument is consecutive, in the sense …\nPass this argument directly instead. Should NOT be used! …\nPass this argument indirectly, by passing a (thin or wide) …\nSame as <code>make_indirect</code>, but for arguments that are ignored. …\nTry to combine two <code>HomogeneousAggregate</code>s, e.g. from two …\nPass using one or more values of the given type, without …\nThis defines the “default ABI” for that type, that is …\nPass this argument indirectly, by placing it at a fixed …\nThe minimum size of the pointee, guaranteed to be valid …\nThe layout, type, and the way a value is returned from …\nThe total size of the argument, which can be:\nWhen you only access the range containing valid data, you …\nIf this is a homogeneous aggregate, returns the homogeneous\nThe Xtensa ABI implementation\nIndicates the variant of the AArch64 ABI we are compiling …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nthe pass mode used for aggregates in arg and ret position\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe purpose of this ABI is to match the C ABI (aka clang) …\nThe purpose of this ABI is for matching the WebAssembly …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nClassification of “eightbyte” components.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet of types which can be used with a particular register …\nReturns the full set of allocatable registers for a given …\nReturns the set of registers which are clobbered by this …\nReturns the default modifier for this register and an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether registers in this class can only be used …\nParses a clobber ABI for the given target, or returns a …\nReturns a suggested register class to use for this type. …\nReturns a suggested template modifier to use for this type …\nReturns a list of supported types for this register class, …\nReturns the list of template modifiers that can be used …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresents a JSON array.\nRepresents a JSON boolean.\nRepresents any valid JSON value.\nRepresents a JSON null value.\nRepresents a JSON number, whether integer or floating …\nRepresents a JSON object.\nRepresents a JSON string.\nIf the <code>Value</code> is an Array, returns the associated vector. …\nIf the <code>Value</code> is an Array, returns the associated mutable …\nIf the <code>Value</code> is a Boolean, returns the associated bool. …\nIf the <code>Value</code> is a number, represent it as f64 if possible. …\nIf the <code>Value</code> is an integer, represent it as i64 if …\nIf the <code>Value</code> is a Null, returns (). Returns None otherwise.\nIf the <code>Value</code> is a Number, returns the associated <code>Number</code>. …\nIf the <code>Value</code> is an Object, returns the associated Map. …\nIf the <code>Value</code> is an Object, returns the associated mutable …\nIf the <code>Value</code> is a String, returns the associated str. …\nIf the <code>Value</code> is an integer, represent it as u64 if …\nDisplay a JSON value as a string.\nConvert 64-bit floating point number to <code>Value::Number</code>, or …\nReturns the argument unchanged.\nConvert <code>()</code> to <code>Value::Null</code>.\nConvert a slice to <code>Value::Array</code>.\nConvert a <code>Vec</code> to <code>Value::Array</code>.\nConvert map (with string keys) to <code>Value::Object</code>.\nConvert <code>Number</code> to <code>Value::Number</code>.\nConvert copy-on-write string to <code>Value::String</code>.\nConvert string slice to <code>Value::String</code>.\nConvert <code>String</code> to <code>Value::String</code>.\nConvert boolean to <code>Value::Bool</code>.\nConvert 32-bit floating point number to <code>Value::Number</code>, or …\nCreate a <code>Value::Object</code> by collecting an iterator of …\nCreate a <code>Value::Array</code> by collecting an iterator of array …\nIndex into a JSON array or map. A string index can be used …\nMutably index into a JSON array or map. A string index can …\nIndex into a <code>serde_json::Value</code> using the syntax <code>value[0]</code> or\nWrite into a <code>serde_json::Value</code> using the syntax …\nCalls <code>U::from(self)</code>.\nReturns true if the <code>Value</code> is an Array. Returns false …\nReturns true if the <code>Value</code> is a Boolean. Returns false …\nReturns true if the <code>Value</code> is a number that can be …\nReturns true if the <code>Value</code> is an integer between <code>i64::MIN</code> …\nReturns true if the <code>Value</code> is a Null. Returns false …\nReturns true if the <code>Value</code> is a Number. Returns false …\nReturns true if the <code>Value</code> is an Object. Returns false …\nReturns true if the <code>Value</code> is a String. Returns false …\nReturns true if the <code>Value</code> is an integer between zero and …\nLooks up a value by a JSON Pointer.\nLooks up a value by a JSON Pointer and returns a mutable …\nTakes the value out of the <code>Value</code>, leaving a <code>Null</code> in its …\nGenerate stack canaries in all functions.\nForces the machine code generator to always preserve the …\nOn LLVM, mark all generated LLVM functions with the <code>ssp</code> …\nBorrowed data.\nLinker tool for BPF.\nInvoke the linker via a C/C++ compiler (e.g. on most unix …\nCRT objects (e.g. on <code>windows-gnu</code>, <code>musl</code>, <code>wasi</code> targets)\nCall <code>__rust_probestack</code> whenever stack needs to be probed.\nLinker is called through a C/C++ compiler.\nUnix-like linker for Apple targets (both naked and …\nWhich kind of debuginfo does the target use?\nDWARF debuginfo (such as that used on …\nDWARF debuginfo in dSYM files (such as on Apple platforms).\nRegular dynamic library (“dynamically linked”).\nDynamically linked non position-independent executable.\nDynamically linked position-independent executable.\nEmscripten Compiler Frontend, a wrapper around …\nThe target spec explicitly disables self-contained linking.\nUnix-like linker with GNU extensions (both naked and …\nThe target spec requests that the self-contained mode is …\nThe target spec requests that the self-contained mode is …\nIt is harmless to use this option even on targets that do …\nUse inline option for LLVM versions later than specified …\nlibc static library (e.g. on <code>musl</code>, <code>wasi</code> targets)\nLinker, dlltool, and their necessary libraries (e.g. on …\nUse the lld linker, either the system lld or the …\nLegacy ABI. Which is non-spec-compliant.\nEverything is flattened to a single enum to make the json …\nThe <code>-C link-self-contained</code> components that can …\nThe different <code>-Clink-self-contained</code> options that can be …\nThe <code>-Z linker-features</code> components that can individually be …\nAll linkers have some kinds of command line interfaces and …\nLinker flavors available externally through command line (…\nLLVM bitcode linker that can be used as a <code>self-contained</code> …\nLinker is LLD.\nOther MinGW libs and Windows import libs\nAllows the machine code generator to omit the frame …\nMSVC-style linker for Windows and UEFI, LLD supports it.\nForces the machine code generator to preserve the frame …\nDon’t emit any stack probes.\nDisable stack canary generation.\nSplit debug-information is disabled, meaning that on …\nOwned data.\nSplit debug-information can be found in a “packed” …\nProgram database files (such as on Windows).\nLinker tool for Nvidia PTX.\nSanitizer runtime libraries\nSpec-compliant C ABI.\nControls use of stack canaries.\nDynamic library with bundled libc (“statically linked”…\nStatically linked non position-independent executable.\nStatically linked position-independent executable.\nOn LLVM, mark all generated LLVM functions with the …\nList of supported targets\nEverything <code>rustc</code> knows about how to compile for a specific …\nMetadata about a target like the description or tier. Part …\nOptional aspects of a target specification.\nEither a target triple string or a path to a JSON file.\nWarnings encountered when parsing the target <code>json</code>.\nThe target spec explicitly enables self-contained linking.\nlibgcc/libunwind (e.g. on <code>windows-gnu</code>, <code>fuchsia</code>, <code>fortanix</code>, …\nBasic Unix-like linker for “any other Unix” targets …\nSplit debug-information can be found in individual object …\nWASI module with a lifetime past the _initialize entry …\nWhich C ABI to use for <code>wasm32-unknown-unknown</code>.\nUnix-like linker for Wasm targets (both naked and …\nThe target spec explicitly enables a list of …\nABI name to distinguish multiple ABIs on the same OS and …\nWhether the target toolchain’s ABI supports returning …\nAdd arguments for the given flavor and also for its “twin…\nGiven a function ABI, turn it into the correct ABI for …\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nReturns an array of all the components.\nIs asm!() allowed? Defaults to true.\nThe MinGW toolchain has a known issue that prevents it …\nArchitecture to use for ABI considerations. Valid options …\nFormat that archives should be emitted in. This affects …\nReturns whether at least a component is enabled.\nReturn the component’s name.\nReturn sanitizer’s name\nExtra arguments to pass to the external assembler (when …\nWhether the target supports atomic CAS operations natively\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nContent of the LLVM cmdline section associated with …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nMinimum number of bits in #[repr(C)] enum. Defaults to the …\nWidth of c_int type. Defaults to “32”.\nCode model to use. Corresponds to …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nDefault CPU to pass to LLVM. Corresponds to <code>llc -mcpu=$cpu</code>…\nObject files providing support for basic runtime …\nWhether or not linking dylibs to a static CRT is allowed.\nWhether or not the CRT is statically linked by default.\nWhether or not crt-static is respected by the compiler (or …\nHack for calling <code>deployment_target</code> outside of this module.\nCow-Vec-Str: Cow&lt;’static, [Cow&lt;’static, str&gt;]&gt;\nData layout to pass to LLVM.\nReturns an extended string triple for this target.\nWhich kind of debuginfo is used by this target?\nCreates a set of “sane defaults” for any target. This …\nDefault codegen backend used for this target. Defaults to …\nDefault number of codegen units to use in debug mode\nDefault supported version of DWARF on this platform. …\nWhether or not to emit <code>uwtable</code> attributes on functions if …\nThe default visibility for symbols in this target.\nA short description of the target including platform …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nDirect or use GOT indirect to reference external data …\nDo not emit code that uses the “red zone”, if the ABI …\nString to prepend to the name of every dynamic library. …\nString to append to the name of every dynamic library. …\nWhether dynamic linking can export TLS globals. Defaults …\nWhether dynamic linking is available on this target. …\nResolve the value of the EF_AVR_ARCH field for AVR ELF …\nWhether the linker is instructed to add a <code>GNU_EH_FRAME</code> ELF …\nWhether a .debug_gdb_scripts section will be added to the …\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nUsed as the <code>target_endian</code> <code>cfg</code> variable. Defaults to little …\nThe ABI of entry function. Default value is <code>Conv::C</code>, i.e. …\nThe name of entry function. Default value is “main”\nEnvironment name to use for conditional compilation (…\nString to append to the name of every executable.\nWhether executables are available on this target. Defaults …\nLoad a built-in target\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nValues of the <code>target_family</code> cfg set for this target.\nDefault target features to pass to LLVM. These features …\nWhether the target requires that emitted object code …\nFrame pointer mode for this target. Defaults to <code>MayOmit</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nAt this point the target’s reference linker flavor doesn…\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nLoads a target descriptor from a JSON object.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nCreates a target triple from the passed target path.\nParses a single <code>-Clink-self-contained</code> well-known …\nParses a single <code>-Z linker-features</code> well-known feature, not …\nCreates a target triple from the passed target triple …\nEmit each function in its own section. Defaults to true.\nWhether or not the DWARF <code>.debug_aranges</code> section should be …\nWhether the linker support rpaths or not. Defaults to …\nFlag indicating whether #thread_local is available for …\nIs true if the target is an ARM architecture using thumb …\nWhether the Rust project ships host tools for a target.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a None if the UNSUPPORTED_CALLING_CONVENTIONS lint …\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether the target is built-in or loaded from a custom …\nReturns whether the <code>cc</code> linker feature is enabled.\nReturns whether <code>LinkSelfContainedComponents::CRT_OBJECTS</code> …\nReturns whether the target spec has self-contained linking …\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether the target toolchain is like AIX’s. Linker …\nWhether a target toolchain is like Android, implying a …\nWhether the target is like MSVC. This is a combination of …\nWhether the target toolchain is like macOS’s. Only …\nWhether the target toolchain is like Solaris’s. Only …\nWhether a target toolchain is like WASM.\nWhether the target is like Windows. This is a combination …\nReturns whether <code>LinkSelfContainedComponents::LINKER</code> is …\nReturns whether the <code>lld</code> linker feature is enabled.\nReturns whether this <code>-C linker-flavor</code> option is one of the …\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nReturns the key to use when serializing the setting to …\nLinker arguments that are unconditionally passed after any …\nLinker arguments used in addition to <code>late_link_args</code> if at …\nLinker arguments used in addition to <code>late_link_args</code> if all …\nPass a list of symbol which should be exported in the …\nEnvironment variables to be set for the linker invocation.\nEnvironment variables to be removed for the linker …\nOptional link script applied to <code>dylib</code> and <code>executable</code> crate …\nBehavior for the self-contained linking mode: inferred for …\nLinker to invoke\nDefault linker flavor used if <code>-C linker-flavor</code> or <code>-C linker</code>…\nLLVM ABI name, corresponds to the ‘-mabi’ parameter …\nAdditional arguments to pass to LLVM, similar to the …\nUse LLVM intrinsic for mcount function name\nTarget triple to pass to LLVM.\nWhether the runtime startup code requires the <code>main</code> …\nMaximum integer size in bits that this target can perform …\nDon’t use this field; instead use the <code>.max_atomic_width()</code>…\nUse platform dependent mcount function\nDetermines how or whether the MergeFunctions LLVM pass …\nMetadata about a target, for example the description or …\nMinimum integer size in bits that this target can perform …\nDon’t use this field; instead use the <code>.min_atomic_width()</code>…\nThe minimum alignment for global symbols.\nWhether library functions call lowering/optimization is …\nWhether to disable linking to the default libraries, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThis is mainly for easy compatibility with emscripten. If …\nIf dynamic linking is available, whether only cdylibs are …\nOptional settings with defaults.\nOS name to use for conditional compilation (<code>target_os</code>). …\nIf set, have the linker export exactly these symbols, …\nPanic strategy: “unwind” or “abort”\nDetermines if the target always requires using the PLT for …\nNumber of bits in a pointer. Influences the …\nDynamically linked executables can be compiled as position …\nLinker arguments that are unconditionally passed <em>after</em> any …\nLinker arguments that are passed <em>before</em> any user-defined …\nObjects to link before and after all other object code.\nSame as <code>(pre|post)_link_objects</code>, but when self-contained …\nIt is intended that the “force frame pointer” …\nWhether or not RelaxElfRelocation flag will be passed to …\nRelocation model to use in object file. Corresponds to …\nEither partial, full, or off. Full RELRO makes the dynamic …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThis target requires everything to be compiled with LTO to …\nWhether or not to unconditionally <code>uwtable</code> attributes on …\nSearch for a JSON file specifying the given target triple.\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nWhether or not SIMD types are passed by reference in the …\nThis target has no support for threads.\nReturn the target’s small data threshold support, …\nWhether the targets supports -Z small-data-threshold\nHow to handle split debug information, if at all. …\nThe implementation of stack probes to use.\nExecutables that are both statically linked and …\nString to prepend to the name of every static library. …\nString to append to the name of every static library. …\nWhether a target has the <code>std</code> library. This is usually true …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe sanitizers supported by this target\nWhich kinds of split debuginfo are supported by the target?\nWhether the target supports stack canary checks. <code>true</code> by …\nWhether the target supports XRay instrumentation.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe tier of the target. 1, 2 or 3.\nTLS model to use. Options are “global-dynamic” …\nReturns the corresponding backwards-compatible CLI flavor.\nReturns the modern CLI flavor that is the counterpart of …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nWhether to generate trap instructions in places where …\nReturns a string triple for this target.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nWhether to use legacy .ctors initialization hooks rather …\nReturns whether the flavor calls the linker via a C/C++ …\nReturns whether the flavor uses the <code>lld</code> linker.\nVendor name to use for conditional compilation (…\nCreates a <code>LinkSelfContainedDefault</code> enabling the …\nFor flavors with an <code>Lld</code> component, ensure it’s disabled. …\nFor flavors with an <code>Lld</code> component, ensure it’s enabled. …\nWarning: This field may only be used by rustdoc. Using it …\nDefault ABI chosen for <code>extern fn</code> declarations without an …\nFor things unlikely to be called, where reducing register …\n<em>Not</em> a stable ABI, just directly use the Rust types to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the ABI with the given name (if any).\nName of this ABI as we like it called.\nGet the base target options, LLVM target and <code>target_arch</code> …\nGet the deployment target based on the standard …\nHack for calling <code>deployment_target</code> outside of this module.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerate the target triple that we need to pass to LLVM …\nParse an OS version triple (SDK version or deployment …\nResolve the value of the EF_AVR_ARCH field for AVR ELF …\nA base target for AVR devices using the GNU toolchain.\nTargets the ARMv4T, with code as <code>a32</code> code by default.\nTargets the ARMv5TE, with code as <code>a32</code> code by default.\nA target tuple for OpenWrt MIPS64 targets.\nBare MIPS32r2, little endian, softfloat, O32 calling …\nTargets the ARMv4T, with code as <code>t32</code> code by default.\nTargets the ARMv5TE, with code as <code>t32</code> code by default.\nA “bare wasm” target representing a WebAssembly output …\nNB: This target is in the process of being renamed to …\nThe <code>wasm32-wasip1</code> enables compiling to WebAssembly using …\nThe <code>wasm32-wasip1-threads</code> target is an extension of the …\nThe <code>wasm32-wasip2</code> target is the next evolution of the …\nA “bare wasm” target representing a WebAssembly output …\nA base target for Nintendo Switch devices using a pure …\nA base target for Nintendo 3DS devices using the devkitARM …\nA base target for PlayStation Vita devices using the …\nFeatures that require special handling when passing to …\nFeatures that control behaviour of rustc, rather than the …\nStability information for target features.\nThis target feature is stable, it can be used in …\nThis target feature is unstable; using it in …\nWhen rustdoc is running, provide a list of all known …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")