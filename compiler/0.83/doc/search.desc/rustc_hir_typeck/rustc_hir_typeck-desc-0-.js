searchState.loadedDescShard("rustc_hir_typeck", 0, "When <code>check_fn</code> is invoked on a coroutine (i.e., a body that …\nRaw content of Fluent resource for this crate, generated …\nControls whether the arguments are tupled. This is used …\nSome helper functions for <code>AutoDeref</code>.\nCheck whether <code>ty</code> can be coerced to <code>output_ty</code>. Used from …\nCode for type-checking cast expressions.\nCode for type-checking closure expressions.\nType Coercion\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nUsed only to get <code>TypeckResults</code> for type inference during …\nErrors emitted by <code>rustc_hir_typeck</code>.\nType checking expressions.\nA different sort of visitor for walking fn bodies. Unlike …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSame as <code>typeck</code> but <code>inspect</code> is invoked on evaluation of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMethod lookup: the secret sauce of Rust. See the rustc dev …\nCode related to processing overloaded binary and unary …\nType of coroutine argument / values returned by <code>yield</code>.\nInferring borrow kinds for upvars\nType of value that is yielded.\nCall overloading when callee implements one of the Fn* …\nChecks that it is legal to call methods of the trait …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReifies a cast check to be checked once we have full type …\nCast of int to (possibly) wide raw pointer.\nSlice\nThe unsize info of this projection or opaque type\nThe unsize info of this parameter\nThe kind of pointer and associated metadata (thin, length …\nCast of thin to wide raw ptr (e.g., …\nNo metadata attached, ie pointer to sized type or foreign …\nA trait object\nThe target type. That is, the type we are casting to.\nIf a cast from <code>from_ty</code> to <code>to_ty</code> is valid, returns a <code>Some</code> …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nChecks a cast, and report an error if one exists. In some …\nThe expression whose value is being casted\nThe source type for the cast expression\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAttempt to suggest using <code>.is_empty</code> when trying to cast …\nHelper used for fns and closures. Does the grungy work of …\nWhat signature do we <em>expect</em> the closure to have from …\nThe signature users of the closure see.\nSpan that gave us this expectation, if we know that.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe signature within the function body. This mostly …\nSomething that can be converted into an expression to …\nCoerceMany encapsulates the pattern you should use when …\nThe type of a <code>CoerceMany</code> that is storing up the …\nContains the error value\nContains the success value\nDetermines whether or not allow_two_phase_borrow is set on …\nCheck whether <code>ty</code> can be coerced to <code>output_ty</code>. Used from …\nIndicates that the value generated by <code>expression</code>, which is …\nReborrows <code>&amp;mut A</code> to <code>&amp;mut B</code> and <code>&amp;(mut) A</code> to <code>&amp;B</code>. To match <code>A</code> …\nAttempts to coerce from the type of a non-capturing closure\nIndicates that one of the inputs is a “forced unit”. …\nAttempts to coerce from the type of a Rust function item …\nAttempts to coerce from the type of a Rust function item …\nCoercing <em>from</em> an inference variable. In this case, we have …\nThe inner coercion “engine”. If <code>expression</code> is <code>None</code>, …\nCoercing a mutable reference to an immutable works, while …\nWhether we allow <code>NeverToAny</code> coercions. This is unsound if …\nApplies reborrowing for <code>Pin</code>\nPerforms [unsized coercion] by emulating a fulfillment …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the “expected type” with which this coercion …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDo not require any adjustments, i.e. coerce <code>x -&gt; x</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether the return type is unsized via an …\nReturns the current “merged type”, representing our …\nThe usual case; collect the set of expressions dynamically.\nThis always returns <code>Ok(...)</code>.\nUnify two types (using sub or lub) and produce a specific …\nAs an optimization, you can create a <code>CoerceMany</code> with a …\nWhen we fail during method argument checking, try to find …\nExpected the binding to have the given type, but it was …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDefinitely known to diverge and therefore not reach the …\nTracks whether executing a node may exit normally (versus …\nPotentially unknown, some cases converge, others require a …\nSame as <code>Always</code> but with a reachability warning already …\nCreates a <code>Diverges::Always</code> with the provided <code>span</code> and the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIn some cases (e.g. a <code>match</code> expression where all arms …\nThe <code>Span</code> points to the expression that caused us to diverge\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nRendered expression of the RHS of the range\nSpan of the LHS of the range\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSpan of the <code>..RHS</code> part of the range\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis expression will be cast to the <code>Ty</code>.\nThis expression should have the type given (or some …\nThis rvalue expression will be wrapped in <code>&amp;</code> or <code>Box</code> and …\nWhen type-checking an expression, we propagate downward …\nWe know nothing about what type this expression should …\nLike <code>only_has_type</code>, but instead of returning <code>None</code> if no …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIt sometimes happens that we want to turn an expectation …\nResolves <code>expected</code> by a single level if it is a variable. If\nProvides an expectation for an rvalue expression given an …\nThis trait defines the callbacks you can expect to receive …\nThe ExprUseVisitor type\nA named local variable.\nA <code>Place</code> represents how a value is located in memory.\nA <code>PlaceWithHirId</code> represents how a value is located in …\nA temporary variable.\nA named <code>static</code> item.\nAn upvar referenced by closure env.\nThe “outermost” place that holds this value.\nThe type of the <code>PlaceBase</code>\nThe path at <code>binding_place</code> is a binding that is being …\nThe value found at <code>place</code> is being borrowed with kind <code>bk</code>. …\nThis recursion helper avoids going through <em>too many</em> …\nHere, <code>place</code> is the <code>PlaceWithHirId</code> being matched and pat is …\nCategorize an upvar.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe value found at <code>place</code> is moved, depending on <code>mode</code>. …\nThe value found at <code>place</code> is being copied. <code>diag_expr_id</code> is …\nWe use a <code>RefCell</code> here so that delegates can mutate …\nReturns an iterator of the types that have to be …\nThe <code>place</code> should be a fake read because of specified <code>cause</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>HirId</code> of the expression or pattern producing this value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDefines the kind of access made by the projection.\nThe path at <code>assignee_place</code> is being assigned to. …\nCreates the ExprUseVisitor, configuring it with the …\nReturns the type of value that this pattern matches …\nLike <code>TypeckResults::pat_ty</code>, but ignores implicit <code>&amp;</code> …\nInformation about the <code>Place</code>.\nHow this place is derived from the base place.\nReturns the total number of fields in an ADT variant used …\nReturns the total number of fields in a tuple used within …\nReturns the type of this <code>Place</code> after all projections have …\nType after the projection is applied.\nReturns the type of this <code>Place</code> immediately before …\nReturns the variant index for an ADT used within a Struct …\nInvoke the appropriate delegate calls for anything that …\nWalks the autoref <code>autoref</code> applied to the autoderef’d <code>expr</code>…\nIndicates that the value of <code>blk</code> will be consumed, meaning …\nHandle the case where the current body contains a closure.\nWalks a pat that occurs in isolation (i.e., top-level of …\nThe core driver for walking a pattern\nSometimes fallback to <code>!</code>, but mainly fallback to <code>()</code> so that …\nDon’t fallback at all\nAlways fallback to <code>!</code> (which should be equivalent to never …\nAlways fallback to <code>()</code> (aka “always spontaneous decay”)\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nFinds all type variables which are passed to an <code>unsafe</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe <code>FnCtxt</code> stores type-checking context needed to …\nThe <code>ty</code> representation of a user-provided type. Depending …\nAdd all the obligations that are required, instantiated …\nRegisters obligations that all <code>args</code> are well-formed.\nCreates a string version of the <code>expr</code> that includes …\nReally hacky heuristic to remap an <code>assert_eq!</code> error to the …\nGiven a vector of fulfillment errors, try to adjust the …\nReturns the adjustment steps.\nAnalysis starting point.\nFinds item with name <code>item_name</code> defined in impl/trait <code>def_id</code>\n<code>blame_specific_*</code> means that the function will recursively …\nRecursively searches for the most-specific blameable …\nWe want to achieve the error span in the following example:\nDrills into <code>expr</code> to arrive at the equivalent location of …\nPrecondition: pat is a <code>Ref(_)</code> pattern\nHow should the binding mode and expected type be adjusted?\nCompute the new expected type and default binding mode …\nThe “diverging fallback” system is rather complicated. …\nChecks whether we can add a return type to a function. …\nSame as <code>coerce()</code>, but without side-effects.\nIdentify some cases where <code>as_ref()</code> would be appropriate …\nGeneric function that factors out common logic from …\nType check the length of an array pattern.\nWhen a variable is bound several times in a <code>PatKind::Or</code>, it…\nChecks a potentially overloaded binary operator.\nChecks a <code>a &lt;op&gt;= b</code>\nType check a <code>let</code> statement.\nType check assignment expression <code>expr</code> of form <code>lhs = rhs</code>. …\nInvariant: If an expression has any sub-expressions that …\nSame as <code>check_expr_with_expectation</code>, but allows us to pass …\nCheck if the expression that could not be assigned to was …\nThis method is called after we have encountered a missing …\nChecks a method call.\nDoes this expression refer to a place that either:\nType check the given <code>pat</code> against the <code>expected</code> type with …\nType check a slice pattern.\nType check the given top level pattern against the <code>expected</code>…\nCheck an expression that <em>is being returned</em>. For example, …\nProvide actionable suggestions when trying to add two …\nAttempt to coerce an expression to a type, and return the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nas opposed from the body of a while loop, which we can …\nFigures out the list of root variables (and their types) …\nFigures out the list of root variables (and their types) …\nFigures out the list of root variables (and their types) …\nCombines all the reasons for 2229 migrations\nAnalyzes the information collected by <code>InferBorrowKind</code> to …\nConvert auto-derefs, indices, etc of an expression from …\nDetermines whether the body of the coroutine uses its …\nReturns a graph whose nodes are (unresolved) inference …\nIf <code>ty</code> is <code>Option&lt;T&gt;</code>, returns <code>T, T, None</code>. If <code>ty</code> is …\nGiven the expected type, figures out what it can about …\nInvoked when we are translating the coroutine that results …\nGiven a projection like\nGiven a projection like “&lt;F as Fn(X)&gt;::Result == Y”, …\nReturns the default fallback which is used when there is …\nChecks that the type of <code>expr</code> can be coerced to <code>expected</code>.\nRequires that the two types unify, and prints an error …\nGiven a type, this function will calculate and return the …\nGiven a type and a target type, this function will …\nA captured place is mutable if\nWhether the last checked node generates a divergence (e.g.,\nEmit an error because <code>return</code> or <code>become</code> is used outside of …\nRequires that <code>element_ty</code> is <code>Copy</code> (unless it’s a const …\nCreates an <code>TypeErrCtxt</code> with a reference to the in-progress …\nReturns a diagnostic reporting a struct pattern which is …\nConverts the types that the user supplied, in case that …\nReturns a diagnostic reporting a struct pattern which does …\nExplain why <code>if</code> expressions without <code>else</code> evaluate to <code>()</code> and …\nWhether this expression constitutes a read of value of the …\nReturns <code>true</code> if an expression is contained inside the LHS …\nExtracts information about a callable type for …\nGiven an <code>FnOnce::Output</code> or <code>AsyncFn::Output</code> projection, …\nWhen an async closure is passed to a function that has a …\nFind the position of a field named <code>ident</code> in <code>base_def</code>, …\nTry to match an implementation of <code>Index</code> against a self …\nLook at all the associated functions without receivers in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf one of the function arguments is a never pattern, this …\nIf <code>expr</code> is a <code>match</code> expression that has only one non-<code>!</code> arm, …\nGiven a <code>HirId</code>, return the <code>HirId</code> of the enclosing function …\nReturns the parameters of a function, with their generic …\nThis function checks whether the method is not static and …\nThis is a helper function to …\nGive appropriate suggestion when encountering …\nHandle the fallback arm of a desugared if(-let) like a …\nA utility module to inspect currently ambiguous …\nInstantiates and normalizes the bounds for a given item\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the given expression is an <code>else if</code>.\nWhether the currently checked node is the whole body of …\nReport that a pattern for a <code>#[non_exhaustive]</code> struct …\nType-check <code>*oprnd_expr</code> with <code>oprnd_expr</code> type-checked …\nType-check <code>*base_expr[index_expr]</code> with <code>base_expr</code> and …\nPerforms method lookup. If lookup is successful, it will …\n<code>lookup_method_in_trait</code> is used for overloaded operators. …\nIf an appropriate error source is not found, check method …\nFor the overloaded place expressions (<code>*x</code>, <code>x[3]</code>), the trait …\nIf the given <code>HirId</code> corresponds to a block with a trailing …\nGive appropriate suggestion when encountering …\nEnforce the user’s types against the expectation. See …\nDetermines whether the type <code>self_ty</code> supports a visible …\nCreate a reference type with a fresh region variable.\nThe normalized form of <code>raw</code>, stored here for efficiency.\nNotes the point at which a variable is constrained to some …\nSuggest that <code>&amp;T</code> was cloned instead of <code>T</code> because <code>T</code> does not …\nGiven a type mismatch error caused by <code>&amp;T</code> being cloned …\nReturns a list of all obligations whose self type has been …\nThe parameter environment used for proving trait …\nWhether this pattern constitutes a read of value of the …\nUsed to determines whether we can infer the expected type …\nPeel off as many immediately nested <code>&amp; mut?</code> from the …\nPerform the migration analysis for RFC 2229, and emit lint …\nReturns the kind of unsize information of t, or None if t …\nThis is used to offer suggestions to users. It returns …\nInstantiate a QueryResponse in a probe context, without a …\nAdjusts the closure capture information to ensure that the …\nThe unnormalized type provided by the user.\nRegisters an obligation for checking later, during …\nSuggest possible range with adding parentheses, for …\nReport an error for a struct field expression when there …\nReport an error for a struct field expression when there …\nUnify the inference variables corresponding to coroutine …\nPerforms a full-qualified function call (formerly “…\nResolves an associated value path into a base type and …\nResolves type and const variables in <code>ty</code> if possible. …\nIf <code>Some</code>, this stores coercion information for returned …\nFirst span of a return site that we find. Used in error …\nIf <code>ty</code> is an unresolved type variable, returns its root vid.\nSelect as many obligations as we can at present.\nIf there is no expected signature, then we will convert the\nInvoked to compute the signature of a closure expression. …\nResolves <code>ty</code> by a single level if <code>ty</code> is a type variable.\nFor code <code>rect::area(...)</code>, if <code>rect</code> is a local variable and …\nSuggest calling <code>Ty::method</code> if <code>.method()</code> isn’t found …\nSuggest wrapping the block in square brackets instead of …\nGiven an expression type mismatch, peel any <code>&amp;</code> expressions …\nWhen encountering the expected boxed value allocated in …\nAttempts to reinterpret <code>method(rcvr, args...)</code> as …\nWhen encountering an <code>impl Future</code> where <code>BoxFuture</code> is …\nSuggest calling a field with a type that implements the <code>Fn*</code>…\nSuggest calling a method on a field i.e. <code>a.field.bar()</code> …\nIf the expected type is an enum (Issue #55250) with any …\nThis function is used to determine potential “simple” …\nissue #102320, for <code>unwrap_or</code> with closure as argument, …\nWhen encountering an fn-like type, try accessing the …\nIf the last field is a range literal, but it isn’t …\nAdds a suggestion to call the given method to the provided …\nIdentify when the user has written <code>foo..bar()</code> instead of …\nOn implicit return expressions with mismatched types, …\nA possible error is to forget to add a return type that is …\nA common error is to forget to add a semicolon at the end …\nWhen encountering a closure that captures variables, where …\nSuggest providing <code>std::ptr::null()</code> or <code>std::ptr::null_mut()</code> …\nWhen expecting a <code>bool</code> and finding an <code>Option</code>, suggests …\nIdentify when the type error is because <code>()</code> is found in a …\nIf there is no expected signature, then we will convert the\nGiven some expressions, their known unified type and …\nTo type-check <code>base_expr[index_expr]</code>, we progressively …\nTry to resolve an overloaded place op. We only deal with …\nTry to resolve <code>ty</code> to a structural type, normalizing …\ncheck whether the return type is a generic type with a …\nPrint out the type for use in value namespace.\nChecks whether there is a local type somewhere in the …\nPerforms type inference fallback, setting …\nWhen the previously checked expression (the scrutinee) …\nProduces warning on the given node, if the current point …\nGiven the args that we just converted from the HIR, try to …\nTraverses the given ty (either a <code>ty::Ty</code> or a <code>ty::GenericArg</code>…\nReturns <code>Some(iterator.next())</code> if it has exactly one item, …\nSimilar to <code>Issue</code>, but contains some extra information\nThere’s a superfluous argument\nThere’s a superfluous argument\nThe given argument is the invalid type for the input\nThe provided argument is the invalid type for the expected …\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nThere is a missing input\nThere is a missing input\nSeveral arguments should be reordered\nSeveral arguments should be reordered\nTwo arguments should be swapped\nTwo arguments should be swapped\nZero value of the index.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe first dimension (rows) are the remaining user provided …\nRemove a given argument from consideration\nRemove a given input from consideration\nMaps the indices in the <code>compatibility_matrix</code> columns to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps the indices in the <code>compatibility_matrix</code> rows to the …\n“satisfy” an input with a given arg, removing both …\nThis is the current stable behavior:\nAlternative behavior:\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nProvides context for checking patterns in declarations. …\nA declaration is an abstraction of hir::LetStmt and …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAllocates a type for a declaration, which may have a type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf the type is <code>Option&lt;T&gt;</code>, it will return <code>T</code>, otherwise the …\nMultiple methods might apply.\nFound a match, but the return type is wrong\nError has already been emitted, no need to emit another …\nFound a <code>Self: Sized</code> bound where <code>Self</code> is a trait object.\nDid not find an applicable method, but we did find various …\nFound an applicable method, but it is not visible. The …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nImpl method ID, for inherent methods, or trait method ID, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiated method signature, i.e., it has been …\nGive useful errors and suggestions to users when an item …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns a set of generic parameters for the method <em>receiver</em>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReceiver has type <code>T</code>, add <code>&amp;</code> or <code>&amp;mut</code> (if <code>T</code> is <code>mut</code>), and …\nWhen adjusting a receiver we often want to do one of\nContains the error value\nBoolean flag used to indicate if this search is for a …\nContains the success value\nReborrow a <code>Pin&lt;&amp;mut T&gt;</code> or <code>Pin&lt;&amp;T&gt;</code>.\nReceiver has type <code>*mut T</code>, convert to <code>*const T</code>\nWhen probing for names, include names that are close to the\nIndicates that the source expression should be autoderef’…\nIndicates that we want to add an autoref (and maybe also …\nUsed for ambiguous method call error reporting. Uses …\nSometimes we get in a situation where we have multiple …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nIn case there were unstable name collisions, emit them as …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFinds the method with the appropriate name (or return …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermine if the given associated item type is relevant in …\nIs this probe being done for a diagnostic? This will skip …\nDetermine if the associated item with the given DefId …\nIn case there were unstable name collisions, emit them as …\nThis is the OriginalQueryValues for the steps queries that …\nFor each type <code>T</code> in the step list, this attempts to find a …\nIf <code>self_ty</code> is <code>*mut T</code> then this picks <code>*const T</code> methods. The …\nLooks for applicable methods if we reborrow a <code>Pin&lt;&amp;mut T&gt;</code> …\nSome(candidate) if there is a private candidate\nList of potential private candidates. Will be trimmed to …\nSimilarly to <code>probe_for_return_type</code>, this method attempts …\nCollects near misses when the candidate functions are …\nCollects near misses when trait bounds for type parameters …\nUnstable candidates alongside the stable ones.\nWhen we’re looking up a method by path (UFCS), we relate …\nIndicates that the source expression should be “unsized…\nRetrieves all traits in this crate and any dependent …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n&amp;, |, ^ – takes equal types, produces same type as input,\n==, !=, etc – takes equal types, produces bools, except …\nWhether the binary operation is an assignment (<code>a += b</code>), or …\n+, -, etc – takes equal types, produces same type as …\n&lt;&lt;, &gt;&gt; – when shifting a single integer, rhs can be any …\n&amp;&amp;, || – cannot be overridden\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nDereferences a single level of immutable referencing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this is a built-in arithmetic operation …\nMode for adjusting the expected type and binding mode.\nNo restriction on mutability\n<code>ref mut</code> patterns (explicit or match-ergonomics) are not …\nMutability restricted to immutable.\nPass on the input binding mode and expected type.\nPeel off all immediate reference types.\nReset binding mode to the initial mode. Used for …\nInformation about the expected type at the top level of …\nMutability restricted to immutable, but only because of …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe depth of current pattern\nThe <code>expected</code> type at the top level of type checking a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe <code>HirId</code> of the top-level pattern.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWas the origin of the <code>span</code> from a scrutinee expression?\nThe span giving rise to the <code>expected</code> type, if one could be …\nApplied to an expression <code>expr</code> if <code>expr</code> – or something …\nData shared between a “typeck root” and its nested …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nWhen we process a call like <code>c()</code> where <code>c</code> is a closure type, …\nSome additional <code>Sized</code> obligations badly affect type …\nWhenever we introduce an adjustment from <code>!</code> into a type …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWe previously captured all of <code>x</code>, but now we capture some …\nIntermediate format to store a captured <code>Place</code> and …\nIntermediate format to store information needed to …\nReasons that we might issue a migration warning.\nIntermediate format to store the hir id of the root …\nDescribe the relationship between the paths of two places …\nIntermediate format to store the hir_id pointing to the …\nTruncate deref of any reference.\nAdjust closure capture just that if taking ownership of …\nReturns a Ty that applies the specified capture kind on …\nWhen we used to capture <code>x</code> in its entirety, we implemented …\nFor each Place that is captured by the closure, we track …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nHelper function to determine if we need to escalate …\nDetermines the Ancestry relationship of Place A relative …\nReturns the Span of where the value with the provided …\nWhen we used to capture <code>x</code> in its entirety, we would …\nPrecise capture is enabled if user is using Rust Edition …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn a two string tuple (s1, s2)\nreasons why migration is needed for this capture\nTruncate projections so that following rules are obeyed by …\nRust doesn’t permit moving fields out of a type that …\nTruncate <code>place</code> so that an <code>unsafe</code> block isn’t required to …\nTruncate the capture so that the place being borrowed is …\nDetermines whether a child capture that is derived from a …\nReduces the precision of the captured place when the …\nTruncates <code>place</code> to have up to <code>len</code> projections. <code>curr_mode</code> …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether we should normalize using the new solver, disabled …")