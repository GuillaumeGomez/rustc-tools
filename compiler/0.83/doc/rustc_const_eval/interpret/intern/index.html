<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module specifies the type based interner for constants."><title>rustc_const_eval::interpret::intern - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-49344e4802b2d48a.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rustc_const_eval" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-dev" data-channel="nightly" data-search-js="search-e056c65ede92db13.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../../../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../rustc_const_eval/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../rustc_const_eval/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2><a href="../../../rustc_const_eval/index.html">rustc_<wbr>const_<wbr>eval</a><span class="version">1.83.0-dev</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module intern</a></h2><h3><a href="#enums">Module Items</a></h3><ul class="block"><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#trait-aliases" title="Trait Aliases">Trait Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In rustc_<wbr>const_<wbr>eval::<wbr>interpret</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">rustc_const_eval</a>::<wbr><a href="../index.html">interpret</a></span><h1>Module <span>intern</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/rustc_const_eval/interpret/intern.rs.html#1-349">source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module specifies the type based interner for constants.</p>
<p>After a const evaluation has computed a value, before we destroy the const evaluatorâ€™s session
memory, we need to extract all memory allocations to the global memory pool so they stay around.</p>
<p>In principle, this is not very complicated: we recursively walk the final value, follow all the
pointers, and move all reachable allocations to the global <code>tcx</code> memory. The only complication
is picking the right mutability: the outermost allocation generally has a clear mutability, but
what about the other allocations it points to that have also been created with this value? We
donâ€™t want to do guesswork here. The rules are: <code>static</code>, <code>const</code>, and promoted can only create
immutable allocations that way. <code>static mut</code> can be initialized with expressions like <code>&amp;mut 42</code>,
so all inner allocations are marked mutable. Some of them could potentially be made immutable,
but that would require relying on type information, and given how many ways Rust has to lie
about type information, we want to avoid doing that.</p>
</div></details><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.InternKind.html" title="enum rustc_const_eval::interpret::intern::InternKind">Intern<wbr>Kind</a></div><div class="desc docblock-short">How a constant value should be interned.</div></li><li><div class="item-name"><a class="enum" href="enum.InternResult.html" title="enum rustc_const_eval::interpret::intern::InternResult">Intern<wbr>Result</a></div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.HasStaticRootDefId.html" title="trait rustc_const_eval::interpret::intern::HasStaticRootDefId">HasStatic<wbr>Root<wbr>DefId</a></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.intern_as_new_static.html" title="fn rustc_const_eval::interpret::intern::intern_as_new_static">intern_<wbr>as_<wbr>new_<wbr>static</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Creates a new <code>DefId</code> and feeds all the right queries to make this <code>DefId</code>
appear as if it were a user-written <code>static</code> (though it has no HIR).</div></li><li><div class="item-name"><a class="fn" href="fn.intern_const_alloc_for_constprop.html" title="fn rustc_const_eval::interpret::intern::intern_const_alloc_for_constprop">intern_<wbr>const_<wbr>alloc_<wbr>for_<wbr>constprop</a></div><div class="desc docblock-short">Intern <code>ret</code>. This function assumes that <code>ret</code> references no other allocation.</div></li><li><div class="item-name"><a class="fn" href="fn.intern_const_alloc_recursive.html" title="fn rustc_const_eval::interpret::intern::intern_const_alloc_recursive">intern_<wbr>const_<wbr>alloc_<wbr>recursive</a></div><div class="desc docblock-short">Intern <code>ret</code> and everything it references.</div></li><li><div class="item-name"><a class="fn" href="fn.intern_shallow.html" title="fn rustc_const_eval::interpret::intern::intern_shallow">intern_<wbr>shallow</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Intern an allocation. Returns <code>Err</code> if the allocation does not exist in the local memory.</div></li></ul><h2 id="trait-aliases" class="section-header">Trait Aliases<a href="#trait-aliases" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="traitalias" href="traitalias.CompileTimeMachine.html" title="traitalias rustc_const_eval::interpret::intern::CompileTimeMachine">Compile<wbr>Time<wbr>Machine</a></div></li></ul></section></div></main></body></html>