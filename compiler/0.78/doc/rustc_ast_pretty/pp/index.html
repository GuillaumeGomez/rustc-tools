<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This pretty-printer is a direct reimplementation of Philip Karltonâ€™s Mesa pretty-printer, as described in the appendix to Derek C. Oppen, â€œPretty Printingâ€ (1979), Stanford Computer Science Department STAN-CS-79-770, http://i.stanford.edu/pub/cstr/reports/cs/tr/79/770/CS-TR-79-770.pdf."><title>rustc_ast_pretty::pp - Rust</title><script> if (window.location.protocol !== "file:") document.write(`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2">`)</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="rustc_ast_pretty" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0-dev" data-channel="nightly" data-search-js="search-42d8da7a6b9792c2.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-12cf3b4f4f9dc36d.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../rustc_ast_pretty/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../rustc_ast_pretty/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2><a href="../../rustc_ast_pretty/index.html">rustc_ast_pretty</a><span class="version">1.78.0-dev</span></h2></div><h2 class="location"><a href="#">Module pp</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li></ul></section><h2><a href="../index.html">In crate rustc_ast_pretty</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../rustc_ast_pretty/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">rustc_ast_pretty</a>::<wbr><a class="mod" href="#">pp</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/rustc_ast_pretty/pp.rs.html#1-450">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This pretty-printer is a direct reimplementation of Philip Karltonâ€™s
Mesa pretty-printer, as described in the appendix to
Derek C. Oppen, â€œPretty Printingâ€ (1979),
Stanford Computer Science Department STAN-CS-79-770,
<a href="http://i.stanford.edu/pub/cstr/reports/cs/tr/79/770/CS-TR-79-770.pdf">http://i.stanford.edu/pub/cstr/reports/cs/tr/79/770/CS-TR-79-770.pdf</a>.</p>
<p>The algorithmâ€™s aim is to break a stream into as few lines as possible
while respecting the indentation-consistency requirements of the enclosing
block, and avoiding breaking at silly places on block boundaries, for
example, between â€œxâ€ and â€œ)â€ in â€œx)â€.</p>
<p>I am implementing this algorithm because it comes with 20 pages of
documentation explaining its theory, and because it addresses the set of
concerns Iâ€™ve seen other pretty-printers fall down on. Weirdly. Even though
itâ€™s 32 years old. What can I say?</p>
<p>Despite some redundancies and quirks in the way itâ€™s implemented in that
paper, Iâ€™ve opted to keep the implementation here as similar as I can,
changing only what was blatantly wrong, a typo, or sufficiently
non-idiomatic rust that it really stuck out.</p>
<p>In particular youâ€™ll see a certain amount of churn related to INTEGER vs.
CARDINAL in the Mesa implementation. Mesa apparently interconverts the two
somewhat readily? In any case, Iâ€™ve used usize for indices-in-buffers and
ints for character-sizes-and-indentation-offsets. This respects the need
for ints to â€œgo negativeâ€ while carrying a pending-calculation balance, and
helps differentiate all the numbers flying around internally (slightly).</p>
<p>I also inverted the indentation arithmetic used in the print stack, since
the Mesa implementation (somewhat randomly) stores the offset on the print
stack in terms of margin-col rather than col itself. I store col.</p>
<p>I also implemented a small change in the String token, in that I store an
explicit length for the string. For most tokens this is just the length of
the accompanying string. But itâ€™s necessary to permit it to differ, for
encoding things that are supposed to â€œgo on their own lineâ€ â€“ certain
classes of comment and blank-line â€“ where relying on adjacent
hardbreak-like Break tokens with long blankness indication doesnâ€™t actually
work. To see why, consider when there is a â€œthing that should be on its own
lineâ€ between two long blocks, say functions. If you put a hardbreak after
each function (or before each) and the breaking algorithm decides to break
there anyways (because the functions themselves are long) you wind up with
extra blank lines. If you donâ€™t put hardbreaks you can wind up with the
â€œthing which should be on its own lineâ€ not getting its own line in the
rare case of â€œreally small functionsâ€ or such. This re-occurs with comments
and explicit blank lines. So in those cases we use a string with a payload
we want isolated to a line and an explicit length thatâ€™s huge, surrounded
by two zero-length breaks. The algorithm will try its best to fit it on a
line (which it canâ€™t) and so naturally place the content on its own line to
avoid combining it with other lines and making matters even worse.</p>
<h2 id="explanation"><a class="doc-anchor" href="#explanation">Â§</a>Explanation</h2>
<p>In case you do not have the paper, here is an explanation of whatâ€™s going
on.</p>
<p>There is a stream of input tokens flowing through this printer.</p>
<p>The printer buffers up to 3N tokens inside itself, where N is linewidth.
Yes, linewidth is chars and tokens are multi-char, but in the worst
case every token worth buffering is 1 char long, so itâ€™s ok.</p>
<p>Tokens are String, Break, and Begin/End to delimit blocks.</p>
<p>Begin tokens can carry an offset, saying â€œhow far to indent when you break
inside hereâ€, as well as a flag indicating â€œconsistentâ€ or â€œinconsistentâ€
breaking. Consistent breaking means that after the first break, no attempt
will be made to flow subsequent breaks together onto lines. Inconsistent
is the opposite. Inconsistent breaking example would be, say:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code>foo(hello, there, good, friends)</code></pre></div>
<p>breaking inconsistently to become</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code>foo(hello, there,
    good, friends);</code></pre></div>
<p>whereas a consistent breaking would yield:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code>foo(hello,
    there,
    good,
    friends);</code></pre></div>
<p>That is, in the consistent-break blocks we value vertical alignment
more than the ability to cram stuff onto a line. But in all cases if it
can make a block a one-liner, itâ€™ll do so.</p>
<p>Carrying on with high-level logic:</p>
<p>The buffered tokens go through a ring-buffer, â€˜tokensâ€™. The â€˜leftâ€™ and
â€˜rightâ€™ indices denote the active portion of the ring buffer as well as
describing hypothetical points-in-the-infinite-stream at most 3N tokens
apart (i.e., â€œnot wrapped to ring-buffer boundariesâ€). The paper will switch
between using â€˜leftâ€™ and â€˜rightâ€™ terms to denote the wrapped-to-ring-buffer
and point-in-infinite-stream senses freely.</p>
<p>There is a parallel ring buffer, <code>size</code>, that holds the calculated size of
each token. Why calculated? Because for Begin/End pairs, the â€œsizeâ€
includes everything between the pair. That is, the â€œsizeâ€ of Begin is
actually the sum of the sizes of everything between Begin and the paired
End that follows. Since that is arbitrarily far in the future, <code>size</code> is
being rewritten regularly while the printer runs; in fact most of the
machinery is here to work out <code>size</code> entries on the fly (and give up when
theyâ€™re so obviously over-long that â€œinfinityâ€ is a good enough
approximation for purposes of line breaking).</p>
<p>The â€œinput sideâ€ of the printer is managed as an abstract process called
SCAN, which uses <code>scan_stack</code>, to manage calculating <code>size</code>. SCAN is, in
other words, the process of calculating â€˜sizeâ€™ entries.</p>
<p>The â€œoutput sideâ€ of the printer is managed by an abstract process called
PRINT, which uses <code>print_stack</code>, <code>margin</code> and <code>space</code> to figure out what to
do with each token/size pair it consumes as it goes. Itâ€™s trying to consume
the entire buffered window, but canâ€™t output anything until the size is &gt;=
0 (sizes are set to negative while theyâ€™re pending calculation).</p>
<p>So SCAN takes input and buffers tokens and pending calculations, while
PRINT gobbles up completed calculations and tokens from the buffer. The
theory is that the two can never get more than 3N tokens apart, because
once thereâ€™s â€œobviouslyâ€ too much data to fit on a line, in a size
calculation, SCAN will write â€œinfinityâ€ to the size and let PRINT consume
it.</p>
<p>In this implementation (following the paper, again) the SCAN process is the
methods called <code>Printer::scan_*</code>, and the â€˜PRINTâ€™ process is the
method called <code>Printer::print</code>.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="convenience/index.html" title="mod rustc_ast_pretty::pp::convenience">convenience</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="ring/index.html" title="mod rustc_ast_pretty::pp::ring">ring</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BeginToken.html" title="struct rustc_ast_pretty::pp::BeginToken">BeginToken</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.BreakToken.html" title="struct rustc_ast_pretty::pp::BreakToken">BreakToken</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.BufEntry.html" title="struct rustc_ast_pretty::pp::BufEntry">BufEntry</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.Printer.html" title="struct rustc_ast_pretty::pp::Printer">Printer</a></div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Breaks.html" title="enum rustc_ast_pretty::pp::Breaks">Breaks</a></div><div class="desc docblock-short">How to break. Described in more detail in the module docs.</div></li><li><div class="item-name"><a class="enum" href="enum.IndentStyle.html" title="enum rustc_ast_pretty::pp::IndentStyle">IndentStyle</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="enum" href="enum.PrintFrame.html" title="enum rustc_ast_pretty::pp::PrintFrame">PrintFrame</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="enum" href="enum.Token.html" title="enum rustc_ast_pretty::pp::Token">Token</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.MARGIN.html" title="constant rustc_ast_pretty::pp::MARGIN">MARGIN</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Target line width.</div></li><li><div class="item-name"><a class="constant" href="constant.MIN_SPACE.html" title="constant rustc_ast_pretty::pp::MIN_SPACE">MIN_SPACE</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Every line is allowed at least this much space, even if highly indented.</div></li><li><div class="item-name"><a class="constant" href="constant.SIZE_INFINITY.html" title="constant rustc_ast_pretty::pp::SIZE_INFINITY">SIZE_INFINITY</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li></ul></section></div></main></body></html>