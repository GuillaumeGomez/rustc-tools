<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Match exhaustiveness and redundancy algorithm"><title>rustc_pattern_analysis::usefulness - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5ca6ca2a1f83705a.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="rustc_pattern_analysis" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-dev" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../rustc_pattern_analysis/index.html">rustc_pattern_analysis</a><span class="version">1.82.0-dev</span></h2></div><h2 class="location"><a href="#">Module usefulness</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate rustc_pattern_analysis</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">rustc_pattern_analysis</a>::<wbr><a class="mod" href="#">usefulness</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/rustc_pattern_analysis/usefulness.rs.html#1-1785">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="match-exhaustiveness-and-redundancy-algorithm"><a class="doc-anchor" href="#match-exhaustiveness-and-redundancy-algorithm">§</a>Match exhaustiveness and redundancy algorithm</h2>
<p>This file contains the logic for exhaustiveness and usefulness checking for pattern-matching.
Specifically, given a list of patterns in a match, we can tell whether:
(a) a given pattern is redundant
(b) the patterns cover every possible value for the type (exhaustiveness)</p>
<p>The algorithm implemented here is inspired from the one described in <a href="http://moscova.inria.fr/~maranget/papers/warn/index.html">this
paper</a>. We have however changed it in
various ways to accommodate the variety of patterns that Rust supports. We thus explain our
version here, without being as precise.</p>
<p>Fun fact: computing exhaustiveness is NP-complete, because we can encode a SAT problem as an
exhaustiveness problem. See <a href="https://niedzejkob.p4.team/rust-np">here</a> for the fun details.</p>
<h2 id="summary"><a class="doc-anchor" href="#summary">§</a>Summary</h2>
<p>The algorithm is given as input a list of patterns, one for each arm of a match, and computes
the following:</p>
<ul>
<li>a set of values that match none of the patterns (if any),</li>
<li>for each subpattern (taking into account or-patterns), whether removing it would change
anything about how the match executes, i.e. whether it is useful/not redundant.</li>
</ul>
<p>To a first approximation, the algorithm works by exploring all possible values for the type
being matched on, and determining which arm(s) catch which value. To make this tractable we
cleverly group together values, as we’ll see below.</p>
<p>The entrypoint of this file is the <a href="fn.compute_match_usefulness.html" title="fn rustc_pattern_analysis::usefulness::compute_match_usefulness"><code>compute_match_usefulness</code></a> function, which computes
usefulness for each subpattern and exhaustiveness for the whole match.</p>
<p>In this page we explain the necessary concepts to understand how the algorithm works.</p>
<h2 id="usefulness"><a class="doc-anchor" href="#usefulness">§</a>Usefulness</h2>
<p>The central concept of this file is the notion of “usefulness”. Given some patterns <code>p_1 .. p_n</code>, a pattern <code>q</code> is said to be <em>useful</em> if there is a value that is matched by <code>q</code> and by
none of the <code>p_i</code>. We write <code>usefulness(p_1 .. p_n, q)</code> for a function that returns a list of
such values. The aim of this file is to compute it efficiently.</p>
<p>This is enough to compute usefulness: a pattern in a <code>match</code> expression is redundant iff it is
not useful w.r.t. the patterns above it:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">match </span><span class="prelude-val">Some</span>(<span class="number">0u32</span>) {
    <span class="prelude-val">Some</span>(<span class="number">0</span>..<span class="number">100</span>) =&gt; {},
    <span class="prelude-val">Some</span>(<span class="number">90</span>..<span class="number">190</span>) =&gt; {}, <span class="comment">// useful: `Some(150)` is matched by this but not the branch above
    </span><span class="prelude-val">Some</span>(<span class="number">50</span>..<span class="number">150</span>) =&gt; {}, <span class="comment">// redundant: all the values this matches are already matched by
                         //   the branches above
    </span><span class="prelude-val">None </span>=&gt; {},          <span class="comment">// useful: `None` is matched by this but not the branches above
</span>}</code></pre></div>
<p>This is also enough to compute exhaustiveness: a match is exhaustive iff the wildcard <code>_</code>
pattern is <em>not</em> useful w.r.t. the patterns in the match. The values returned by <code>usefulness</code>
are used to tell the user which values are missing.</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">match </span>x {
    <span class="prelude-val">None </span>=&gt; {},
    <span class="prelude-val">Some</span>(<span class="number">0</span>) =&gt; {},
    <span class="comment">// not exhaustive: `_` is useful because it matches `Some(1)`
</span>}</code></pre></div>
<h2 id="constructors-and-fields"><a class="doc-anchor" href="#constructors-and-fields">§</a>Constructors and fields</h2>
<p>In the value <code>Pair(Some(0), true)</code>, <code>Pair</code> is called the constructor of the value, and <code>Some(0)</code>
and <code>true</code> are its fields. Every matcheable value can be decomposed in this way. Examples of
constructors are: <code>Some</code>, <code>None</code>, <code>(,)</code> (the 2-tuple constructor), <code>Foo {..}</code> (the constructor
for a struct <code>Foo</code>), and <code>2</code> (the constructor for the number <code>2</code>).</p>
<p>Each constructor takes a fixed number of fields; this is called its arity. <code>Pair</code> and <code>(,)</code> have
arity 2, <code>Some</code> has arity 1, <code>None</code> and <code>42</code> have arity 0. Each type has a known set of
constructors. Some types have many constructors (like <code>u64</code>) or even an infinitely many (like
<code>&amp;str</code> and <code>&amp;[T]</code>).</p>
<p>Patterns are similar: <code>Pair(Some(_), _)</code> has constructor <code>Pair</code> and two fields. The difference
is that we get some extra pattern-only constructors, namely: the wildcard <code>_</code>, variable
bindings, integer ranges like <code>0..=10</code>, and variable-length slices like <code>[_, .., _]</code>. We treat
or-patterns separately, see the dedicated section below.</p>
<p>Now to check if a value <code>v</code> matches a pattern <code>p</code>, we check if <code>v</code>’s constructor matches <code>p</code>’s
constructor, then recursively compare their fields if necessary. A few representative examples:</p>
<ul>
<li><code>matches!(v, _) := true</code></li>
<li><code>matches!((v0,  v1), (p0,  p1)) := matches!(v0, p0) &amp;&amp; matches!(v1, p1)</code></li>
<li><code>matches!(Foo { bar: v0, baz: v1 }, Foo { bar: p0, baz: p1 }) := matches!(v0, p0) &amp;&amp; matches!(v1, p1)</code></li>
<li><code>matches!(Ok(v0), Ok(p0)) := matches!(v0, p0)</code></li>
<li><code>matches!(Ok(v0), Err(p0)) := false</code> (incompatible variants)</li>
<li><code>matches!(v, 1..=100) := matches!(v, 1) || ... || matches!(v, 100)</code></li>
<li><code>matches!([v0], [p0, .., p1]) := false</code> (incompatible lengths)</li>
<li><code>matches!([v0, v1, v2], [p0, .., p1]) := matches!(v0, p0) &amp;&amp; matches!(v2, p1)</code></li>
</ul>
<p>Constructors and relevant operations are defined in the <a href="../constructor/index.html" title="mod rustc_pattern_analysis::constructor"><code>crate::constructor</code></a> module. A
representation of patterns that uses constructors is available in <a href="../pat/index.html" title="mod rustc_pattern_analysis::pat"><code>crate::pat</code></a>. The question
of whether a constructor is matched by another one is answered by
<a href="../constructor/enum.Constructor.html#method.is_covered_by" title="method rustc_pattern_analysis::constructor::Constructor::is_covered_by"><code>Constructor::is_covered_by</code></a>.</p>
<p>Note 1: variable bindings (like the <code>x</code> in <code>Some(x)</code>) match anything, so we treat them as wildcards.
Note 2: this only applies to matcheable values. For example a value of type <code>Rc&lt;u64&gt;</code> can’t be
deconstructed that way.</p>
<h2 id="specialization"><a class="doc-anchor" href="#specialization">§</a>Specialization</h2>
<p>The examples in the previous section motivate the operation at the heart of the algorithm:
“specialization”. It captures this idea of “removing one layer of constructor”.</p>
<p><code>specialize(c, p)</code> takes a value-only constructor <code>c</code> and a pattern <code>p</code>, and returns a
pattern-tuple or nothing. It works as follows:</p>
<ul>
<li>
<p>Specializing for the wrong constructor returns nothing</p>
<ul>
<li><code>specialize(None, Some(p0)) := &lt;nothing&gt;</code></li>
<li><code>specialize([,,,], [p0]) := &lt;nothing&gt;</code></li>
</ul>
</li>
<li>
<p>Specializing for the correct constructor returns a tuple of the fields</p>
<ul>
<li><code>specialize(Variant1, Variant1(p0, p1, p2)) := (p0, p1, p2)</code></li>
<li><code>specialize(Foo{ bar, baz, quz }, Foo { bar: p0, baz: p1, .. }) := (p0, p1, _)</code></li>
<li><code>specialize([,,,], [p0, .., p1]) := (p0, _, _, p1)</code></li>
</ul>
</li>
</ul>
<p>We get the following property: for any values <code>v_1, .., v_n</code> of appropriate types, we have:</p>
<div class="example-wrap"><pre class="language-text"><code>matches!(c(v_1, .., v_n), p)
&lt;=&gt; specialize(c, p) returns something
    &amp;&amp; matches!((v_1, .., v_n), specialize(c, p))
</code></pre></div>
<p>We also extend specialization to pattern-tuples by applying it to the first pattern:
<code>specialize(c, (p_0, .., p_n)) := specialize(c, p_0) ++ (p_1, .., p_m)</code>
where <code>++</code> is concatenation of tuples.</p>
<p>The previous property extends to pattern-tuples:</p>
<div class="example-wrap"><pre class="language-text"><code>matches!((c(v_1, .., v_n), w_1, .., w_m), (p_0, p_1, .., p_m))
&lt;=&gt; specialize(c, p_0) does not error
    &amp;&amp; matches!((v_1, .., v_n, w_1, .., w_m), specialize(c, (p_0, p_1, .., p_m)))
</code></pre></div>
<p>Whether specialization returns something or not is given by <a href="../constructor/enum.Constructor.html#method.is_covered_by" title="method rustc_pattern_analysis::constructor::Constructor::is_covered_by"><code>Constructor::is_covered_by</code></a>.
Specialization of a pattern is computed in <a href="../pat/struct.DeconstructedPat.html#method.specialize" title="method rustc_pattern_analysis::pat::DeconstructedPat::specialize"><code>DeconstructedPat::specialize</code></a>. Specialization for
a pattern-tuple is computed in <a href="struct.PatStack.html#method.pop_head_constructor" title="method rustc_pattern_analysis::usefulness::PatStack::pop_head_constructor"><code>PatStack::pop_head_constructor</code></a>. Finally, specialization for a
set of pattern-tuples is computed in <a href="struct.Matrix.html#method.specialize_constructor" title="method rustc_pattern_analysis::usefulness::Matrix::specialize_constructor"><code>Matrix::specialize_constructor</code></a>.</p>
<h2 id="undoing-specialization"><a class="doc-anchor" href="#undoing-specialization">§</a>Undoing specialization</h2>
<p>To construct witnesses we will need an inverse of specialization. If <code>c</code> is a constructor of
arity <code>n</code>, we define <code>unspecialize</code> as:
<code>unspecialize(c, (p_1, .., p_n, q_1, .., q_m)) := (c(p_1, .., p_n), q_1, .., q_m)</code>.</p>
<p>This is done for a single witness-tuple in <a href="struct.WitnessStack.html#method.apply_constructor" title="method rustc_pattern_analysis::usefulness::WitnessStack::apply_constructor"><code>WitnessStack::apply_constructor</code></a>, and for a set of
witness-tuples in <a href="struct.WitnessMatrix.html#method.apply_constructor" title="method rustc_pattern_analysis::usefulness::WitnessMatrix::apply_constructor"><code>WitnessMatrix::apply_constructor</code></a>.</p>
<h2 id="computing-usefulness"><a class="doc-anchor" href="#computing-usefulness">§</a>Computing usefulness</h2>
<p>We now present a naive version of the algorithm for computing usefulness. From now on we operate
on pattern-tuples.</p>
<p>Let <code>pt_1, .., pt_n</code> and <code>qt</code> be length-m tuples of patterns for the same type <code>(T_1, .., T_m)</code>.
We compute <code>usefulness(tp_1, .., tp_n, tq)</code> as follows:</p>
<ul>
<li>
<p>Base case: <code>m == 0</code>.
The pattern-tuples are all empty, i.e. they’re all <code>()</code>. Thus <code>tq</code> is useful iff there are
no rows above it, i.e. if <code>n == 0</code>. In that case we return <code>()</code> as a witness-tuple of
usefulness of <code>tq</code>.</p>
</li>
<li>
<p>Inductive case: <code>m &gt; 0</code>.
In this naive version, we list all the possible constructors for values of type <code>T1</code> (we
will be more clever in the next section).</p>
<ul>
<li>
<p>For each such constructor <code>c</code> for which <code>specialize(c, tq)</code> is not nothing:</p>
<ul>
<li>We recursively compute <code>usefulness(specialize(c, tp_1) ... specialize(c, tp_n), specialize(c, tq))</code>,
where we discard any <code>specialize(c, p_i)</code> that returns nothing.</li>
<li>For each witness-tuple <code>w</code> found, we apply <code>unspecialize(c, w)</code> to it.</li>
</ul>
</li>
<li>
<p>We return the all the witnesses found, if any.</p>
</li>
</ul>
</li>
</ul>
<p>Let’s take the following example:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">match </span>x {
    Variant1(<span class="kw">_</span>) =&gt; {} <span class="comment">// `p1`
    </span>Variant2(<span class="prelude-val">None</span>, <span class="number">0</span>) =&gt; {} <span class="comment">// `p2`
    </span>Variant2(<span class="prelude-val">Some</span>(<span class="kw">_</span>), <span class="number">0</span>) =&gt; {} <span class="comment">// `q`
</span>}</code></pre></div>
<p>To compute the usefulness of <code>q</code>, we would proceed as follows:</p>
<div class="example-wrap"><pre class="language-text"><code>Start:
  `tp1 = [Variant1(_)]`
  `tp2 = [Variant2(None, 0)]`
  `tq  = [Variant2(Some(true), 0)]`

  Constructors are `Variant1` and `Variant2`. Only `Variant2` can specialize `tq`.
  Specialize with `Variant2`:
    `tp2 = [None, 0]`
    `tq  = [Some(true), 0]`

    Constructors are `None` and `Some`. Only `Some` can specialize `tq`.
    Specialize with `Some`:
      `tq  = [true, 0]`

      Constructors are `false` and `true`. Only `true` can specialize `tq`.
      Specialize with `true`:
        `tq  = [0]`

        Constructors are `0`, `1`, .. up to infinity. Only `0` can specialize `tq`.
        Specialize with `0`:
          `tq  = []`

          m == 0 and n == 0, so `tq` is useful with witness `[]`.
            `witness  = []`

        Unspecialize with `0`:
          `witness  = [0]`
      Unspecialize with `true`:
        `witness  = [true, 0]`
    Unspecialize with `Some`:
      `witness  = [Some(true), 0]`
  Unspecialize with `Variant2`:
    `witness  = [Variant2(Some(true), 0)]`
</code></pre></div>
<p>Therefore <code>usefulness(tp_1, tp_2, tq)</code> returns the single witness-tuple <code>[Variant2(Some(true), 0)]</code>.</p>
<p>Computing the set of constructors for a type is done in <a href="../trait.PatCx.html#tymethod.ctors_for_ty" title="method rustc_pattern_analysis::PatCx::ctors_for_ty"><code>PatCx::ctors_for_ty</code></a>. See
the following sections for more accurate versions of the algorithm and corresponding links.</p>
<h2 id="computing-usefulness-and-exhaustiveness-in-one-go"><a class="doc-anchor" href="#computing-usefulness-and-exhaustiveness-in-one-go">§</a>Computing usefulness and exhaustiveness in one go</h2>
<p>The algorithm we have described so far computes usefulness of each pattern in turn, and ends by
checking if <code>_</code> is useful to determine exhaustiveness of the whole match. In practice, instead
of doing “for each pattern { for each constructor { … } }”, we do “for each constructor { for
each pattern { … } }”. This allows us to compute everything in one go.</p>
<p><a href="struct.Matrix.html" title="struct rustc_pattern_analysis::usefulness::Matrix"><code>Matrix</code></a> stores the set of pattern-tuples under consideration. We track usefulness of each
row mutably in the matrix as we go along. We ignore witnesses of usefulness of the match rows.
We gather witnesses of the usefulness of <code>_</code> in <a href="struct.WitnessMatrix.html" title="struct rustc_pattern_analysis::usefulness::WitnessMatrix"><code>WitnessMatrix</code></a>. The algorithm that computes
all this is in <a href="fn.compute_exhaustiveness_and_usefulness.html" title="fn rustc_pattern_analysis::usefulness::compute_exhaustiveness_and_usefulness"><code>compute_exhaustiveness_and_usefulness</code></a>.</p>
<p>See the full example at the bottom of this documentation.</p>
<h2 id="making-usefulness-tractable-constructor-splitting"><a class="doc-anchor" href="#making-usefulness-tractable-constructor-splitting">§</a>Making usefulness tractable: constructor splitting</h2>
<p>We’re missing one last detail: which constructors do we list? Naively listing all value
constructors cannot work for types like <code>u64</code> or <code>&amp;str</code>, so we need to be more clever. The final
clever idea for this algorithm is that we can group together constructors that behave the same.</p>
<p>Examples:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">match </span>(<span class="number">0</span>, <span class="bool-val">false</span>) {
    (<span class="number">0 </span>..=<span class="number">100</span>, <span class="bool-val">true</span>) =&gt; {}
    (<span class="number">50</span>..=<span class="number">150</span>, <span class="bool-val">false</span>) =&gt; {}
    (<span class="number">0 </span>..=<span class="number">200</span>, <span class="kw">_</span>) =&gt; {}
}</code></pre></div>
<p>In this example, trying any of <code>0</code>, <code>1</code>, .., <code>49</code> will give the same specialized matrix, and
thus the same usefulness/exhaustiveness results. We can thus accelerate the algorithm by
trying them all at once. Here in fact, the only cases we need to consider are: <code>0..50</code>,
<code>50..=100</code>, <code>101..=150</code>,<code>151..=200</code> and <code>201..</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span>Direction { North, South, East, West }
<span class="kw">match </span>wind {
    (Direction::North, <span class="number">50</span>..) =&gt; {}
    (<span class="kw">_</span>, <span class="kw">_</span>) =&gt; {}
}</code></pre></div>
<p>In this example, trying any of <code>South</code>, <code>East</code>, <code>West</code> will give the same specialized matrix. By
the same reasoning, we only need to try two cases: <code>North</code>, and “everything else”.</p>
<p>We call <em>constructor splitting</em> the operation that computes such a minimal set of cases to try.
This is done in <a href="../constructor/enum.ConstructorSet.html#method.split" title="method rustc_pattern_analysis::constructor::ConstructorSet::split"><code>ConstructorSet::split</code></a> and explained in <a href="../constructor/index.html" title="mod rustc_pattern_analysis::constructor"><code>crate::constructor</code></a>.</p>
<h2 id="missing-and-relevancy"><a class="doc-anchor" href="#missing-and-relevancy">§</a><code>Missing</code> and relevancy</h2><h3 id="relevant-values"><a class="doc-anchor" href="#relevant-values">§</a>Relevant values</h3>
<p>Take the following example:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">match </span>foo {
    (<span class="bool-val">true</span>, <span class="kw">_</span>) =&gt; <span class="number">1</span>,
    (<span class="kw">_</span>, <span class="bool-val">true</span>) =&gt; <span class="number">2</span>,
};</code></pre></div>
<p>Consider the value <code>(true, true)</code>:</p>
<ul>
<li>Row 2 does not distinguish <code>(true, true)</code> and <code>(false, true)</code>;</li>
<li><code>false</code> does not show up in the first column of the match, so without knowing anything else we
can deduce that <code>(false, true)</code> matches the same or fewer rows than <code>(true, true)</code>.</li>
</ul>
<p>Using those two facts together, we deduce that <code>(true, true)</code> will not give us more usefulness
information about row 2 than <code>(false, true)</code> would. We say that “<code>(true, true)</code> is made
irrelevant for row 2 by <code>(false, true)</code>”. We will use this idea to prune the search tree.</p>
<h3 id="computing-relevancy"><a class="doc-anchor" href="#computing-relevancy">§</a>Computing relevancy</h3>
<p>We now generalize from the above example to approximate relevancy in a simple way. Note that we
will only compute an approximation: we can sometimes determine when a case is irrelevant, but
computing this precisely is at least as hard as computing usefulness.</p>
<p>Our computation of relevancy relies on the <code>Missing</code> constructor. As explained in
<a href="../constructor/index.html" title="mod rustc_pattern_analysis::constructor"><code>crate::constructor</code></a>, <code>Missing</code> represents the constructors not present in a given column. For
example in the following:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">enum </span>Direction { North, South, East, West }
<span class="kw">match </span>wind {
    (Direction::North, <span class="kw">_</span>) =&gt; <span class="number">1</span>,
    (<span class="kw">_</span>, <span class="number">50</span>..) =&gt; <span class="number">2</span>,
};</code></pre></div>
<p>Here <code>South</code>, <code>East</code> and <code>West</code> are missing in the first column, and <code>0..50</code>  is missing in the
second. Both of these sets are represented by <code>Constructor::Missing</code> in their corresponding
column.</p>
<p>We then compute relevancy as follows: during the course of the algorithm, for a row <code>r</code>:</p>
<ul>
<li>if <code>r</code> has a wildcard in the first column;</li>
<li>and some constructors are missing in that column;</li>
<li>then any <code>c != Missing</code> is considered irrelevant for row <code>r</code>.</li>
</ul>
<p>By this we mean that continuing the algorithm by specializing with <code>c</code> is guaranteed not to
contribute more information about the usefulness of row <code>r</code> than what we would get by
specializing with <code>Missing</code>. The argument is the same as in the previous subsection.</p>
<p>Once we’ve specialized by a constructor <code>c</code> that is irrelevant for row <code>r</code>, we’re guaranteed to
only explore values irrelevant for <code>r</code>. If we then ever reach a point where we’re only exploring
values that are irrelevant to all of the rows (including the virtual wildcard row used for
exhaustiveness), we skip that case entirely.</p>
<h3 id="example"><a class="doc-anchor" href="#example">§</a>Example</h3>
<p>Let’s go through a variation on the first example:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">match </span>foo {
    (<span class="bool-val">true</span>, <span class="kw">_</span>, <span class="bool-val">true</span>) =&gt; <span class="number">1</span>,
    (<span class="kw">_</span>, <span class="bool-val">true</span>, <span class="kw">_</span>) =&gt; <span class="number">2</span>,
};</code></pre></div>
<div class="example-wrap"><pre class="language-text"><code> ┐ Patterns:
 │   1. `[(true, _, true)]`
 │   2. `[(_, true, _)]`
 │   3. `[_]` // virtual extra wildcard row
 │
 │ Specialize with `(,,)`:
 ├─┐ Patterns:
 │ │   1. `[true, _, true]`
 │ │   2. `[_, true, _]`
 │ │   3. `[_, _, _]`
 │ │
 │ │ There are missing constructors in the first column (namely `false`), hence
 │ │ `true` is irrelevant for rows 2 and 3.
 │ │
 │ │ Specialize with `true`:
 │ ├─┐ Patterns:
 │ │ │   1. `[_, true]`
 │ │ │   2. `[true, _]` // now exploring irrelevant cases
 │ │ │   3. `[_, _]`    // now exploring irrelevant cases
 │ │ │
 │ │ │ There are missing constructors in the first column (namely `false`), hence
 │ │ │ `true` is irrelevant for rows 1 and 3.
 │ │ │
 │ │ │ Specialize with `true`:
 │ │ ├─┐ Patterns:
 │ │ │ │   1. `[true]` // now exploring irrelevant cases
 │ │ │ │   2. `[_]`    // now exploring irrelevant cases
 │ │ │ │   3. `[_]`    // now exploring irrelevant cases
 │ │ │ │
 │ │ │ │ The current case is irrelevant for all rows: we backtrack immediately.
 │ │ ├─┘
 │ │ │
 │ │ │ Specialize with `false`:
 │ │ ├─┐ Patterns:
 │ │ │ │   1. `[true]`
 │ │ │ │   3. `[_]`    // now exploring irrelevant cases
 │ │ │ │
 │ │ │ │ Specialize with `true`:
 │ │ │ ├─┐ Patterns:
 │ │ │ │ │   1. `[]`
 │ │ │ │ │   3. `[]`    // now exploring irrelevant cases
 │ │ │ │ │
 │ │ │ │ │ Row 1 is therefore useful.
 │ │ │ ├─┘
&lt;etc...&gt;
</code></pre></div>
<p>Relevancy allowed us to skip the case <code>(true, true, _)</code> entirely. In some cases this pruning can
give drastic speedups. The case this was built for is the following (#118437):</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">match </span>foo {
    (<span class="bool-val">true</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, ..) =&gt; <span class="number">1</span>,
    (<span class="kw">_</span>, <span class="bool-val">true</span>, <span class="kw">_</span>, <span class="kw">_</span>, ..) =&gt; <span class="number">2</span>,
    (<span class="kw">_</span>, <span class="kw">_</span>, <span class="bool-val">true</span>, <span class="kw">_</span>, ..) =&gt; <span class="number">3</span>,
    (<span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="bool-val">true</span>, ..) =&gt; <span class="number">4</span>,
    ...
}</code></pre></div>
<p>Without considering relevancy, we would explore all 2^n combinations of the <code>true</code> and <code>Missing</code>
constructors. Relevancy tells us that e.g. <code>(true, true, false, false, false, ...)</code> is
irrelevant for all the rows. This allows us to skip all cases with more than one <code>true</code>
constructor, changing the runtime from exponential to linear.</p>
<h3 id="relevancy-and-exhaustiveness"><a class="doc-anchor" href="#relevancy-and-exhaustiveness">§</a>Relevancy and exhaustiveness</h3>
<p>For exhaustiveness, we do something slightly different w.r.t relevancy: we do not report
witnesses of non-exhaustiveness that are irrelevant for the virtual wildcard row. For example,
in:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">match </span>foo {
    (<span class="bool-val">true</span>, <span class="bool-val">true</span>) =&gt; {}
}</code></pre></div>
<p>we only report <code>(false, _)</code> as missing. This was a deliberate choice made early in the
development of rust, for diagnostic and performance purposes. As showed in the previous section,
ignoring irrelevant cases preserves usefulness, so this choice still correctly computes whether
a match is exhaustive.</p>
<h2 id="or-patterns"><a class="doc-anchor" href="#or-patterns">§</a>Or-patterns</h2>
<p>What we have described so far works well if there are no or-patterns. To handle them, if the
first pattern of any row in the matrix is an or-pattern, we expand it by duplicating the rest of
the row as necessary. For code reuse, this is implemented as “specializing with the <code>Or</code>
constructor”.</p>
<p>This makes usefulness tracking subtle, because we also want to compute whether an alternative of
an or-pattern is redundant, e.g. in <code>Some(_) | Some(0)</code>. We therefore track usefulness of each
subpattern of the match.</p>
<h2 id="constants-and-opaques"><a class="doc-anchor" href="#constants-and-opaques">§</a>Constants and opaques</h2>
<p>There are two kinds of constants in patterns:</p>
<ul>
<li>literals (<code>1</code>, <code>true</code>, <code>"foo"</code>)</li>
<li>named or inline consts (<code>FOO</code>, <code>const { 5 + 6 }</code>)</li>
</ul>
<p>The latter are converted into the corresponding patterns by a previous phase. For example
<code>const_to_pat(const { [1, 2, 3] })</code> becomes an <code>Array(vec![Const(1), Const(2), Const(3)])</code>
pattern. This gets problematic when comparing the constant via <code>==</code> would behave differently
from matching on the constant converted to a pattern. The situation around this is currently
unclear and the lang team is working on clarifying what we want to do there. In any case, there
are constants we will not turn into patterns. We capture these with <code>Constructor::Opaque</code>. These
<code>Opaque</code> patterns do not participate in exhaustiveness, specialization or overlap checking.</p>
<h2 id="usefulness-vs-reachability-validity-and-empty-patterns"><a class="doc-anchor" href="#usefulness-vs-reachability-validity-and-empty-patterns">§</a>Usefulness vs reachability, validity, and empty patterns</h2>
<p>This is likely the subtlest aspect of the algorithm. To be fully precise, a match doesn’t
operate on a value, it operates on a place. In certain unsafe circumstances, it is possible for
a place to not contain valid data for its type. This has subtle consequences for empty types.
Take the following:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span>Void {}
<span class="kw">let </span>x: u8 = <span class="number">0</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*const </span>Void = <span class="kw-2">&amp;</span>x <span class="kw">as </span><span class="kw-2">*const </span>u8 <span class="kw">as </span><span class="kw-2">*const </span>Void;
<span class="kw">unsafe </span>{
    <span class="kw">match </span><span class="kw-2">*</span>ptr {
        <span class="kw">_ </span>=&gt; <span class="macro">println!</span>(<span class="string">"Reachable!"</span>),
    }
}</code></pre></div>
<p>In this example, <code>ptr</code> is a valid pointer pointing to a place with invalid data. The <code>_</code> pattern
does not look at the contents of <code>*ptr</code>, so this is ok and the arm is taken. In other words,
despite the place we are inspecting being of type <code>Void</code>, there is a reachable arm. If the
arm had a binding however:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">match </span><span class="kw-2">*</span>ptr {
    _a =&gt; <span class="macro">println!</span>(<span class="string">"Unreachable!"</span>),
}</code></pre></div>
<p>Here the binding loads the value of type <code>Void</code> from the <code>*ptr</code> place. In this example, this
causes UB since the data is not valid. In the general case, this asserts validity of the data at
<code>*ptr</code>. Either way, this arm will never be taken.</p>
<p>Finally, let’s consider the empty match <code>match *ptr {}</code>. If we consider this exhaustive, then
having invalid data at <code>*ptr</code> is invalid. In other words, the empty match is semantically
equivalent to the <code>_a =&gt; ...</code> match. In the interest of explicitness, we prefer the case with an
arm, hence we won’t tell the user to remove the <code>_a</code> arm. In other words, the <code>_a</code> arm is
unreachable yet not redundant. This is why we lint on redundant arms rather than unreachable
arms, despite the fact that the lint says “unreachable”.</p>
<p>These considerations only affects certain places, namely those that can contain non-valid data
without UB. These are: pointer dereferences, reference dereferences, and union field accesses.
We track in the algorithm whether a given place is known to contain valid data. This is done
first by inspecting the scrutinee syntactically (which gives us <code>cx.known_valid_scrutinee</code>), and
then by tracking validity of each column of the matrix (which correspond to places) as we
recurse into subpatterns. That second part is done through <a href="enum.PlaceValidity.html" title="enum rustc_pattern_analysis::usefulness::PlaceValidity"><code>PlaceValidity</code></a>, most notably
<a href="enum.PlaceValidity.html#method.specialize" title="method rustc_pattern_analysis::usefulness::PlaceValidity::specialize"><code>PlaceValidity::specialize</code></a>.</p>
<p>Having said all that, in practice we don’t fully follow what’s been presented in this section.
Let’s call “toplevel exception” the case where the match scrutinee itself has type <code>!</code> or
<code>EmptyEnum</code>. First, on stable rust, we require <code>_</code> patterns for empty types in all cases apart
from the toplevel exception. The <code>exhaustive_patterns</code> and <code>min_exaustive_patterns</code> allow
omitting patterns in the cases described above. There’s a final detail: in the toplevel
exception or with the <code>exhaustive_patterns</code> feature, we ignore place validity when checking
whether a pattern is required for exhaustiveness. I (Nadrieril) hope to deprecate this behavior.</p>
<h2 id="full-example"><a class="doc-anchor" href="#full-example">§</a>Full example</h2>
<p>We illustrate a full run of the algorithm on the following match.</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">match </span>x {
    Pair(<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="kw">_</span>) =&gt; <span class="number">1</span>,
    Pair(<span class="kw">_</span>, <span class="bool-val">false</span>) =&gt; <span class="number">2</span>,
    Pair(<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="bool-val">false</span>) =&gt; <span class="number">3</span>,
}</code></pre></div>
<p>We keep track of the original row for illustration purposes, this is not what the algorithm
actually does (it tracks usefulness as a boolean on each row).</p>
<div class="example-wrap"><pre class="language-text"><code> ┐ Patterns:
 │   1. `[Pair(Some(0), _)]`
 │   2. `[Pair(_, false)]`
 │   3. `[Pair(Some(0), false)]`
 │
 │ Specialize with `Pair`:
 ├─┐ Patterns:
 │ │   1. `[Some(0), _]`
 │ │   2. `[_, false]`
 │ │   3. `[Some(0), false]`
 │ │
 │ │ Specialize with `Some`:
 │ ├─┐ Patterns:
 │ │ │   1. `[0, _]`
 │ │ │   2. `[_, false]`
 │ │ │   3. `[0, false]`
 │ │ │
 │ │ │ Specialize with `0`:
 │ │ ├─┐ Patterns:
 │ │ │ │   1. `[_]`
 │ │ │ │   3. `[false]`
 │ │ │ │
 │ │ │ │ Specialize with `true`:
 │ │ │ ├─┐ Patterns:
 │ │ │ │ │   1. `[]`
 │ │ │ │ │
 │ │ │ │ │ We note arm 1 is useful (by `Pair(Some(0), true)`).
 │ │ │ ├─┘
 │ │ │ │
 │ │ │ │ Specialize with `false`:
 │ │ │ ├─┐ Patterns:
 │ │ │ │ │   1. `[]`
 │ │ │ │ │   3. `[]`
 │ │ │ │ │
 │ │ │ │ │ We note arm 1 is useful (by `Pair(Some(0), false)`).
 │ │ │ ├─┘
 │ │ ├─┘
 │ │ │
 │ │ │ Specialize with `1..`:
 │ │ ├─┐ Patterns:
 │ │ │ │   2. `[false]`
 │ │ │ │
 │ │ │ │ Specialize with `true`:
 │ │ │ ├─┐ Patterns:
 │ │ │ │ │   // no rows left
 │ │ │ │ │
 │ │ │ │ │ We have found an unmatched value (`Pair(Some(1..), true)`)! This gives us a witness.
 │ │ │ │ │ New witnesses:
 │ │ │ │ │   `[]`
 │ │ │ ├─┘
 │ │ │ │ Unspecialize new witnesses with `true`:
 │ │ │ │   `[true]`
 │ │ │ │
 │ │ │ │ Specialize with `false`:
 │ │ │ ├─┐ Patterns:
 │ │ │ │ │   2. `[]`
 │ │ │ │ │
 │ │ │ │ │ We note arm 2 is useful (by `Pair(Some(1..), false)`).
 │ │ │ ├─┘
 │ │ │ │
 │ │ │ │ Total witnesses for `1..`:
 │ │ │ │   `[true]`
 │ │ ├─┘
 │ │ │ Unspecialize new witnesses with `1..`:
 │ │ │   `[1.., true]`
 │ │ │
 │ │ │ Total witnesses for `Some`:
 │ │ │   `[1.., true]`
 │ ├─┘
 │ │ Unspecialize new witnesses with `Some`:
 │ │   `[Some(1..), true]`
 │ │
 │ │ Specialize with `None`:
 │ ├─┐ Patterns:
 │ │ │   2. `[false]`
 │ │ │
 │ │ │ Specialize with `true`:
 │ │ ├─┐ Patterns:
 │ │ │ │   // no rows left
 │ │ │ │
 │ │ │ │ We have found an unmatched value (`Pair(None, true)`)! This gives us a witness.
 │ │ │ │ New witnesses:
 │ │ │ │   `[]`
 │ │ ├─┘
 │ │ │ Unspecialize new witnesses with `true`:
 │ │ │   `[true]`
 │ │ │
 │ │ │ Specialize with `false`:
 │ │ ├─┐ Patterns:
 │ │ │ │   2. `[]`
 │ │ │ │
 │ │ │ │ We note arm 2 is useful (by `Pair(None, false)`).
 │ │ ├─┘
 │ │ │
 │ │ │ Total witnesses for `None`:
 │ │ │   `[true]`
 │ ├─┘
 │ │ Unspecialize new witnesses with `None`:
 │ │   `[None, true]`
 │ │
 │ │ Total witnesses for `Pair`:
 │ │   `[Some(1..), true]`
 │ │   `[None, true]`
 ├─┘
 │ Unspecialize new witnesses with `Pair`:
 │   `[Pair(Some(1..), true)]`
 │   `[Pair(None, true)]`
 │
 │ Final witnesses:
 │   `[Pair(Some(1..), true)]`
 │   `[Pair(None, true)]`
 ┘
</code></pre></div>
<p>We conclude:</p>
<ul>
<li>Arm 3 is redundant (it was never marked as useful);</li>
<li>The match is not exhaustive;</li>
<li>Adding arms with <code>Pair(Some(1..), true)</code> and <code>Pair(None, true)</code> would make the match exhaustive.</li>
</ul>
<p>Note that when we’re deep in the algorithm, we don’t know what specialization steps got us here.
We can only figure out what our witnesses correspond to by unspecializing back up the stack.</p>
<h2 id="tests"><a class="doc-anchor" href="#tests">§</a>Tests</h2>
<p>Note: tests specific to this file can be found in:</p>
<ul>
<li><code>ui/pattern/usefulness</code></li>
<li><code>ui/or-patterns</code></li>
<li><code>ui/consts/const_in_pattern</code></li>
<li><code>ui/rfc-2008-non-exhaustive</code></li>
<li><code>ui/half-open-range-patterns</code></li>
<li>probably many others</li>
</ul>
<p>I (Nadrieril) prefer to put new tests in <code>ui/pattern/usefulness</code> unless there’s a specific
reason not to, for example if they crucially depend on a particular feature like <code>or_patterns</code>.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Matrix.html" title="struct rustc_pattern_analysis::usefulness::Matrix">Matrix</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">A 2D matrix. Represents a list of pattern-tuples under investigation.</div></li><li><div class="item-name"><a class="struct" href="struct.MatrixRow.html" title="struct rustc_pattern_analysis::usefulness::MatrixRow">MatrixRow</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">A row of the matrix.</div></li><li><div class="item-name"><a class="struct" href="struct.PatStack.html" title="struct rustc_pattern_analysis::usefulness::PatStack">PatStack</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Represents a pattern-tuple under investigation.</div></li><li><div class="item-name"><a class="struct" href="struct.PlaceCtxt.html" title="struct rustc_pattern_analysis::usefulness::PlaceCtxt">PlaceCtxt</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Context that provides information local to a place under investigation.</div></li><li><div class="item-name"><a class="struct" href="struct.PlaceInfo.html" title="struct rustc_pattern_analysis::usefulness::PlaceInfo">PlaceInfo</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Data about a place under investigation. Its methods contain a lot of the logic used to analyze
the constructors in the matrix.</div></li><li><div class="item-name"><a class="struct" href="struct.UsefulnessCtxt.html" title="struct rustc_pattern_analysis::usefulness::UsefulnessCtxt">UsefulnessCtxt</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Context that provides information for usefulness checking.</div></li><li><div class="item-name"><a class="struct" href="struct.UsefulnessReport.html" title="struct rustc_pattern_analysis::usefulness::UsefulnessReport">UsefulnessReport</a></div><div class="desc docblock-short">The output of checking a match for exhaustiveness and arm usefulness.</div></li><li><div class="item-name"><a class="struct" href="struct.WitnessMatrix.html" title="struct rustc_pattern_analysis::usefulness::WitnessMatrix">WitnessMatrix</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Represents a set of pattern-tuples that are witnesses of non-exhaustiveness for error
reporting. This has similar invariants as <code>Matrix</code> does.</div></li><li><div class="item-name"><a class="struct" href="struct.WitnessStack.html" title="struct rustc_pattern_analysis::usefulness::WitnessStack">WitnessStack</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">A witness-tuple of non-exhaustiveness for error reporting, represented as a list of patterns (in
reverse order of construction).</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.PlaceValidity.html" title="enum rustc_pattern_analysis::usefulness::PlaceValidity">PlaceValidity</a></div><div class="desc docblock-short">Track whether a given place (aka column) is known to contain a valid value or not.</div></li><li><div class="item-name"><a class="enum" href="enum.Usefulness.html" title="enum rustc_pattern_analysis::usefulness::Usefulness">Usefulness</a></div><div class="desc docblock-short">Indicates whether or not a given arm is useful.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.collect_non_contiguous_range_endpoints.html" title="fn rustc_pattern_analysis::usefulness::collect_non_contiguous_range_endpoints">collect_non_contiguous_range_endpoints</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Collect ranges that have a singleton gap between them.</div></li><li><div class="item-name"><a class="fn" href="fn.collect_overlapping_range_endpoints.html" title="fn rustc_pattern_analysis::usefulness::collect_overlapping_range_endpoints">collect_overlapping_range_endpoints</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Collect ranges that overlap like <code>lo..=overlap</code>/<code>overlap..=hi</code>. Must be called during
exhaustiveness checking, if we find a singleton range after constructor splitting. This reuses
row intersection information to only detect ranges that truly overlap.</div></li><li><div class="item-name"><a class="fn" href="fn.compute_exhaustiveness_and_usefulness.html" title="fn rustc_pattern_analysis::usefulness::compute_exhaustiveness_and_usefulness">compute_exhaustiveness_and_usefulness</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">The core of the algorithm.</div></li><li><div class="item-name"><a class="fn" href="fn.compute_match_usefulness.html" title="fn rustc_pattern_analysis::usefulness::compute_match_usefulness">compute_match_usefulness</a></div><div class="desc docblock-short">Computes whether a match is exhaustive and which of its arms are useful.</div></li></ul></section></div></main></body></html>