searchState.loadedDescShard("rustc_expand", 0, "Raw content of Fluent resource for this crate, generated …\nConverts a macro item into a syntax extension.\nConditional compilation stripping.\nThis module implements declarative macros: old <code>macro_rules</code> …\nA token-based attribute macro.\nA token-based function-like macro.\nA token-based derive macro.\nFill-in macro expansion result, to allow compilation to …\nResult of an expansion that may need to be retried. …\nOne of these is made during expansion and incrementally …\nA glob delegation.\nError type that denotes indeterminacy.\nAn AST-based attribute macro.\nAn AST-based function-like macro.\nAn AST-based derive macro.\n<code>MacResult</code> implementation for the common case where you’…\nThe result of a macro expansion. The return values of the …\nA trivial attribute “macro” that does nothing, only …\nNo value.\nExpansion produced a result (possibly dummy).\nExpansion produced a result (possibly dummy).\nExpansion could not produce a result and needs to be …\nExpansion could not produce a result and needs to be …\nSome value of type <code>T</code>.\nA struct representing a macro definition in “lowered” …\nA syntax extension kind.\nRepresents a thing that maps token trees to Macro Results\nSuppresses the <code>unsafe_code</code> lint for code produced by this …\nList of unstable features that are treated as stable …\nCreates a default MacResult that can be anything.\nSame as <code>any</code>, but must be a valid fragment, not error.\nUsed for storing lints generated during expansion, like …\nBuilt-in macros have a couple of special properties like …\nPath resolution logic for <code>#[cfg_accessible(path)]</code>.\nShould debuginfo for the macro be collapsed to the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe order of items in the HIR is unrelated to the order of …\nConstructs a syntax extension with default properties.\nThe macro’s deprecation info.\nDirectory to search child module files in, often (but not …\nA dummy bang macro <code>foo!()</code>.\nA dummy derive macro <code>#[derive(Foo)]</code>.\nEdition of the crate in which this macro is defined.\n<code>meta_item</code> is the attribute, and <code>item</code> is the item being …\nWhen we ‘expand’ an inert attribute, we leave it in …\nReturns a <code>Folder</code> for deeply expanding all macros in an AST …\nReturns span for the macro which originally caused the …\nReturns the current expansion kind’s description.\n<code>[expr1, expr2, ...]</code>\n<code>&amp;[expr1, expr2, ...]</code>\nStack of paths to files loaded by out-of-line module items,\nError recovery mode entered when expansion is stuck (or …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nif-ext - if macro from different crate (related to …\nDecodes the proc-macro quoted span in the specified crate, …\nNames of specific methods to which glob delegation expands.\nDoes <code>#[derive(...)]</code> attribute with the given <code>ExpnId</code> have …\nNames of helper attributes registered by this macro.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA syntax extension kind.\nSome parent node that is close to this macro call\nUsed for running pre-expansion lints on freshly loaded …\nEnables the macro helper hack (<code>ident!(...)</code> -&gt; …\nReturns which kind of macro calls this syntax extension.\nCreates an expression.\nCreates zero or more items in an <code>extern {}</code> block\nCreates zero or more impl items.\nCreates zero or more items.\nCreates a pattern.\nCreates zero or more statements.\nCreates zero or more trait items.\nPath to the module starting from the crate name, like …\nReturns a <code>Folder</code> that deeply expands all macros and …\nConstructs a syntax extension with the given properties …\nIf this item looks like a specific enums from <code>rental</code>, emit …\nA plain dummy expression.\nMark this invocation id as a glob delegation.\nTools registered with <code>#![register_tool]</code> and used by tool …\nResolve paths inside the <code>#[derive(...)]</code> attribute with the …\nResolves a <code>path</code> mentioned inside Rust code, returning an …\nSpan of the macro definition.\nThe macro’s stability info.\nGenerates <code>let _: Type;</code>, which is usually used for type …\nTake resolutions for paths inside the <code>#[derive(...)]</code> …\nEquivalent of <code>Span::call_site</code> from the proc macro API, …\nEquivalent of <code>Span::def_site</code> from the proc macro API, …\nEquivalent of <code>Span::mixed_site</code> from the proc macro API, …\nA folder that strips out items that do not belong in the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nIf <code>true</code>, perform cfg-stripping on attached tokens. This is …\nPerforms cfg-expansion on <code>stream</code>, producing a new …\nParse and expand a single <code>cfg_attr</code> attribute into a list …\nReturns the argument unchanged.\nDetermines if a node with the given attributes should be …\nCalls <code>U::from(self)</code>.\nIf attributes are not allowed on expressions, emit an …\nParse and expand all <code>cfg_attr</code> attributes into a list of …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA fragment of AST that can be produced by a single macro …\n“Discriminant” of an AST fragment.\nA trait implemented for all <code>AstFragment</code> nodes and …\nThis struct is a hack to workaround unstable of …\nWraps a call to <code>walk_*</code> / <code>walk_flat_map_*</code> for an AST node …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCollects all macro invocations reachable at this time in …\nAll of the names (items) declared by this node. This is an …\nA macro’s expansion does not fit in this fragment kind. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRecursively expand all macro invocations in this AST …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf true, show backtraces for proc-macro panics\nIf false, strip <code>#[test]</code> nodes\nIf true, use verbose debugging for <code>proc_macro::Span</code>\nIf <code>item</code> is an attribute invocation, remove the attribute …\nContains the sub-token-trees of a “delimited” token …\nA delimited sequence, e.g. <code>($e:expr)</code> (RHS) or <code>{ $e }</code> (LHS).\nA Kleene-style repetition operator for token sequences.\ne.g., <code>$var</code>. The span covers the leading dollar and the …\ne.g., <code>$var:expr</code>. Only appears on the LHS.\nA meta-variable expression inside <code>${...}</code>.\nKleene plus (<code>+</code>) for one or more repetitions\nA kleene-style repetition sequence, e.g. <code>$($e:expr)*</code> (RHS) …\nA token. Unlike <code>tokenstream::TokenTree::Token</code> this lacks a …\nSimilar to <code>tokenstream::TokenTree</code>, except that <code>Sequence</code>, …\nKleene star (<code>*</code>) for zero or more repetitions\nKleene optional (<code>?</code>) for zero or one repetitions\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the given token tree is delimited.\nReturns <code>true</code> if the given token tree is a token of the …\nWhether the sequence can be repeated zero (*), or one or …\nChecks that meta-variables in macro definition are …\nThis is an NFA-based parser, which calls out to the main …\nThe number of <code>Match</code>s that appear in the sequence (and …\nThe optional separator\nRetrieves the <code>TokenTree</code>’s span.\nFIXME: #67062 has details about why this is sub-optimal.\nThe sequence of token trees\nThe tracker used for the slow error path that collects …\nCurrently used by macro_rules! compilation to extract a …\nWhich arm’s failure should we report? (the one furthest …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates an appropriate parsing failure message. For EOF, …\nInformation attached to a meta-variable binder in LHS.\nAn environment of meta-variables to their binder …\nEmpty stack.\nNothing that matches a nested macro definition was …\nThe keyword <code>macro</code> was processed.\nThe keyword <code>macro</code> followed by a name was processed.\nThe keyword <code>macro</code> followed by a name and a token delimited …\nThe token <code>macro_rules</code> was processed.\nThe tokens <code>macro_rules!</code> were processed.\nThe tokens <code>macro_rules!</code> followed by a name were processed. …\nThe state at which we entered a macro definition in the …\nRepresents the processed prefix of a nested macro.\nA non-empty stack.\nStack represented as linked list.\nThe binders of the branch where we entered the macro …\nChecks <code>lhs</code> as part of the LHS of a macro definition, …\nChecks that meta-variables are used correctly in a macro …\nChecks the body of nested macro, returns where the check …\nChecks <code>tts</code> as part of the RHS of a macro definition, tries …\nChecks <code>rhs</code> as part of the RHS of a macro definition and …\nChecks that a meta-variable occurrence is valid.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the binder information of a meta-variable.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether a stack is empty.\nThe stack of Kleene operators (outermost first).\nThe stack of Kleene operators (outermost first) where we …\nReturns whether <code>binder_ops</code> is a prefix of <code>occurrence_ops</code>.\nReturns a new stack with an element of top.\nThe span of the meta-variable in LHS.\nThe previous elements.\nThe top element.\nFatal error (malformed macro?). Abort compilation.\nFatal error (malformed macro?). Abort compilation.\nArm failed to match. If the second parameter is <code>token::Eof</code>…\nArm failed to match. If the second parameter is <code>token::Eof</code>…\nA unit within a matcher that a <code>MatcherPos</code> can refer to. …\nA single matcher position, representing the state of …\n<code>NamedMatch</code> is a pattern-match result for a single metavar. …\nContains a mapping of <code>MacroRulesNormalizedIdent</code>s to …\nA <code>ParseResult</code> where the <code>Success</code> variant contains a mapping …\nRepresents the possible results of an attempted parse.\nParsed successfully.\nParsed successfully.\nThe set of mps that are waiting for the black-box parser.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCount how many metavars declarations are in <code>matcher</code>.\nThe set of current mps to be processed. This should be …\nPre-allocate an empty match array, so it can be cloned …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe index into <code>TtParser::locs</code>, which represents the “dot…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe matches made against metavar decls so far. On a …\nThe set of newly generated mps. These are used to …\nMatch the token stream from <code>parser</code> against <code>matcher</code>.\nProcess the matcher positions of <code>cur_mps</code> until it is …\nAdds <code>m</code> as a named match for the <code>metavar_idx</code>-th metavar. …\nPerforms a token equality check, ignoring syntax context …\nThe contents of <code>ParseResult::Failure</code>.\nWe are not allowed to retry macro expansion as a fatal …\nA noop tracker that is used in the hot path of the …\nThis is only used for implicit token trees. The …\nThis is used in most cases.\nThis is called after an arm has been parsed, either …\nThis is called before trying to match next MatcherLoc on …\nArm failed to match. If the token is <code>token::Eof</code>, it …\nChecks that the lhs contains no repetition which could …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nConverts a macro item into a syntax extension.\nFor tracing.\nExpands the rules based macro defined by <code>lhses</code> and <code>rhses</code> …\nReturns <code>true</code> if a fragment of type <code>frag</code> can be followed by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>frag</code> can legally be followed by the token …\nWhether or not this macro is defined in the current crate\nThe ident of the macro we’re parsing\nSpan of the expansion site of the macro this parser is for\nTry expanding the macro. Returns the index of the …\nUnification of two or more identifiers.\nThe number of repetitions of an identifier.\nIdentifier WITHOUT a preceding dollar sign, which means …\nIgnore a meta-variable for repetition without expansion.\nThe index of the repetition at a particular depth, where 0 …\nThe length of the repetition at a particular depth, where …\nFor example, a number or a string.\nA meta-variable expression, for expansions based on …\nIndicates what is placed in a <code>concat</code> parameter. For …\nIdentifier WITH a preceding dollar sign, which means that …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nExpects that the next item is a dollar sign.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAttempt to parse a meta-variable expression from a token …\nParse a meta-variable <code>count</code> expression: …\nParses the depth used by index(depth) and len(depth).\nParses an generic ident\nTries to move the iterator forward returning <code>true</code> if there …\nTries to move the iterator forward returning <code>true</code> if there …\nTakes a token and returns <code>Some(KleeneOp)</code> if the token is <code>+</code> …\nAsks for the <code>macro_metavar_expr</code> feature if it is not …\nTakes a <code>tokenstream::TokenStream</code> and returns a …\nParse the next token tree of the input looking for a …\nAttempt to parse a single Kleene star, possibly with a …\nTakes a <code>tokenstream::TokenTree</code> and returns a …\nA <code>MetaVar</code> with an actual <code>MatchedSeq</code>. The length of the …\nTwo <code>Constraint</code>s on the same sequence had different …\nAn iterator over the token trees in a delimited token tree …\nAn accumulator over a TokenTree to be used with <code>fold</code>. …\nNo constraints on length of matcher. This is true for any …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nUsed solely by the <code>count</code> meta-variable expression, counts …\nExtracts an metavariable symbol that can be an identifier, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven a <code>tree</code>, make sure that all sequences have the same …\nLookup the meta-var named <code>ident</code> and return the matched …\nReturns a <code>NamedMatch</code> item declared on the LHS given an …\nStore the metavariable span for this original span into a …\nUsed by meta-variable expressions when an user input is …\nThis can do Macro-By-Example transcription.\nFind incompatibilities in matcher/invocation sizes.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns a path to a module.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDerive a submodule path from the first found …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSaves the provided span into the metadata of <em>the crate we </em>…")