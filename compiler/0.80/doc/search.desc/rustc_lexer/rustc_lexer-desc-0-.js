searchState.loadedDescShard("rustc_lexer", 0, "Low-level Rust lexer.\n“&amp;”\n“@”\n“!”\nBase of numeric literal encoding according to its prefix.\nLiteral starts with “0b”.\n<code>/* block comment */</code>\n“b’a’”, “b’\\‘”, “b’‘’”, “b’;…\n“b“abc”“, “b“abc”\n<code>c&quot;abc&quot;</code>, <code>c&quot;abc</code>\n“^”\n“‘a’”, “‘\\’”, “‘’‘”, “’;”\n“}”\n“]”\n“)”\n“:”\n“,”\nPeekable iterator over a char sequence.\nLiteral doesn’t contain a prefix.\n“$”\n“.”\nEnd of input.\n“=”\n“12.34f32”, “1e3”, but not “1f32”.\n“&gt;”\nLiteral starts with “0x”.\n“ident” or “continue”\n“12_u8”, “0o100”, “0b120i99”, “1f32”.\nLike the above, but containing invalid unicode codepoints.\nSimilar to the above, but <em>always</em> an error on every …\nNon <code>#</code> characters exist between <code>r</code> and <code>&quot;</code>, e.g. <code>r##~&quot;abcde&quot;##</code>\n“’a”\n“// comment”\nExamples: <code>12u8</code>, <code>1.0e-40</code>, <code>b&quot;123&quot;</code>. Note that <code>_</code> is an invalid …\nEnum representing the literal types supported by the lexer.\n“&lt;”\n“-”\nThe string was not terminated, e.g. <code>r###&quot;abcde&quot;##</code>. …\nLiteral starts with “0o”.\n“{”\n“[”\n“(”\n“|”\n“%”\n“+”\n“#”\n“?”\n“br“abc”“, “br#“abc”#“, “br####“ab”…\n<code>cr&quot;abc&quot;</code>, “cr#“abc”#“, <code>cr#&quot;a</code>. <code>None</code> indicates an …\n“r#ident”\n“r“abc”“, “r#“abc”#“, “r####“ab”###…\n“;”\n“/”\n“*”\n““abc”“, ““abc”\n“~”\nParsed token. It doesn’t contain information about data …\nEnum representing common lexeme types.\nMore than 255 <code>#</code>s exist.\nUnknown token, not expected by the lexer, e.g. “№”\nAn unknown prefix, like <code>foo#</code>, <code>foo&#39;</code>, <code>foo&quot;</code>.\nAny whitespace character sequence.\nIterator over chars. Slightly faster than a &amp;str.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if <code>c</code> is valid as a non-first character of an …\nTrue if <code>c</code> is valid as a first character of an identifier. …\nThe passed string is lexically an identifier.\nTrue if <code>c</code> is considered a whitespace according to Rust …\n<code>rustc</code> allows files to have a shebang, e.g. “…\nCreates an iterator that produces tokens from the input …\nUtilities for validating string and char literals and …\nValidates a raw string literal. Used for getting more …\nPeekable iterator over a char sequence.\nParses a token from the input string.\nMoves to the next character.\nIterator over chars. Slightly faster than a &amp;str.\nEats double-quoted string and returns true if string is …\nEats the float exponent. Returns true if at least one …\nEats symbols while predicate returns true or until the end …\nPeeks the next symbol from the input stream without …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nChecks if there is nothing more to consume.\nReturns amount of already consumed symbols.\nReturns the last eaten symbol (or <code>&#39;\\0&#39;</code> in release builds). …\nEats the double-quoted string and returns <code>n_hashes</code> and an …\nResets the number of bytes consumed to 0.\nPeeks the second symbol from the input stream without …\nPeeks the third symbol from the input stream without …\nRaw ‘\\r’ encountered.\nRaw ‘\\r’ encountered in raw string.\nUsed for ASCII chars (written directly or via <code>\\x00</code>..<code>\\x7f</code> …\n‘\\u{}’\nErrors and warnings that can occur during string …\nUnescaped character that was expected to be escaped (e.g. …\nUsed for high bytes (<code>\\x80</code>..<code>\\xff</code>).\nInvalid character in numeric escape (e.g. ‘\\xz’)\nNon-hexadecimal value in ‘\\u{..}’.\nInvalid escape character (e.g. ‘\\z’).\n‘\\u{_12}’\nEscaped ’&#39; character without continuation.\nInvalid in-bound unicode character code, e.g. ‘\\u{DFFF}…\nUsed for mixed utf8 string literals, i.e. those that allow …\nWhat kind of literal do we parse.\nExpected 1 char, but more than 1 were found.\nAfter a line ending with ’&#39;, multiple lines are skipped.\n‘\\u’ not followed by ‘{’.\nNon-ascii character in byte literal, byte string literal, …\nCharacter code in numeric escape is non-ascii (e.g. ‘\\xFF…\nOut of bounds unicode character code, e.g. ‘\\u{FFFFFF}’…\nMore than 6 characters in ‘\\u{..}’, e.g. ‘…\nNumeric character escape is too short (e.g. ‘\\x1’).\nNo closing brace in ‘\\u{..}’, e.g. ‘\\u{12’.\nUnicode escape code in byte literal.\nAfter a line ending with ’&#39;, the next line contains …\nExpected 1 char, but 0 were found.\nAre <code>\\x80</code>..<code>\\xff</code> allowed?\nAre unicode (non-ASCII) chars allowed?\nAre unicode escapes (<code>\\u</code>) allowed?\nTakes a contents of a string literal (without quotes) and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true for actual errors, as opposed to warnings.\nTakes a contents of a byte literal (without quotes), and …\nTakes a contents of a char literal (without quotes), and …\nTakes the contents of a mixed-utf8 literal (without …\nTakes a contents of a string literal (without quotes) and …\nTakes the contents of a unicode-only (non-mixed-utf8) …")