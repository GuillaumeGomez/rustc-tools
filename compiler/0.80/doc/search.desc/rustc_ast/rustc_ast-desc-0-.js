searchState.loadedDescShard("rustc_ast", 0, "The Rust Abstract Syntax Tree (AST).\nRequirements for a <code>StableHashingContext</code> to be used in this …\nThe Rust abstract syntax tree module.\nA set of traits implemented for various AST nodes, …\nFunctions dealing with attributes and meta items.\nDefinitions shared by macros / syntax extensions and e.g. …\nA <code>MutVisitor</code> represents an AST modification; it accepts an …\nThe AST pointer.\nToken Streams\nAST walker. Each overridden visit method has full control …\nThe <code>+</code> operator (addition)\nA referencing operation (<code>&amp;a</code>, <code>&amp;mut a</code>, <code>&amp;raw const a</code> or …\n<code>Type: const Trait</code>\nThe <code>&amp;&amp;</code> operator (logical and)\nThe <code>&lt;&#39;a, A, B, C&gt;</code> in <code>foo::bar::baz::&lt;&#39;a, A, B, C&gt;</code>.\nEither an argument for a generic parameter or a constraint …\nA path like <code>Foo&lt;&#39;a, T&gt;</code>.\nA constant (expression) that’s not an item or associated …\nAn anonymous struct type i.e. <code>struct { foo: Type }</code>.\nAn anonymous union type i.e. <code>union { bar: Type }</code>.\nA generic argument for a generic parameter.\nType or const parameter.\nAn arm of a ‘match’.\nAn array (e.g, <code>[a, b, c, d]</code>).\nA fixed length array (<code>[T; n]</code>).\nAn assignment (<code>a = foo()</code>). The <code>Span</code> argument is the span …\nAn assignment with an operator.\nRepresents associated items. These include items in <code>impl</code> …\nA constraint on an associated item.\nThe kind of associated item constraint.\nRepresents associated item kinds.\n<code>async</code>, which returns an <code>impl Future</code>.\n<code>Type: async Trait</code>\n<code>async gen</code>, which returns an <code>impl AsyncIterator</code>.\nArguments passed to an attribute macro.\nDistinguishes between <code>Attribute</code>s that decorate items and …\nA list of attributes.\nA syntax-level representation of an attribute.\nAn await expression (<code>my_future.await</code>). Span is of await …\nA bare function (e.g., <code>fn(usize) -&gt; bool</code>).\n<code>..x</code>.\nA tail call return, with the value to be returned.\nA binary operation (e.g., <code>a + b</code>, <code>a * b</code>).\nThe mode of a binding (<code>mut</code>, <code>ref mut</code>, etc). Used for both …\nThe <code>&amp;</code> operator (bitwise and)\nThe <code>|</code> operator (bitwise or)\nThe <code>^</code> operator (bitwise xor)\nA block (<code>{ .. }</code>).\nA block (<code>&#39;label: { ... }</code>).\nA boolean literal (<code>true</code>, <code>false</code>).\nThe kind of borrow in an <code>AddrOf</code> expression, e.g., <code>&amp;place</code> …\nA bound on an associated type (e.g., <code>AssocTy: Bound</code> in …\nThe asyncness of a trait bound.\nThe constness of a trait bound.\nThe polarity of a trait bound.\nA type bound (e.g., <code>for&lt;&#39;c&gt; Foo: Send + Clone + &#39;c</code>).\nA <code>box</code> pattern.\nThe macro statement had braces (e.g., <code>foo! { ... }</code>).\nA <code>break</code>, with an optional label to break, and an optional …\nA byte char (<code>b&#39;f&#39;</code>).\nA byte string (<code>b&quot;foo&quot;</code>). Not stored as a symbol because it …\nA C String (<code>c&quot;foo&quot;</code>). Guaranteed to only have <code>\\0</code> at the end.\nPlaceholder for a <code>va_list</code>.\nA function call.\nA capture clause used in closures and <code>async</code> blocks.\nA cast (e.g., <code>foo as f64</code>).\nA character literal (<code>&#39;a&#39;</code>).\nInclusive at the beginning and end.\nA closure (e.g., <code>move |a, b, c| a + b + c</code>).\nClosure lifetime binder, <code>for&lt;&#39;a, &#39;b&gt;</code> in …\n<code>1</code> in <code>Foo&lt;1&gt;</code>.\nA constant item (<code>const</code>).\nAn associated constant, <code>const $ident: $ty $def?;</code> where …\nAllow anonymous constants from an inline <code>const</code> block.\nA constraint on an associated item.\nA <code>continue</code>, with an optional label.\nA regular string, like <code>&quot;foo&quot;</code>.\nDescribes what kind of coroutine markers, if any, a …\nLocal declaration. Example: <code>let x;</code>\nDefault means no value was provided, it will take a …\nReturns type is not specified.\nItem defaultness. For details see the RFC #2532.\nA single delegation item (<code>reuse</code>).\nAn associated delegation item.\nA list or glob delegation item (<code>reuse prefix::{a, b, c}</code>, …\nAn associated list or glob delegation item.\nDelimited arguments, as used in <code>#[attr()/[]/{}]</code> or …\nDelimited arguments: <code>#[attr()/[]/{}]</code>.\nA <code>deref</code> pattern (currently <code>deref!()</code> macro-based syntax).\nThe <code>*</code> operator for dereferencing\nThe <code>/</code> operator (division)\nA doc comment (e.g. <code>/// ...</code>, <code>//! ...</code>, <code>/** ... */</code>, …\n<code>...</code>\n<code>..=</code>\nActs as a null expression. Lowering it will always emit a …\nSometimes we need a dummy value when no error has occurred.\nJust a trailing semi-colon.\nNo arguments: <code>#[attr]</code>.\nAn enum definition (<code>enum</code>).\nThe <code>==</code> operator (equality)\nArguments of a key-value attribute: <code>#[attr = &quot;value&quot;]</code>.\nAn equality predicate (unsupported).\nAn equality constraint for an associated item (e.g., …\nPlaceholder for a pattern that wasn’t syntactically well …\nPlaceholder for an expression that wasn’t syntactically …\nPlaceholder for a literal that wasn’t well-formed in …\nPlaceholder for a kind that has failed to be defined.\n<code>..</code>\n<code>self: TYPE</code>, <code>mut self: TYPE</code>\nAn explicit extern keyword was used with an explicit ABI.\nAn expression.\nExpr without trailing semi-colon.\nA single field in a struct expression, e.g. <code>x: value</code> and <code>y</code> …\n<code>extern</code> qualifier on a function item or function type.\nAn <code>extern crate</code> item, with the optional <em>original</em> crate …\nAccess of a named (e.g., <code>obj.foo</code>) or unnamed (e.g., <code>obj.0</code>) …\nField definition in a struct, variant or union.\nA float literal (<code>1.0</code>, <code>1f64</code> or <code>1E10f64</code>). The pre-suffix …\nA function declaration (<code>fn</code>).\nAn associated function.\nAn foreign function.\nA signature (not the body) of a function declaration.\nA function header.\nRepresents a function’s signature in a trait declaration,\nThe binder is present.\nA <code>for</code> loop, with an optional label.\nUsed to differentiate between <code>for</code> loops and <code>for await</code> …\nAn item in <code>extern</code> block.\nForeign module declaration.\nAn external module (<code>extern</code>).\nA <code>format_args!()</code> expression.\nThe <code>&gt;=</code> operator (greater than or equal to)\nAn <code>async</code> block (<code>async move { ... }</code>), or a <code>gen</code> block (…\n<code>gen</code>, which returns an <code>impl Iterator</code>.\nUsed to differentiate between <code>async {}</code> blocks and <code>gen {}</code> …\nConcrete argument in the sequence of generic args.\nThe generic arguments and associated item constraints of a …\nRepresents lifetime, type and const parameters attached to …\n<code>use prefix::*</code>\nModule-level inline assembly (from <code>global_asm!()</code>).\nThe <code>&gt;</code> operator (greater than)\nInclusive at the beginning, exclusive at the end.\nA <code>PatKind::Ident</code> may either be a new bound variable (…\nAn <code>if</code> block, with an optional <code>else</code> block.\nAn implementation.\nAn <code>impl Bound1 + Bound2 + Bound3</code> type where <code>Bound</code> is a …\nAn explicit extern keyword was used, but with implicit ABI.\nInferred type of a <code>self</code> or <code>&amp;self</code> argument in a method.\n<code>..=</code> or <code>...</code>\nBytes included via <code>include_bytes!</code> Added for optimization …\nAn indexing operation (e.g., <code>foo[2]</code>). The span represents …\nThis means the type should be inferred instead of it …\nLocal declaration with an initializer. Example: <code>let x = y;</code>\nLocal declaration with an initializer and an <code>else</code> clause. …\nInline assembly.\nOutput of the <code>asm!()</code> macro.\nInline assembly operand.\nInline assembly operand explicit register or register …\nInline assembly symbol operands get their own AST node …\nAn integer literal (<code>1</code>).\nIs the trait definition an auto trait?\nAn item definition.\nAn item definition.\nA “Label” is an identifier of some point in sources, …\nThe <code>&lt;=</code> operator (less than or equal to)\nA local (let) binding.\nA <code>let pat = expr</code> expression that is only semantically …\nA “Lifetime” is an annotation of the scope in which …\n<code>&#39;a</code> in <code>Foo&lt;&#39;a&gt;</code>.\nA lifetime definition (e.g., <code>&#39;a: &#39;b + &#39;c + &#39;d</code>).\nLifetime parameter.\nList meta item.\nA literal.\nA literal.\nA literal (e.g., <code>1</code>, <code>&quot;foo&quot;</code>).\nType of the float literal based on provided suffix.\nType of the integer literal based on provided suffix.\nThis type is used within both <code>ast::MetaItemLit</code> and <code>hir::Lit</code>…\nModule with inlined definition <code>mod foo { ... }</code>, or with …\nLocal represents a <code>let</code> statement, e.g., …\nConditionless loop (can be exited with <code>break</code>, <code>continue</code>, or …\nThe <code>&lt;</code> operator (less than)\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nRepresents a macro invocation. The <code>path</code> indicates which …\nA macro pattern; pre-expansion.\nMacro.\nA macro invocation; pre-expansion.\nA macro in the type position.\nA macro invocation.\nA macro expanding to associated items.\nA macro expanding to foreign items.\nRepresents a macro definition.\nA macro definition.\nA <code>match</code> block.\nThe kind of match expression\n<code>Type: ?Trait</code>\n<code>Type: ~const Trait</code>\nA semantic representation of a meta item. A meta item is a …\nA full MetaItem, for recursive meta items.\nThe meta item kind, containing the data after the initial …\nA literal in a meta item.\nA method call (e.g. <code>x.foo::&lt;Bar, Baz&gt;(a, b, c)</code>).\nA method call (e.g., <code>x.foo::&lt;Bar, Baz&gt;(a, b, c)</code>).\nA module declaration (<code>mod</code>).\nModule item kind.\nThe movability of a coroutine / closure literal: whether a …\nMust not contain self-references, <code>Unpin</code>.\nThe <code>*</code> operator (multiplication)\nName value meta item.\nThe <code>!=</code> operator (not equal to)\nThe <code>-</code> operator for negation\n<code>impl !Trait for Type</code>\n<code>Type: !Trait</code>\n<code>use prefix::{...}</code>\nValues inside meta item lists.\nThe never type (<code>!</code>).\n<code>Type: Trait</code>\nThe macro statement had parentheses or brackets and no …\n<code>module::StructName { field }</code>\nNo trailing <code>..</code> or expression.\nNo explicit extern keyword was used.\n<code>Type: Trait</code>\nA normal attribute.\nThe <code>!</code> operator for logical inversion\nThe binder is not present, all closure lifetimes are …\nAn <code>offset_of</code> expression (e.g., …\nAn or-pattern <code>A | B | C</code>. Invariant: <code>pats.len() &gt;= 2</code>.\nThe <code>||</code> operator (logical or)\nA parameter in a function header.\nSpecifies the enforced ordering for generic parameters. In …\nParentheses in patterns used for grouping (i.e., <code>(PAT)</code>).\nNo-op: used solely so we can pretty-print faithfully.\nNo-op; kept solely so that we can pretty-print faithfully.\nThe <code>(A, B)</code> and <code>C</code> in <code>Foo(A, B) -&gt; C</code>.\nA path like <code>Foo(A, B) -&gt; C</code>.\n<code>(..)</code> in return type notation.\nA match pattern.\nPattern types like <code>pattern_type!(u32 is 1..=)</code>, which is …\nA single field in a struct pattern.\nWhether the <code>..</code> is present in a struct fields pattern.\nAll the different flavors of pattern that Rust recognizes.\nA “Path” is essentially Rust’s notion of a name.\nA possibly qualified path pattern. Unqualified path …\nVariable reference, possibly containing <code>::</code> and/or type …\nA path (<code>module::module::...::Type</code>), optionally “qualified…\nA segment of a path: an identifier, an optional lifetime, …\n<code>impl Trait for Type</code>\n<code>Type: Trait</code>\nexpr.match { … }\nmatch expr { … }\nA raw pointer (<code>*const T</code> or <code>*mut T</code>).\nThe explicit <code>Self</code> type in a “qualified path”. The …\nA range pattern (e.g., <code>1...2</code>, <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>).\nA range (e.g., <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>; and <code>..</code> in …\nLimit types of a range (inclusive or exclusive).\nA raw borrow, <code>&amp;raw const $expr</code> or <code>&amp;raw mut $expr</code>. The …\nA raw string, like <code>r##&quot;foo&quot;##</code>.\nWas parsing recovery performed?\nA reference pattern (e.g., <code>&amp;mut (a, b)</code>).\nA normal borrow, <code>&amp;$expr</code> or <code>&amp;mut $expr</code>. The resulting type …\n<code>move</code> keyword was not specified.\nA reference (<code>&amp;&#39;a T</code> or <code>&amp;&#39;a mut T</code>).\n<code>&amp;&#39;lt self</code>, <code>&amp;&#39;lt mut self</code>\nA lifetime predicate (e.g., <code>&#39;a: &#39;b + &#39;c</code>).\nThe <code>%</code> operator (modulus)\nAn array literal constructed from one repeated element.\nA rest pattern <code>..</code>.\n<code>module::StructName { field, ..}</code>\n<code>..</code>.\nA <code>return</code>, with an optional value to be returned.\n<code>safe</code> an item is explicitly marked as <code>safe</code>.\nSafety of items.\nAlternative representation for <code>Arg</code>s describing <code>self</code> …\nExpr with a trailing semi-colon.\nThe macro statement had a trailing semicolon (e.g., …\nThe <code>&lt;&lt;</code> operator (shift left)\nThe <code>&gt;&gt;</code> operator (shift right)\ne.g. <code>42_i32</code>.\n<code>use prefix</code> or <code>use prefix as rename</code>\nA slice pattern <code>[a, b, c]</code>.\nA variable-length slice (<code>[T]</code>).\nMay contain self-references, <code>!Unpin</code>.\nA static item (<code>static</code>).\nA foreign static item (<code>static FOO: u8</code>).\nA statement. No <code>attrs</code> or <code>tokens</code> fields because each …\nA string literal (<code>&quot;foo&quot;</code>). The symbol is unescaped, and so …\nSimilar to <code>MetaItemLit</code>, but restricted to string literals.\nA struct or struct variant pattern (e.g., …\nA struct literal expression.\nStruct variant.\nA struct definition (<code>struct</code>).\nThe <code>-</code> operator (subtraction)\nA float literal with a suffix (<code>1f32</code> or <code>1E10f32</code>).\nA trait declaration (<code>trait</code>).\nTrait alias.\nModifiers on a trait bound like <code>~const</code>, <code>?</code> and <code>!</code>.\nA trait object type <code>Bound1 + Bound2 + Bound3</code> where <code>Bound</code> …\nSyntax used to declare a trait object.\n<code>TraitRef</code>s appear in impls.\nA try expression (<code>expr?</code>).\nA try block (<code>try { ... }</code>).\nA tuple (e.g., <code>(a, b, c, d)</code>).\nA tuple (<code>(A, B, C, D,...)</code>).\nA tuple pattern (<code>(a, b)</code>).\nTuple variant.\nA tuple struct/variant pattern (<code>Variant(x, y, .., z)</code>).\nEverything else.\nA type alias (<code>type</code>).\nAn foreign type.\nThe location of a where clause on a <code>TyAlias</code> (<code>Span</code>) and …\nThe span information for the two where clauses on a <code>TyAlias</code>…\nThe various kinds of type recognized by the compiler.\n<code>Bar</code> in <code>Foo&lt;Bar&gt;</code>.\nA type ascription (e.g., <code>builtin # type_ascribe(42, usize)</code>…\nAn associated type.\nUnused for now.\nUnary operator.\nA unary operation (e.g., <code>!x</code>, <code>*x</code>).\nAn underscore, used in destructuring assignment to ignore …\nA union definition (<code>union</code>).\nUnit variant.\nModule with definition outlined to a separate file <code>mod foo;</code>…\n<code>unsafe</code> an item is explicitly marked as <code>unsafe</code>.\ne.g. <code>42_u32</code>.\ne.g. <code>42</code>.\nA float literal without a suffix (<code>1.0 or 1.0E10</code>).\nPrecise capturing syntax: <code>impl Sized + use&lt;&#39;a&gt;</code>\nA use declaration item (<code>use</code>).\nA tree of paths sharing common prefixes. Used in <code>use</code> items …\nPart of <code>use</code> item to the right of its prefix.\n<code>move |x| y + x</code>.\n<code>self</code>, <code>mut self</code>\nEnum variant.\nFields and constructor ids of enum variants and structs.\nA type bound.\nA where-clause in a definition.\nAn equality predicate (unsupported).\nA single predicate in a where-clause.\nA lifetime predicate.\nA while loop, with an optional label.\nRepresents a wildcard pattern (<code>_</code>).\nWord meta item.\nA <code>do yeet</code> (aka <code>throw</code>/<code>fail</code>/<code>bail</code>/<code>raise</code>/whatever), with an …\nA <code>yield</code>, with an optional value to be yielded.\nZero value of the index.\nConverts a parsed <code>Stmt</code> to a <code>Stmt</code> with a trailing semicolon.\nAfter the equals sign.\nGet a flags value with all known bits set.\nType/lifetime parameters attached to this path. They come …\nThe comma separated parts in the <code>&lt;...&gt;</code>.\nThe arguments, e.g. <code>a, b, c</code>.\n“a” or “an”\nCheaply converts a meta item literal into a token literal.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nAttributes of the variant.\nBefore the equals sign.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nMatch arm body. Omitted if the pattern is a never pattern.\nAny generics from a <code>for</code> binding.\nThe <code>&#39;a</code> in <code>for&lt;&#39;a&gt; Foo&lt;&amp;&#39;a T&gt;</code>.\nThe type being bounded.\nTrait and lifetime bounds (<code>Clone + Send + &#39;static</code>).\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe <code>const</code> keyword, if any\nWhether all set bits in a source flags value are also set …\nWhether this contains a <code>!</code> pattern. This in particular …\nWhether this is <code>async</code>, <code>gen</code>, or nothing.\nThe following <em>isn’t</em> a parse error, but will cause …\nWhether this could be a never pattern, taking into account …\nReturn the <code>NodeId</code> of this variant’s constructor, if it …\nFields and constructor id of the variant.\nSpan of the <code>[unsafe] [extern] fn(...) -&gt; ...</code> part, i.e. …\nCreates an instance of <code>Generics</code>.\nReturn a name suitable for diagnostics.\nThe intersection of a source flags value with the …\nExplicit discriminant, e.g., <code>Foo = 1</code>.\nReturns the documentation if this is a doc comment or a …\nReturns the documentation and its kind if this is a doc …\nGet a flags value with all bits unset.\nThe <code>extern</code> keyword and corresponding ABI string, if any.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturn the fields of this variant.\nThe span of the argument block <code>|...|</code>\nThe span of the declaration block: ‘move |…| -&gt; …’\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe item was expanded from a glob delegation item.\nConvert a span and an identifier to the corresponding …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nBuilds a <code>Param</code> object from <code>ExplicitSelf</code>.\nConverts an arbitrary token into meta item literal.\nConverts a token literal into a meta item literal.\nConverts literal token into a semantic literal.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nMatch arm guard, e.g. <code>n &gt; 10</code> in …\nReturns <code>true</code> if this list item is a MetaItem with a name …\nDoes this function header have any qualifiers or is it …\n<code>true</code> if we ate a <code>where</code> token.\nMust be equal to <code>CRATE_NODE_ID</code> after the crate root is …\nId of the variant (not the constructor, see …\nPath resolution id.\nFor a single-segment meta item, returns its name; …\nFor a single-segment meta item, returns its name; …\nFor a single-segment attribute, returns its name; …\nThe name of the item. It might be a dummy name in case of …\nThe name of the item. It might be a dummy name in case of …\nThe identifier portion of this path segment.\nThe identifier for the field.\nName of the variant.\nThe name of the item. It might be a dummy name in case of …\nExtracts the value of this index as a <code>usize</code>.\n<code>inner_span</code> covers the body of the module; for a file …\nTokens inside the delimiters or after <code>=</code>. Proc macros see …\n<code>(A, B)</code>\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nTo a first-order approximation, is this a pattern?\nReturns <code>true</code> if the binary operator takes its arguments by …\nReturns <code>true</code> if the unary operator takes its argument by …\nReturns <code>true</code> if this literal is byte literal string.\nReturns <code>true</code> if it is a sugared doc comment (<code>///</code> or <code>//!</code> …\nWhether all bits in this flags value are unset.\nReturns <code>true</code> if the variant is <code>MetaItem</code>.\nReturn <code>true</code> if self is mutable\nReturn <code>true</code> if self is <strong>not</strong> mutable\nReturns <code>true</code> if this is a numeric literal.\nIs a macro placeholder.\nIf this path is a single identifier with no arguments, …\nIs this expr either <code>N</code>, or <code>{ N }</code>.\nIs this a <code>..</code> pattern?\nReturns <code>true</code> if parameter is <code>self</code>.\nReturns <code>true</code> if this literal is a string.\nReturns <code>true</code> if this literal has a suffix.\nReturns <code>true</code> if this literal has no suffix. Note: this …\nReturns <code>true</code> if <code>self</code> is a <code>MetaItem</code> and the meta item is a …\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe “semantic” representation of the literal lowered …\nReturns the <code>MetaItemLit</code> if <code>self</code> is a …\n<code>true</code> if macro was defined with <code>macro_rules</code>.\nExtracts the MetaItem from inside this Attribute.\nReturns the <code>MetaItem</code> if <code>self</code> is a <code>NestedMetaItem::MetaItem</code>.\nGets a list of inner meta items from a list <code>MetaItem</code> type.\nReturns <code>&quot;&quot;</code> (empty string) or <code>&quot;mutably &quot;</code> depending on the …\nThis is used in case you want the value span instead of …\nSee <code>MetaItem::name_value_literal_span</code>.\nWhether a macro with these arguments needs a semicolon …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe trait being implemented, if any.\n<code>C</code>\nThe pattern the field is destructured to.\nMatch arm pattern, e.g. <code>10</code> in …\nThe span of <code>a::b::Trait</code> in a path like …\nReturns <code>&quot;&quot;</code> (empty string) or <code>&quot;mut &quot;</code> depending on the …\nReturns <code>&quot;const&quot;</code> or <code>&quot;mut&quot;</code> depending on the mutability.\nThe receiver, e.g. <code>x</code>.\nReturns <code>&quot;&amp;&quot;</code> or <code>&quot;&amp;mut &quot;</code> depending on the mutability.\nThe intersection of a source flags value with the …\nIn this case this is an <code>async</code> or <code>gen</code> return, the <code>NodeId</code> …\nDistinguishes between <code>unsafe { ... }</code> and <code>{ ... }</code>.\n<code>unsafe</code> keyword accepted syntactically for macro DSLs, but …\nWhether this is <code>unsafe</code>, or has a default safety.\nThe method name and its generic arguments, e.g. …\nThe segments in the path: the things separated by <code>::</code>. …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nIf it’s a singleton list of the form <code>foo(lit)</code>, returns …\nThe overall span.\nThe span of the function, without the dot and receiver …\nSpan\nReturn the span that encompasses the attributes.\nThe index in <code>TyAlias.generics.where_clause.predicates</code> that …\nThe statements in the block.\nDenotes if the attribute decorates the following construct …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe original suffix as written in the source code.\nThe original suffix as written in source code.\nThe original literal as written in the source code.\nThe original literal as written in source code.\nThe semantic (unescaped) representation of the literal.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nAttempts to cast parameter to <code>ExplicitSelf</code>.\nRebuilds the asm template string from its pieces.\nAttempt reparsing the pattern as a type. This is intended …\nAttempts to reparse as <code>Ty</code> (for diagnostic purposes).\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nOriginal tokens this item was parsed from. This isn’t …\nOriginal tokens this item was parsed from. This isn’t …\nOriginal tokens this item was parsed from. This isn’t …\nThe <code>Foo&lt;&amp;&#39;a T&gt;</code> in <code>&lt;&#39;a&gt; Foo&lt;&amp;&#39;a T&gt;</code>.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGets the string value if <code>self</code> is a <code>MetaItem</code> and the …\nThe visibility of the variant. Syntactically accepted but …\nWalk top-down and call <code>it</code> in each place where a pattern …\nThe span of the <code>move</code> keyword.\nLifetimes in the <code>for&lt;&gt;</code> closure\nSpan of the whole <code>for&lt;&gt;</code> clause\nOptional default value for the const generic param.\nSpan of the <code>const</code> keyword.\nA utility trait to reduce boilerplate. Standard <code>Deref(Mut)</code> …\nA newtype around an AST node that implements the traits …\nA trait for AST nodes having (or not having) attributes.\nA trait for AST nodes having an ID.\nA trait for AST nodes having (or not having) collected …\nThis is <code>true</code> if this <code>HasAttrs</code> might support ‘custom’ …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is a function called <code>main</code> at the root level.\nThis function is not an entrypoint.\nThis function is <strong>not</strong> an entrypoint but simply named <code>main</code> …\nThis is a function with the <code>#[rustc_main]</code> attribute. Used …\nThis is a function with the <code>#[start]</code> attribute.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>{:.*}</code>, <code>{:.5$}</code>, or <code>{:a$}</code>, etc.\n<code>{:b}</code>\n<code>format_args(&quot;… {arg} …&quot;)</code>\n<code>{:^}</code>\n<code>{:?}</code>\n<code>{}</code>\n(Parsed) format args.\nA piece of a format template string.\nThe arguments to format_args!().\n<code>{}</code> or <code>{:.*}</code>\n<code>{:&lt;}</code>\n<code>{:5}</code> or <code>{:.5}</code>\nThe <code>x</code> flag in <code>{:x?}</code>.\n<code>{:e}</code>\n<code>{:x}</code>\nThe <code>-</code> flag.\n<code>format_args(…, arg = 1)</code>\n<code>{a}</code> or <code>{:a$}</code> or <code>{:.a$}</code>\n<code>format_args(…, arg)</code>\n<code>{1}</code> or <code>{:1$}</code> or <code>{:.1$}</code>\n<code>{:o}</code>\nThe <code>+</code> flag.\n<code>{:p}</code>\n<code>{:&gt;}</code>\nThe <code>X</code> flag in <code>{:X?}</code>.\n<code>{:E}</code>\n<code>{:X}</code>\nThe alignment. E.g. <code>{:&gt;}</code> or <code>{:&lt;}</code> or <code>{:^}</code>.\nThe <code>#</code> flag.\nIndex into <code>FormatArgs::arguments</code>.\nThe <code>x</code> or <code>X</code> flag (for <code>Debug</code> only). E.g. the <code>x</code> in <code>{:x?}</code>.\nThe fill character. E.g. the <code>.</code> in <code>{:.&gt;10}</code>.\n<code>{}</code> or <code>{:.5}</code> or <code>{:-^20}</code>, etc.\n<code>{}</code>, <code>{:?}</code>, or <code>{:x}</code>, etc.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhich argument this position refers to (Ok), or would’ve …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhat kind of position this is. See <code>FormatArgPositionKind</code>.\nThe precision. E.g. <code>{:.5}</code> or <code>{:.precision$}</code>.\nThe <code>+</code> or <code>-</code> flag.\nThe span inside the format string for the full <code>{…}</code> …\nThe span of the name or number.\nThe width. E.g. <code>{:5}</code> or <code>{:width$}</code>.\nThe <code>0</code> flag. E.g. the <code>0</code> in <code>{:02x}</code>.\nE.g., <code>|x, y| body</code>.\nSome value for the AST node that is valid but possibly …\nE.g., <code>fn foo()</code>, <code>fn foo(&amp;self)</code>, or <code>extern &quot;Abi&quot; fn foo()</code>.\nMutable token visiting only exists for the <code>macro_rules</code> …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUse a map-style function (<code>FnOnce(T) -&gt; T</code>) to overwrite a …\n<code>Span</code> and <code>NodeId</code> are mutated at the caller site.\nThis method is a hack to workaround unstable of …\nApplies the visitor to elements of interpolated nodes.\nApplies ident visitor if it’s an ident; applies other …\nMutates one item, returning the item again.\nThe <code>NodeId</code> used to represent the root of the crate.\nWhen parsing and at the beginning of doing expansions, we …\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nIdentifies an AST node.\nAn occupied entry.\nA vacant entry.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nAn owned smart pointer.\nConstruct a <code>P&lt;T&gt;</code> from a <code>T</code> value.\nMove out of the pointer. Intended for chaining …\nCreates an empty <code>P&lt;[T]&gt;</code>.\nOptionally produce a new <code>P&lt;T&gt;</code> from <code>self</code> without …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>and_then(|x| x)</code>.\nProduce a new <code>P&lt;T&gt;</code> from <code>self</code> without reallocating.\n<code>&amp;&amp;</code>\n<code>@</code>\n<code>{ ... }</code>\n<code>[ ... ]</code>\nA closing delimiter (e.g., <code>}</code>).\n<code>:</code>\n<code>,</code>\nDescribes how a sequence of token trees is delimited. …\nA doc comment token. <code>Symbol</code> is the doc comment’s data …\n<code>$</code>\n<code>.</code>\n<code>..</code>\n<code>...</code>\n<code>..=</code>\nEnd Of File\n<code>=</code>\n<code>==</code>\n<code>=&gt;</code>\n<code>&gt;=</code>\n<code>&gt;</code>\nIdentifier token. Do not forget about <code>NtIdent</code> when you …\nAn embedded AST node, as produced by a macro. This only …\n<code>∅ ... ∅</code> An invisible delimiter, that may, for example, …\n<code>&lt;-</code>\n<code>&lt;=</code>\nLifetime identifier token. Do not forget about <code>NtLifetime</code> …\nA literal token.\n<code>&lt;</code>\n<code>!=</code>\nFor interpolation during macro expansion.\n<code>!</code>\nThis identifier (and its span) is the identifier passed to …\nThis identifier (and its span) is the lifetime passed to …\nStuff inside brackets for attributes\nAn opening delimiter (e.g., <code>{</code>).\n<code>||</code>\n<code>( ... )</code>\n<code>::</code>\n<code>#</code>\n<code>?</code>\n<code>-&gt;</code>\n<code>;</code>\nUsed by proc macros for representing lifetimes, not …\n<code>~</code>\nAn English article for the literal token kind.\nAn approximation to proc-macro-style single-character …\nReturns <code>true</code> if the token can appear at the start of a …\nReturns <code>true</code> if the token can appear at the start of an …\nReturns <code>true</code> if the token can appear at the start of an …\nReturns <code>true</code> if the token is any literal, a minus (which …\nReturns <code>true</code> if the token can appear at the start of a …\nReturns <code>true</code> if the token can appear at the start of a …\nSome token that will be thrown away later.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRecovers a <code>Token</code> from an <code>Ident</code>. This creates a raw …\nThe <code>edition</code> closure is used to get the edition for the …\nKeep this in sync with <code>Token::can_begin_literal_maybe_minus</code>…\nReturns an identifier if this token is an identifier.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the token is the identifier <code>true</code> or <code>false</code>.\nReturns <code>true</code> if the token is an identifier.\nReturns <code>true</code> if the token is an identifier whose name is …\nReturns <code>true</code> if the token is the integer literal.\nReturns <code>true</code> if the token is a given keyword, <code>kw</code>.\nReturns <code>true</code> if the token is a given keyword, <code>kw</code> or if <code>case</code>…\nReturns <code>true</code> if the token is a lifetime.\nReturns <code>true</code> if the token is any literal.\nReturns <code>true</code> if the token is either the <code>mut</code> or <code>const</code> …\nReturns <code>true</code> if the token is a non-raw identifier for …\nReturns <code>true</code> if the token is either a special identifier …\nReturns <code>true</code> if this is semantically a float literal. This …\nReturns true for reserved identifiers used internally for …\nReturns <code>true</code> if the token is a keyword reserved for …\nReturns <code>true</code> if the token is a keyword used in the …\nIs the token an interpolated block (<code>$b:block</code>)?\nIs this a pre-parsed expression dropped into the token …\nReturns <code>true</code> if the token is an interpolated path.\nReturns a lifetime identifier if this token is a lifetime.\nReturns tokens that are likely to be typed accidentally …\nA convenience function for matching on identifiers during …\nFor interpolated tokens, returns a span of the fragment to …\nThe token cannot join with the following token to form a …\nAn <code>AttrTokenStream</code> is similar to a <code>TokenStream</code>, but with …\nLike <code>TokenTree</code>, but for <code>AttrTokenStream</code>.\nStores the tokens for an attribute target, along with its …\nStores the attributes for an attribute target, along with …\nA delimited sequence of token trees.\nThe token can join with the following token to form a …\nThe token can join with the following token to form a …\nA lazy version of <code>TokenStream</code>, which defers creation of an …\nBy-reference iterator over a <code>TokenStream</code>, that produces …\nIndicates whether a token can join with the following …\nA single token. Should never be <code>OpenDelim</code> or <code>CloseDelim</code>, …\nA <code>TokenStream</code> is an abstract sequence of tokens, organized …\nPart of a <code>TokenStream</code>.\nOwning by-value iterator over a <code>TokenStream</code>, that produces …\nGiven a <code>TokenStream</code> with a <code>Stream</code> of only two arguments, …\nAttributes, both outer and inner. These are stored in the …\nDesugar doc comments like <code>/// foo</code> in the stream into …\nChecks if this <code>TokenTree</code> is equal to the other, regardless …\nCompares two <code>TokenStream</code>s, checking equality without …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPush <code>stream</code> onto the end of the stream, possibly gluing …\nPush <code>tt</code> onto the end of the stream, possibly gluing it to …\nRetrieves the <code>TokenTree</code>’s span.\nConverts this <code>AttrTokenStream</code> to a plain <code>Vec&lt;TokenTree&gt;</code>. …\nCreate a <code>TokenTree::Token</code> with alone spacing.\nCreate a token stream containing a single token with alone …\nCreate a <code>TokenTree::Token</code> with joint spacing.\nCreate a <code>TokenTree::Token</code> with joint-hidden spacing.\nThe underlying tokens for the attribute target that <code>attrs</code> …\nRoutines the parser and pretty-printer use to classify AST …\nCode related to parsing literals.\nWhatever to ignore case (<code>fn</code> vs <code>Fn</code> vs <code>FN</code>) or not. Used for …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrailing brace in any other expression, such as <code>a + B {}</code>. …\nTrailing brace in a macro call, like the one in …\nThis classification determines whether various syntactic …\nDoes this expression require a semicolon to be treated as …\nIf an expression ends with <code>}</code>, returns the innermost …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns whether the leftmost token of the given expression …\nReturns the trailing return type in the given path, if it …\nIf the type’s last token is <code>}</code>, it must be due to a …\nJust a manual blank line “\\n\\n”, for layout\nNo code on either side of each line of the comment\nCode before /* foo */ and after the comment\nCode exists to the left of the comment\nMakes a doc string more presentable to users. Used by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA fast conservative estimate on whether the string can …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>+</code>\n<code>as</code>\n<code>=</code>\n<code>?=</code> where ? is one of the BinOpToken\nAssociative operator with precedence.\n<code>&amp;</code>\n<code>|</code>\n<code>^</code>\n<code>/</code>\n<code>..</code> range\n<code>..=</code> range\n<code>==</code>\n<code>&gt;</code>\n<code>&gt;=</code>\n<code>&amp;&amp;</code>\n<code>||</code>\nThe operator is left-associative\n<code>&lt;</code>\n<code>&lt;=</code>\n<code>%</code>\n<code>*</code>\nThe operator is not associative\n<code>!=</code>\nThe operator is right-associative\n<code>&lt;&lt;</code>\n<code>&gt;&gt;</code>\n<code>-</code>\nThis operator could be used to follow a block …\nExpressions that syntactically contain an “exterior” …\nGets the fixity of this operator\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new AssocOp from ast::BinOpKind.\nCreates a new AssocOP from a token\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSuppose we have <code>let _ = e</code> and the <code>order</code> of <code>e</code>. Is the <code>order</code> …\nIn <code>let p = e</code>, operators with precedence <code>&lt;=</code> this one …\nGets the precedence of this operator\nTrait bounds in generics bounds and type/trait alias. …\nAppears as a bound on a type or another lifetime.\nE.g., <code>|x, y| body</code>.\nE.g., <code>fn foo()</code>, <code>fn foo(&amp;self)</code>, or <code>extern &quot;Abi&quot; fn foo()</code>.\nAppears as a generic argument.\nTrait bounds in <code>impl</code> type. E.g., …\nAppears in a reference type.\nThe result type of the <code>visit_*</code> methods. Can be either <code>()</code>, …\nSuper traits of a trait. E.g., <code>trait A: B</code>\nTrait bounds in trait object type. E.g., …\nEach method of the <code>Visitor</code> trait is a hook to be …\nSimilar to the <code>Try</code> trait, but also implemented for <code>()</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis method is a hack to workaround unstable of …")