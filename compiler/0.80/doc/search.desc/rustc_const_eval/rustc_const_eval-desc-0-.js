searchState.loadedDescShard("rustc_const_eval", 0, "<code>rustc_driver::main</code> installs a handler that will set this …\nRaw content of Fluent resource for this crate, generated …\nCheck the bodies of <code>const</code>s, <code>static</code>s and <code>const fn</code>s for …\nReturns the diagnostic message for this error.\nAn interpreter for MIR used in CTFE and by miri\nInformation about the item currently being const-checked, …\nThe <code>Visitor</code> responsible for actually checking a <code>mir::Body</code> …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the kind of const context this <code>Item</code> represents (…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the given <code>const fn</code> is “const-stable”.\nConcrete error types for all operations which may be …\nStructural const qualification.\nPropagate <code>Qualif</code>s between locals and query the results.\nEmits an error if an expression cannot be evaluated in the …\nEmits an error at the given <code>span</code> if an expression cannot …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if <code>local</code> is <code>HasMutInterior</code> at the given …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA set that stores for each local whether it has a …\nReturns <code>true</code> if <code>local</code> is <code>NeedsDrop</code> at the given <code>Location</code>.\nReturns <code>true</code> if <code>local</code> is <code>NeedsNonConstDrop</code> at the given …\nThe span of the current statement.\nA borrow of a type that contains an <code>UnsafeCell</code> somewhere. …\nA function call where the callee is a pointer.\nA function call where the callee is not marked as <code>const</code>.\nA call to an <code>#[unstable]</code> const fn or …\nThis op is for <code>&amp;mut</code> borrows in the trailing expression of …\nAn operation that is not <em>always</em> allowed in a const context.\nA call to a <code>panic()</code> lang item where the first argument is …\nAn operation that must be removed for const-checking to …\nComparing raw pointers for equality. Not currently …\nCasting raw pointer or function pointer to an integer. Not …\nAn operation that causes const-checking to fail, but is …\nAn access to a (non-thread-local) <code>static</code>.\nAn access to a thread-local <code>static</code>.\nA borrow of a type that contains an <code>UnsafeCell</code> somewhere. …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTypes that cannot appear in the signature or locals of a …\nReturns an enum indicating whether this operation is …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLook for live drops in a const context.\nReturns <code>true</code> if we should use the more precise live drop …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether this <code>Qualif</code> might be evaluated after the promotion …\nThe name of the file used to debug the dataflow analysis …\nConstant containing interior mutability (<code>UnsafeCell&lt;T&gt;</code>). …\nWhether this <code>Qualif</code> is cleared when a local is moved from.\nConstant containing an ADT that implements <code>Drop</code>. This must …\nConstant containing an ADT that implements non-const <code>Drop</code>. …\nA “qualif”(-ication) is a way to look for something “…\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns <code>true</code> if this <code>Qualif</code> behaves sructurally for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if this <code>Qualif</code> is inherent to the given …\nReturns <code>true</code> if <em>any</em> value of the given type could possibly …\nReturns <code>true</code> if this <code>Operand</code> contains qualif <code>Q</code>.\nReturns <code>true</code> if this <code>Place</code> contains qualif <code>Q</code>.\nExtracts the field of <code>ConstQualifs</code> that corresponds to …\nReturns <code>true</code> if this <code>Rvalue</code> contains qualif <code>Q</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe dataflow analysis used to propagate qualifs on …\nA <code>Visitor</code> that propagates qualifs between locals. This …\nDescribes whether a local’s address escaped and it might …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDescribes whether a local contains qualif.\n<code>&amp;</code> only allow mutation if the borrowed place is <code>!Freeze</code>.\nExtra machine state for CTFE, and the Machine instance\nThe CTFE machine has some custom error kinds.\nContains the error value\nHard error when dereferencing a misaligned pointer.\nIgnore all alignment requirements. This is mainly used in …\nValues of this type, or this particular value, are not …\nContains the success value\nPattern matching on consts with references would be …\nWhether to check alignment during evaluation.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether the <code>def_id</code> is an unstable const fn and what …\nThis function takes the place where the result of the …\nCreate an interpreter context to inspect the given …\nThe number of terminators that have been evaluated.\nThe virtual call stack.\nIf <code>Some</code>, we are evaluating the initializer of the static …\nComputes the tag (if any) for a given type and variant.\nMacro for machine-specific <code>InterpError</code> without allocation. …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMacro for machine-specific <code>InterpError</code> without allocation. …\nThe CTFE machine has some custom error kinds.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEmit a lint from a const-eval situation, with a backtrace.\nCreate a diagnostic for a const eval error.\nThis function takes the place where the result of the …\nCreate an interpreter context to inspect the given …\nThe <code>InterpCx</code> is only meant to be used to do field and …\nThis function converts an interpreter value into a MIR …\nChecks whether an item is considered to be <code>const</code>. If it is …\nWhether the <code>def_id</code> is an unstable const fn and what …\nExtra machine state for CTFE, and the Machine instance\nHard error when dereferencing a misaligned pointer.\nWhen hitting this many interpreted terminators we emit a …\nIgnore all alignment requirements. This is mainly used in …\nAfter this many interpreted terminators, we start emitting …\nThe limit used by <code>-Z tiny-const-eval-limit</code>. This smaller …\nFind the first stack frame that is within the current …\nPattern matching on consts with references would be …\nWhether to check alignment during evaluation.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStores the <code>Machine</code> instance.\nThe virtual memory system.\nThe number of terminators that have been evaluated.\nBounds in scope for polymorphic evaluations.\nThe recursion limit (cached from <code>tcx.recursion_limit(())</code>)\nThe virtual call stack.\nIf <code>Some</code>, we are evaluating the initializer of the static …\nThe results of the type checker, from rustc. The span in …\nEvaluates a constant and turns it into a type-level …\nValtrees don’t store the <code>MemPlaceMeta</code> that all …\nConverts a <code>ValTree</code> to a <code>ConstValue</code>, which is needed after …\nPut a valtree into memory and return a reference to that.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the diagnostic message for this error.\nOne of “const”, “const_with_path”, and “static”\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtra data stored in every allocation.\nThe return value of <code>get_alloc_info</code> indicates the “kind”…\nThe functionality needed by memory to manage its …\nA reference to some allocation that was already …\nA reference to some allocation that was already …\nType for the bytes of the allocation.\nMemory allocated by <code>caller_location</code> intrinsic. Error if …\nValidation of a <code>const</code>. <code>allow_immutable_unsafe_cell</code> says …\nA <code>const</code> item\nPass a copy of the given operand.\nExtra things to check for during validation of CTFE …\nA dead allocation.\nMachines can define extra (non-instance) things that …\nAn argment passed to a function.\nThe value of a function pointer.\nA stack frame.\nExtra data stored in every call frame.\nWhat we store about a frame in an interpreter backtrace.\nA function allocation (that fn ptrs point to).\nThe memory kind to use for copied global memory (held in …\nJump to the next block in the caller, or cause UB if None …\nAn <code>Immediate</code> represents a single immediate self-contained …\nAllow for the argument to be passed in-place: destroy the …\nThe offset has to be inbounds, like <code>ptr::offset</code>.\nHow a constant value should be interned.\nA regular live data allocation.\nA MemPlace with its layout. Constructing it is only …\nMethods of this trait signifies a point where CTFE …\nAdditional memory kinds a machine wishes to distinguish …\nWhether this kind of memory is allowed to leak\nInformation required for the sound usage of a <code>MemPlace</code>.\nAdditional memory kinds a machine wishes to distinguish …\nMemory’s allocation map\nThe unsized payload (e.g. length for slices or vtable …\nReturned by <code>InterpCx::pop_stack_frame</code> when no cleanup …\nIndicates that we should <em>not</em> jump to the return/unwind …\n<code>Sized</code> types or unsized <code>extern type</code>\nIndicates that no special handling should be done - we’…\nDescribes the constraints placed on offset-projections.\nShould the machine panic on allocation failures?\nAn evaluated place, together with its type.\nA thing that we can project into, and that has a layout.\nValidation of a promoted.\nPointers are “tagged” with provenance information; …\nWhen getting the AllocId of a pointer, some extra data is …\nThe <code>Readable</code> trait describes interpreter values that one …\nState for tracking recursive validation of references\nData returned by <code>Machine::after_stack_pop</code>, and consumed by …\nThe root frame of the stack: nowhere else to jump to. …\nA single scalar value (must have <em>initialized</em> <code>Scalar</code> ABI).\nA pair of two scalar value (must have <code>ScalarPair</code> ABI where …\nStack memory. Error if deallocated except during a stack …\nThe <code>mutability</code> of the static, ignoring the type which may …\nValidation of a <code>static</code>\nA value of fully uninitialized memory. Can have arbitrary …\nA (symbolic) vtable allocation.\nHow to traverse a value and what to do when we are at the …\nNo constraints, just wrap around the edge of the address …\nThe <code>Weiteable</code> trait describes interpreter values that can …\nReturn a “root” pointer for the given allocation: the …\nAllocations local to this instance of the interpreter. The …\nCalled to evaluate <code>Assert</code> MIR terminators that trigger a …\nCalled for all binary operations where the LHS has pointer …\nThe MIR for the function called on this frame.\nExecute <code>fn_val</code>. It is the hook’s responsibility to …\nDirectly process an intrinsic without pushing a stack …\nA lot of the flexibility above is just needed for <code>Miri</code>, …\nTests if the map contains the given key. Deliberately …\nCallers should prefer <code>AllocMap::contains_key</code> when it is …\nTo be able to compare pointers with null, and to check …\nFunctions for reading and writing discriminants of …\nThe visitor must have an <code>InterpCx</code> in it.\nWhether memory accesses should be alignment-checked.\nWhether to enforce the validity invariant for a specific …\nMarks a pointer as exposed, allowing it’s provenance to …\nReturn the <code>AllocId</code> for the given <code>extern static</code>.\nExtra data for the machine.\nMap for “extra” function pointers.\nReturns data based on the keys and values in the map.\nEntry point to all function calls.\nTurn the given error into a human-readable string. Expects …\nReturns a mutable reference to entry <code>k</code>. If no such entry …\nReturns a reference to entry <code>k</code>. If no such entry exists, …\nWhether Assert(OverflowNeg) and Assert(Overflow) MIR …\nInitialize the extra state of an allocation.\nCalled immediately before a new stack frame gets pushed.\nInserts a new entry into the map.\nThe def_id and args of the current function.\nThis module specifies the type based interner for …\nIntern <code>ret</code>. This function assumes that <code>ret</code> references no …\nIntern <code>ret</code> and everything it references.\nIntrinsics and other functions that the interpreter …\nGet the layout.\nIf this is <code>Right</code>, we are not currently executing any …\nThe list of locals for this stack frame, stored in order as\nThis module contains everything needed to instantiate an …\nStores the <code>Machine</code> instance.\nThe memory subsystem.\nThe virtual memory system.\nGet the metadata of a wide value.\nOffset the value by the given amount, replacing the layout …\nFunctions concerning immediate values and operands, and …\nCalled to trigger a non-unwinding panic.\nBounds in scope for polymorphic evaluations.\nComputations on places – field projections, going from …\nThis file implements “place projections”; basically a …\n“Int-to-pointer cast”\nConvert a pointer with provenance into an …\nThe recursion limit (cached from <code>tcx.recursion_limit(())</code>)\nRemoves an entry from the map.\nThe location where the result of the current stack frame …\nWork to perform when returning from this function.\nBorrow the current thread’s stack.\nMutably borrow the current thread’s stack.\nReturns the <code>DefId</code> of the static item that is currently …\nThis module contains the <code>InterpCx</code> methods for executing a …\nThe results of the type checker, from rustc. The span in …\nConvert this to an <code>OpTy</code>. This might be an irreversible …\nThe span of the <code>tracing</code> crate is stored here. When the …\nCalled when unwinding reached a state where execution …\nThis stores whether we are currently doing reads purely …\nCheck the validity invariant of a given value, and tell …\nVisitor for a run-time value with a given layout: Traverse …\nThis local is not currently alive, and cannot be used at …\nA stack frame.\nWhat we store about a frame in an interpreter backtrace.\nJump to the next block in the caller, or cause UB if None …\nA normal, live local. Mostly for convenience, we re-use …\nState of a local variable including a memoized layout\nCurrent value of a local variable\nThe root frame of the stack: nowhere else to jump to. …\nReturn type of <code>InterpCx::pop_stack_frame</code>.\nRead the local’s value or error if the local is not yet …\nOverwrite the local. If the local can be overwritten in …\nA private helper for <code>push_stack_frame</code>.\n<code>align_offset(ptr, target_align)</code> needs special handling in …\nReturns a wide MPlace of type <code>str</code> to a new 1-aligned …\nThis is a hack because Miri needs a way to visit all the …\nReturns the result of the specified operation.\nThe MIR for the function called on this frame.\nLow-level cast helper function. Converts an apfloat <code>f</code> into …\nLow-level cast helper function. This works directly on …\nLow-level helper function to check if a ptr is in-bounds …\nCheck if the given pointer points to live memory of the …\nChecks a pointer for misalignment.\nCheck that the given vtable trait is valid for a …\nA private helper for <code>pop_stack_frame</code>. Returns <code>true</code> if …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThis function checks the data at <code>op</code> to be const-valid. <code>op</code> …\nMake a copy of the given fn_arg. Any <code>InPlace</code> are …\nMake a copy of the given fn_args. Any <code>InPlace</code> are …\nCopy <code>count*size_of::&lt;T&gt;()</code> many bytes from <code>*src</code> to <code>*dst</code>.\nCopies the data from an operand to a place. <code>src</code> and <code>dest</code> …\nCopies the data from an operand to a place. The layouts of …\nCopies the data from an operand to a place. <code>allow_transmute</code>…\nCopies the data from an operand to a place. The layouts of …\nCopies the data from an operand to a place. <code>allow_transmute</code>…\nCall a query that can return <code>ErrorHandled</code>. Should be used …\nReturns the span of the currently executed …\nGet the current location within the Frame.\nReturn the <code>SourceInfo</code> of the current instruction.\nTake an operand, representing a pointer, and dereference …\nCreate a lazy debug printer that prints the given …\nCreate a lazy debug printer for a list of allocations and …\nReturns <code>true</code> if emulation happened. Here we implement the …\nIf a span is entered, we exit the previous span (if any, …\nCheck if the two things are equal in the current …\nShared part of <code>Call</code> and <code>TailCall</code> implementation — …\nCall this function – pushing the stack frame and …\nEvaluate the arguments of a function call\nEvaluate the operand, returning a place where you can then …\nComputes a place. You should only use this if you intend …\nEvaluate a place with the goal of reading from it. This …\nEvaluate an assignment statement.\nExtra data for the machine.\nWalks up the callstack from the intrinsic’s callsite, …\nFind leaked allocations. Allocations reachable from …\nHandles ‘FloatToFloat’ and ‘FloatToInt’ casts.\nEnsures that a place is in memory, and returns where it is.\nTurn the given error into a human-readable string. Expects …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUse the already known layout if given (but sanity check in …\nGives raw, immutable access to the <code>Allocation</code> address, …\nGives raw, mutable access to the <code>Allocation</code> address, …\nReturn the <code>extra</code> field of the given allocation.\nReturn the <code>extra</code> field of the given allocation.\nObtain the size and alignment of an allocation, even if …\nReturn the <code>mutability</code> field of the given allocation.\nGives raw access to the <code>Allocation</code>, without bounds or …\nGives raw mutable access to the <code>Allocation</code>, without bounds …\nHelper function to obtain a global (tcx) allocation. This …\nObtain the size and alignment of a <em>live</em> allocation.\nInternal helper function to determine the allocation and …\nBounds-checked <em>but not align-checked</em> allocation access.\nBounds-checked <em>but not align-checked</em> allocation access.\nGet the dynamic type of the given vtable pointer. If …\nCreates a dynamic vtable for the given type and vtable …\nCall this to turn untagged “global” pointers (obtained …\nJump to the given block.\nSee documentation on the <code>ptr_guaranteed_cmp</code> intrinsic.\n“Intercept” a function call, because we have something …\nThe def_id and args of the current function.\nCall this on things you got out of the MIR (so it is as …\nCall this on things you got out of the MIR (so it is as …\nHandles ‘IntToInt’ and ‘IntToFloat’ casts.\nA helper function that allocates memory for the layout …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck whether an allocation is live. This is faster than …\nDon’t modify if <code>Some</code>, this is only used to prevent …\nCheck if these two layouts look like they are …\nIf this is <code>Right</code>, we are not currently executing any …\nRead from a local of the current frame. Will not access …\nTurn a local in the current frame into a place.\nThe list of locals for this stack frame, stored in order as\nReturns the address of the buffer where the locals are …\nStores the <code>Machine</code> instance.\nPerforms <code>num_copies</code> many copies of <code>size</code> many bytes from <code>src</code>…\nThe virtual memory system.\nTest if it is valid for a MIR assignment to assign <code>src</code>…\nTurn a mplace into a (thin or wide) mutable raw pointer, …\nConverts a repr(simd) place into a place where <code>place_index</code> …\nBy default a <code>SpanGuard</code> does nothing.\nConverts a repr(simd) operand into an operand where …\nBounds in scope for polymorphic evaluations.\nInitialize a single callee argument, checking the types …\nEvery place can be read from, so we can turn them into an …\nPops a stack frame from the stack and returns some …\nPrint the allocation’s bytes, without any nested …\nApplying a general projection\nIterates over all fields of an array. Much more efficient …\nDowncasting to an enum variant.\nOffset a pointer to project to a field of a struct/union. …\nCompute the offset and field layout for accessing the …\nSubslicing\nTurning a “maybe pointer” into a proper pointer (and …\nOffsets a pointer by some multiple of its type, returning …\nHandles ‘FnPtrToPtr’ and ‘PtrToPtr’ casts.\nTurning a “maybe pointer” into a proper pointer (and …\nCreates a new stack frame, initializes it and pushes it …\nReads the given number of bytes from memory, and strips …\nRead discriminant, return the runtime value as well as the …\nRead an immediate from a place, asserting that that is …\nTry reading an immediate in memory; this is interesting …\nTry returning an immediate for the operand. If the layout …\nRead a pointer from a place.\nRead a scalar from a place\nTurn the wide MPlace into a string (must already be …\nRead a pointer-sized signed integer from a place.\nRead a pointer-sized unsigned integer from a place.\nThe recursion limit (cached from <code>tcx.recursion_limit(())</code>)\nTake a value, which represents a (thin or wide) reference, …\nThis function is used by Miri’s provenance GC to remove …\nThe <code>args</code> are assumed to already be in our interpreter “…\nAdditional information about the action to be performed …\nPops the current frame from the stack, deallocating the …\nThe location where the result of the current stack frame …\n<code>return_place</code> of the popped stack frame.\n<em>Return</em> to the given <code>target</code> basic block. Do <em>not</em> use for …\nWork to perform when returning from this function.\n<code>return_to_block</code> of the popped stack frame.\nRuns the close in “validation” mode, which means the …\nTest if this value might be null. If the machine does not …\nReturns the actual dynamic size and alignment of the place …\nRuns the interpretation logic for the given <code>mir::Statement</code> …\nReturns <code>true</code> as long as there are more things to do.\nMark a storage as live, killing the previous content.\nIn the current stack frame, mark all locals as live that …\nComputes how to write the tag of a given variant of enum <code>ty</code>…\nThe results of the type checker, from rustc. The span in …\nEvaluate the given terminator. Will also adjust the stack …\nThe span of the <code>tracing</code> crate is stored here. When the …\nDoes a <em>typed</em> swap of <code>*left</code> and <code>*right</code>.\nReturns the result of the specified operation, whether it …\nUnwrap types that are guaranteed a …\nFind the wrapped inner type of a transparent wrapper. Must …\nTurn a <code>dyn* Trait</code> type into an value with the actual …\nTurn a place with a <code>dyn Trait</code> type into a place with the …\n<code>src</code> is a <em>pointer to</em> a <code>source_ty</code>, and in <code>dest</code> we should …\n<em>Unwind</em> to the given <code>target</code> basic block. Do <em>not</em> use for …\nThis function checks the data at <code>op</code> to be runtime-valid. <code>op</code>…\nWrites the aggregate to the destination.\nWrites the given stream of bytes into memory.\nWrites the discriminant of the given variant.\nWrite an immediate to a place\nWrite an immediate to a place. If you use this you are …\nWrite an immediate to memory. If you use this you are …\nWrite a pointer to a place\nRepeats <code>operand</code> into the destination. <code>dest</code> must have array …\nWrite a scalar to a place\nA <code>const</code> item\nHow a constant value should be interned.\nThe <code>mutability</code> of the static, ignoring the type which may …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>DefId</code> and feeds all the right queries to …\nIntern <code>ret</code>. This function assumes that <code>ret</code> references no …\nIntern <code>ret</code> and everything it references.\nIntern an allocation. Returns <code>Err</code> if the allocation does …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the <code>DefId</code> of the static item that is currently …\nDirectly returns an <code>Allocation</code> containing an absolute path …\nThe logic for all nullary intrinsics is implemented here. …\nDetermines whether <code>eval_mir_constant</code> can never fail …\nDetermines whether <code>eval_mir_constant</code> can never fail …\nExtra data stored in every allocation.\nThe functionality needed by memory to manage its …\nType for the bytes of the allocation.\nMachines can define extra (non-instance) things that …\nExtra data stored in every call frame.\nThe memory kind to use for copied global memory (held in …\nMethods of this trait signifies a point where CTFE …\nWhether this kind of memory is allowed to leak\nAdditional memory kinds a machine wishes to distinguish …\nMemory’s allocation map\nReturned by <code>InterpCx::pop_stack_frame</code> when no cleanup …\nIndicates that we should <em>not</em> jump to the return/unwind …\nIndicates that no special handling should be done - we’…\nShould the machine panic on allocation failures?\nPointers are “tagged” with provenance information; …\nWhen getting the AllocId of a pointer, some extra data is …\nData returned by <code>Machine::after_stack_pop</code>, and consumed by …\nReturn a “root” pointer for the given allocation: the …\nCalled to adjust global allocations to the Provenance and …\nCalled to adjust global allocations to the Provenance and …\nCalled immediately after actual memory was allocated for a …\nCalled immediately after actual memory was allocated for a …\nCalled immediately after a stack frame got popped, but …\nCalled immediately after a stack frame got popped, but …\nCalled immediately after a stack frame got pushed and its …\nCalled immediately after a stack frame got pushed and its …\nGives the machine a chance to detect more misalignment …\nGives the machine a chance to detect more misalignment …\nCalled to evaluate <code>Assert</code> MIR terminators that trigger a …\nCalled before a global allocation is accessed. <code>def_id</code> is …\nCalled before a global allocation is accessed. <code>def_id</code> is …\nHook for performing extra checks on any memory read access,\nHook for performing extra checks on any memory read access,\nHook for performing extra operations on a memory …\nHook for performing extra operations on a memory …\nHook for performing extra checks on a memory read access.\nHook for performing extra checks on a memory read access.\nHook for performing extra checks on a memory write access. …\nHook for performing extra checks on a memory write access. …\nCalled just before the return value is copied to the …\nCalled just before the return value is copied to the …\nCalled before a basic block terminator is executed.\nCalled before a basic block terminator is executed.\nCalled for all binary operations where the LHS has pointer …\nExecute <code>fn_val</code>. It is the hook’s responsibility to …\nDirectly process an intrinsic without pushing a stack …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nA lot of the flexibility above is just needed for <code>Miri</code>, …\nTests if the map contains the given key. Deliberately …\nCallers should prefer <code>AllocMap::contains_key</code> when it is …\nWhether function calls should be ABI-checked.\nWhether function calls should be ABI-checked.\nWhether memory accesses should be alignment-checked.\nWhether to enforce the validity invariant for a specific …\nEvaluate the inline assembly.\nEvaluate the inline assembly.\nEvaluate the given constant. The <code>eval</code> function will do all …\nEvaluate the given constant. The <code>eval</code> function will do all …\nMarks a pointer as exposed, allowing it’s provenance to …\nReturn the <code>AllocId</code> for the given <code>extern static</code>.\nReturns data based on the keys and values in the map.\nEntry point to all function calls.\nReturns the argument unchanged.\nGenerate the NaN returned by a float operation, given the …\nGenerate the NaN returned by a float operation, given the …\nRead-only lookup.\nRead-only lookup.\nMutable lookup.\nMutable lookup.\nReturns a mutable reference to entry <code>k</code>. If no such entry …\nReturns a reference to entry <code>k</code>. If no such entry exists, …\nWhether Assert(OverflowNeg) and Assert(Overflow) MIR …\nCalled when the interpreter encounters a …\nCalled when the interpreter encounters a …\nInitialize the extra state of an allocation.\nCalled immediately before a new stack frame gets pushed.\nInserts a new entry into the map.\nCalls <code>U::from(self)</code>.\nEntry point for obtaining the MIR of anything that should …\nEntry point for obtaining the MIR of anything that should …\nCalled to trigger a non-unwinding panic.\nCalled on places used for in-place function argument and …\nCalled on places used for in-place function argument and …\n“Int-to-pointer cast”\nConvert a pointer with provenance into an …\nRemoves an entry from the map.\nExecutes a retagging operation on a compound value. …\nExecutes a retagging operation on a compound value. …\nExecutes a retagging operation for a single pointer. …\nExecutes a retagging operation for a single pointer. …\nBorrow the current thread’s stack.\nMutably borrow the current thread’s stack.\nReturn the <code>AllocId</code> for the given thread-local static in …\nReturn the <code>AllocId</code> for the given thread-local static in …\nCalled when unwinding reached a state where execution …\nThe return value of <code>get_alloc_info</code> indicates the “kind”…\nA reference to some allocation that was already …\nA reference to some allocation that was already …\nMemory allocated by <code>caller_location</code> intrinsic. Error if …\nA dead allocation.\nThe value of a function pointer.\nA function allocation (that fn ptrs point to).\nA regular live data allocation.\nAdditional memory kinds a machine wishes to distinguish …\nStack memory. Error if deallocated except during a stack …\nA (symbolic) vtable allocation.\nThis is used by priroda\nAllocations local to this instance of the interpreter. The …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nTo be able to compare pointers with null, and to check …\nMap for “extra” function pointers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>range</code> is relative to this allocation reference, not the …\nReturns whether the allocation has provenance anywhere in …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>range</code> is relative to this allocation reference, not the …\n<code>offset</code> is relative to this allocation reference, not the …\n<code>range</code> is relative to this allocation reference, not the …\nThis stores whether we are currently doing reads purely …\n<code>offset</code> is relative to this allocation reference, not the …\n<code>range</code> is relative to this allocation reference, not the …\nMark the entire referenced range as uninitialized\nAn <code>Immediate</code> represents a single immediate self-contained …\nAn <code>Operand</code> is the result of computing a <code>mir::Operand</code>. It …\nThe <code>Readable</code> trait describes interpreter values that one …\nA single scalar value (must have <em>initialized</em> <code>Scalar</code> ABI).\nA pair of two scalar value (must have <code>ScalarPair</code> ABI where …\nA value of fully uninitialized memory. Can have arbitrary …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCompute the “sub-immediate” that is located within the …\nReturns the scalar from the first component and optionally …\nReturn the immediate as a <code>ScalarInt</code>. Ensures that it has …\nTo support alloc-free locals, we are able to write …\nA MemPlace with its layout. Constructing it is only …\nInformation required for the sound usage of a <code>MemPlace</code>.\nThe unsized payload (e.g. length for slices or vtable …\n<code>Sized</code> types or unsized <code>extern type</code>\nAn evaluated place, together with its type.\nA place referring to a value allocated in the <code>Memory</code> …\nThe <code>Weiteable</code> trait describes interpreter values that can …\nA place is either an mplace or some local.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nProduces a MemPlace that works for ZST but nothing else. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdjust the provenance of the main pointer (metadata is …\nAdjust the provenance of the main pointer (metadata is …\nMetadata for unsized places. Interpretation is up to the …\nStores whether this place was created based on a …\nThe pointer can be a pure integer, with the <code>None</code> …\nTurn a mplace into a (thin or wide) pointer, as a …\nA type representing iteration over the elements of an …\nThe offset has to be inbounds, like <code>ptr::offset</code>.\nDescribes the constraints placed on offset-projections.\nA thing that we can project into, and that has a layout.\nNo constraints, just wrap around the edge of the address …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the layout.\nGet the length of a slice/string/array stored here.\nGet the length of a slice/string/array stored here.\nGet the metadata of a wide value.\nShould be the same <code>ecx</code> on each call, and match the one …\nOffset the value by the given amount, replacing the layout …\nConvert this to an <code>OpTy</code>. This might be an irreversible …\nPass a copy of the given operand.\nAn argment passed to a function.\nAllow for the argument to be passed in-place: destroy the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if the function is marked as <code>#[track_caller]</code> (…\nChecks whether a type contains generic parameters which …\nValidation of a <code>const</code>. <code>allow_immutable_unsafe_cell</code> says …\nExtra things to check for during validation of CTFE …\nWe want to show a nice path to the invalid field for …\nValidation of a promoted.\nState for tracking recursive validation of references\nValidation of a <code>static</code>\nCheck a reference or <code>Box</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\n<code>None</code> indicates this is not validating for CTFE (but for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the allocation is mutable, and whether it…\nThe <code>path</code> may be pushed to, but the part that is present …\nIf $e throws an error matching the pattern, throw a …\nCheck if this is a value of primitive type, and if yes …\nFormat a path\nHow to traverse a value and what to do when we are at the …\nThis function provides the chance to reorder the order in …\nThis function provides the chance to reorder the order in …\nThe visitor must have an <code>InterpCx</code> in it.\n<code>read_discriminant</code> can be hooked for better error messages.\n<code>read_discriminant</code> can be hooked for better error messages.\nVisits the given value as the pointer of a <code>Box</code>. There is …\nVisits the given value as the pointer of a <code>Box</code>. There is …\nCalled each time we recurse down to a field of a “…\nCalled each time we recurse down to a field of a “…\nVisits the given value as a union. No automatic recursion …\nVisits the given value as a union. No automatic recursion …\nVisits the given value, dispatching as appropriate to more …\nVisits the given value, dispatching as appropriate to more …\nCalled when recursing into an enum variant. This gives the …\nCalled when recursing into an enum variant. This gives the …\nClassify whether an operator is “left-homogeneous”, …\nClassify whether an operator is “right-homogeneous”, …\nDetermines if this type permits “raw” initialization …\nRoutines to check for relations between fully inferred …\nReturns <code>true</code> if this place is allowed to be less aligned …\nReturns whether the two types are equal up to subtyping.\nReturns whether <code>src</code> is a subtype of <code>dest</code>, i.e. <code>src &lt;: dest</code>.\nReturns <code>true</code> if this place is allowed to be less aligned …\nAllocate a <code>const core::panic::Location</code> with the provided …\nDetermines if this type permits “raw” initialization …\nImplements the ‘lax’ (default) version of the …\nImplements the ‘strict’ version of the …\nReturns whether the two types are equal up to subtyping.\nReturns whether <code>src</code> is a subtype of <code>dest</code>, i.e. <code>src &lt;: dest</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")