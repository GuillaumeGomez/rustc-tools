searchState.loadedDescShard("rustc_data_structures", 0, "Various data structures used by the Rust compiler. The …\nThis is essentially an <code>AtomicPtr</code> but is guaranteed to …\nThis is a marker for a fatal compiler error used with …\nConverts unsigned integers into a string representation …\nReturns a structure that calls <code>f</code> when dropped.\nDisables on-drop call.\nSimple file-locking apis for each OS.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAn immutable, owned value (except for interior mutability).\nrustc encodes a lot of hashes. If hashes are stored as <code>u64</code> …\nImplements <code>Tag</code> for a given type.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurns a closure that takes an <code>&amp;mut Formatter</code> into …\nThe <code>ObligationForest</code> is a utility data structure used in …\nThis calls the passed function while ensuring it won’t …\nRuns a list of blocks in parallel. The first block is …\nRust Compiler Self-Profiling\nA utility class for implementing “snapshottable” …\nType size assertion. The first argument is a type and the …\nCalculation and management of a Strict Version Hash for …\nThis module defines various operations and types that are …\nThis module implements tagged pointers.\nModule which contains the snapshot/rollback functionality …\nUnion-find implementation. The main type is …\nThis module contains collection types that don’t expose …\nAlignment of <code>Self</code>.\nA type with a statically known alignment.\nReturns the ABI-required minimum alignment of a type in …\nThis is essentially an <code>AtomicPtr</code> but is guaranteed to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUses a sorted slice <code>data: &amp;[E]</code> as a kind of “multi-map”…\n“Signaling” trait used in impl trait to tag lifetimes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWe use <code>flock</code> rather than <code>fcntl</code> on Linux, because WSL1 does …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn owned immutable value.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nType alias for a hashmap using the <code>fx</code> hash algorithm.\nType alias for a hashmap using the <code>fx</code> hash algorithm.\nA speedy hash algorithm for use within rustc. The hashmap …\nAn occupied entry.\nExisting slot with equivalent key.\nA vacant entry.\nVacant slot (no equivalent key in the map).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAlias for <code>DirectedGraph</code> + <code>StartNode</code> + <code>Predecessors</code> + …\nFinding the dominators in a control-flow graph.\nA graph module for use in dataflow, region resolution, and …\nReturns <code>true</code> if the graph has a cycle that is reachable …\nRoutine to compute the strongly connected components …\nTracks the list of dominators for each node.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nA representation optimized for a small path graphs.\nDescribes the number of vertices discovered at the time …\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nProvide deterministic ordering of nodes such that, if any …\nReturns true if <code>a</code> dominates <code>b</code>.\nEvaluate the link-eval virtual forest, providing the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nReturns the immediate dominator of node, if any.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if node is reachable from the start node.\nIterates over all edges defined in the graph\nIterates over all edges defined in the graph.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns unique ID (unique with respect to the graph …\nThe value returned by this search.\nThis <code>TriColorVisitor</code> looks for back edges in a graph, …\nA “depth-first search” iterator for a directed graph.\nThe status of a node in the depth-first search.\nThis node and all nodes reachable from it have been …\nA depth-first search that also tracks when all successors …\nWhat to do when a node is examined or becomes <code>Settled</code> …\nThis node has been examined by the depth-first search but …\nSearches all nodes reachable from the current start nodes. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBehave as if no edges exist from <code>source</code> to <code>target</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalled when a node is examined by the depth-first search.\nCalled after all nodes reachable from this one have been …\nPushes another start node onto the stack. If the node has …\nPerforms a depth-first search, starting from the given <code>root</code>…\nPerforms a depth-first search, starting from …\nReturns true if node has been visited thus far. A node is …\nVersion of <code>push_start_node</code> that is convenient for chained …\nAn annotation for an SCC. This can be a representative, …\nThis node is currently being walked as part of our DFS. It …\nThe SCC and everything reachable from it have been fully …\nThe walk found a cycle, but the entire component is not …\nIndicates that this node is a member of the given cycle …\nIndicates that this node is a member of whatever cycle …\nThis node has not yet been visited as part of the DFS.\nInformation about an invidividual SCC node.\nStrongly connected components (SCC) of a graph. The type <code>N</code> …\nThe state of walking a given node.\nReturns an iterator over the SCCs in the graph.\nContains the successors for all the Sccs, concatenated. The\nUser-specified metadata about the SCC.\nIdentifies SCCs in the graph <code>G</code> and computes the resulting …\nCreates a new SCC with <code>successors</code> as its successors and …\nA set used to strip duplicates. As we accumulate successors\nFetches the state of the node <code>r</code>. If <code>r</code> is recorded as being …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInspect a node during the DFS. We first examine its current\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNumber of SCCs,\nMerge a successor into this annotation.\nMerge two existing annotations into one during path …\nCompute SCCs without annotations.\nCompute SCCs and annotate them with a user-supplied …\nThe stack of nodes that we are visiting as part of the DFS.\nThe state of each node; used during walk to record the …\nReturns the number of SCCs in the graph.\nFor this SCC, the range of <code>all_successors</code> where its …\nConstruct the reverse graph of the SCC graph.\nReturns the SCC to which a node <code>r</code> belongs.\nData about all the SCCs.\nMaps SCC indices to their metadata, including offsets into …\nFor each node, what is the SCC index of the SCC to which it\nReturns the successors of the given SCC.\nReturns the successors of the given SCC.\nThe stack of successors: as we visit a node, we mark our …\nA function that constructs an initial SCC annotation out …\nWalks a node that has never been visited before.\nA directed graph, efficient for cases where node indices …\nCreates/initializes the index for the <code>VecGraph</code>. A helper …\nTargets (or sources for back refs) of edges\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIndices into <code>edge_targets</code> that signify a start of list of …\nGets the predecessors for <code>target</code> as a slice.\nGets the successors for <code>source</code> as a slice.\nA reference to a value that is interned, and is known to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new <code>Interned</code> value. The value referred to <em>must</em> be …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA client of a jobserver\nAcquires a token from this jobserver client.\nBlocks the current thread until a token is acquired.\nReturns amount of tokens in the read-side pipe.\nConfigures a child process to have access to this client’…\nConfigures a child process to have access to this client’…\nReturns the argument unchanged.\nAttempts to connect to the jobserver specified in this …\nAttempts to connect to the jobserver specified in this …\nCalls <code>U::from(self)</code>.\nConverts this <code>Client</code> into a helper thread to deal with a …\nCreates a new jobserver initialized with the given …\nReleases a jobserver token back to the original jobserver.\nAcquires a token from this jobserver client in a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA trivial wrapper for <code>memmap2::Mmap</code> (or <code>Vec&lt;u8&gt;</code> on WASM).\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSafety\nThis obligation, along with its subobligations, are …\nThis obligation was resolved to an error. It will be …\nThe state of one node in some tree within the forest. This …\nThis trait allows us to have two different Outcome types:\nThis obligation has not yet been selected successfully. …\nThe result type used by <code>process_obligation</code>.\nThis obligation was selected successfully, but may or may …\nThis obligation was selected successfully, but it has a …\nA cache of the nodes in <code>nodes</code>, indexed by predicate. …\nConverts this <code>ForestObligation</code> suitable for use as a cache …\nCompresses the vector, removing all popped nodes. This …\nObligations that depend on this obligation for their …\nA cache of predicates that have been successfully …\nCreates a graphviz representation of the obligation …\nReturns a vector of obligations for <code>p</code> and all of its …\nPer tree error cache. This is used to deduplicate errors, …\nBacktrace of obligations that were found to be in error.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf true, <code>dependents[0]</code> points to a “parent” node, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the total number of nodes in the forest that have …\nReturns the set of obligations that are in a pending state.\nMark all <code>Waiting</code> nodes as <code>Success</code>, except those that …\nThe list of obligations. In between calls to …\nIdentifier of the obligation tree to which this node …\nAs we do the cycle check, we invoke this callback when we …\nReport cycles between all <code>Success</code> nodes, and convert all …\nPerforms a fixpoint computation over the obligation list.\nRegisters an obligation.\nA vector reused in Self::compress() and …\nImplementations can provide a fast-path to …\nConverts all remaining obligations to the given error.\nAn owned slice.\nThis is conceptually a <code>&amp;&#39;self.owner [u8]</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSlice this slice by <code>slicer</code>.\nMakes an <code>OwnedSlice</code> out of an <code>owner</code> and a <code>slicer</code> function.\nMakes an <code>OwnedSlice</code> out of an <code>owner</code> and a <code>slicer</code> function …\nA packed 128-bit integer. Useful for reducing the size of …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA helper for recording costly arguments to self-profiling …\nAn <code>EventId</code> is a <code>StringId</code> with the additional guarantee …\nEmit structured JSON\nSomething that uniquely identifies a query invocation.\nA reference to the SelfProfiler. It can be cloned and sent …\nEmit human readable text\nWhich format to use for <code>-Z time-passes</code>\nGet a flags value with all known bits set.\nAllocates a new string in the profiling data. Does not do …\nThe interned event arguments to be recorded in the generic …\nRecord the size of an artifact that the compiler produces\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThis shim makes sure that calls only get executed if the …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nCreate an EventId from a raw u64 value. Only used …\nStart profiling a generic activity. Profiling continues …\nStart profiling a generic activity. Profiling continues …\nStart profiling a generic activity, allowing costly …\nStart profiling with some event filter for a given event. …\nGets a <code>StringId</code> for the given string. This method makes …\nGets a <code>StringId</code> for the given string. This method makes …\nStart profiling how long it takes to load a query result …\nStart profiling how long it takes to hash query results …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe <code>SelfProfiler</code> used to intern the event arguments that …\nStart profiling a query being blocked on a concurrent …\nRecord a query in-memory cache hit.\nStart profiling a query provider. Profiling continues …\nRecords a single argument within the current generic …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nStart profiling a verbose generic activity. Profiling …\nLike <code>verbose_generic_activity</code>, but with an extra arg.\nAn array of cache-line aligned inner locked structures …\nReturns the argument unchanged.\nThe shard is selected by hashing <code>val</code> with <code>FxHasher</code>.\nGet a shard with a pre-computed hash value. If …\nCalls <code>U::from(self)</code>.\nReturns a pointer which outlives <code>self</code>.\nThe shard is selected by hashing <code>val</code> with <code>FxHasher</code>.\nLike SmallVec but for C strings.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSnapshots are tokens that should be created/consumed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNew variable with given index was created.\nExtensible set of actions\nVariable with given index was changed <em>from</em> the given value.\nCommits all changes since the last snapshot. Of course, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a mutable pointer into the vec; whatever changes …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>SnapshotVec</code>. If <code>L</code> is set to <code>()</code> then most …\nReserve space for new values, just like an ordinary vec.\nUpdates the element at the given index. The old value will …\nUpdates all elements. Potentially more efficient – but …\nCreates a <code>SnapshotVec</code> using the <code>undo_log</code>, allowing …\nAn indexed multi-map that preserves insertion order while …\n<code>SortedMap</code> is a data structure with similar characteristics …\nReturns the argument unchanged.\nConstruct a <code>SortedMap</code> from a presorted set of elements. …\nGets a mutable reference to the value in the entry, or …\nIndices of the items in the set, sorted by the item’s …\nA variant of <code>SortedMap</code> that preserves insertion order.\nInserts a presorted range of elements into the map. If the …\nCalls <code>U::from(self)</code>.\nThe elements of the map in insertion order.\nIterate over elements, sorted by key\nIterate over the keys, sorted\nLooks up the key in <code>self.data</code> via <code>slice::binary_search()</code>.\nMutate all keys with the given function <code>f</code>. This mutation …\nIterate over values, sorted by key\nAn indexed multi-map that preserves insertion order while …\nReturns the argument unchanged.\nReturns the item in the map with the given index.\nReturns an iterator over the items in the map that are …\nReturns an iterator over the items in the map that are …\nIndices of the items in the set, sorted by the item’s …\nCalls <code>U::from(self)</code>.\nReturns an iterator over the items in the map in insertion …\nReturns an iterator over the items in the map in insertion …\nThe elements of the map in insertion order.\nReturns an iterator over the items in the map in insertion …\nReturns an iterator over the items in the map in insertion …\nSmall-storage-optimized implementation of a map.\nSmall-storage-optimized implementation of a set.\nA view into a single entry in a map.\nFor pointer-sized arguments arrays are faster than set/map …\nSmall-storage-optimized implementation of a map.\nadapts Item of array mut reference iterator to Item of …\nadapts Item of array reference iterator to Item of hashmap …\nProvides in-place mutable access to an occupied entry …\nReturns the number of elements the map can hold without …\nClears the map, removing all key-value pairs. Keeps the …\nReturns <code>true</code> if the map contains a value for the specified …\nClears the map, returning all key-value pairs as an …\nGets the given key’s corresponding entry in the map for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a reference to the value corresponding to the key.\nReturns the key-value pair corresponding to the supplied …\nReturns a mutable reference to the value corresponding to …\nInserts a key-value pair into the map.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the map contains no elements.\nAn iterator visiting all key-value pairs in arbitrary …\nAn iterator visiting all key-value pairs in arbitrary …\nReturns a reference to this entry’s key.\nAn iterator visiting all keys in arbitrary order. The …\nReturns the number of elements in the map.\nChanges underlying storage from array to hashmap if array …\nCreates an empty <code>SsoHashMap</code>.\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the result of …\nRemoves a key from the map, returning the value at the key …\nRemoves a key from the map, returning the stored key and …\nReserves capacity for at least <code>additional</code> more elements to …\nRetains only the elements specified by the predicate.\nShrinks the capacity of the map as much as possible. It …\nAn iterator visiting all values in arbitrary order. The …\nAn iterator visiting all values mutably in arbitrary order.\nCreates an empty <code>SsoHashMap</code> with the specified capacity.\nSmall-storage-optimized implementation of a set.\nReturns the number of elements the set can hold without …\nClears the set, removing all values.\nReturns <code>true</code> if the set contains a value.\nClears the set, returning all elements in an iterator.\nAdapter function used to return result if SsoHashMap …\nReturns the argument unchanged.\nReturns a reference to the value in the set, if any, that …\nAdds a value to the set.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the set contains no elements.\nAn iterator visiting all elements in arbitrary order. The …\nReturns the number of elements in the set.\nCreates an empty <code>SsoHashSet</code>.\nRemoves a value from the set. Returns whether the value was\nReserves capacity for at least <code>additional</code> more elements to …\nRetains only the elements specified by the predicate.\nShrinks the capacity of the set as much as possible. It …\nRemoves and returns the value in the set, if any, that is …\nCreates an empty <code>SsoHashSet</code> with the specified capacity.\nTrait for processing the result of the stable hashing …\nSomething that implements <code>HashStable&lt;CTX&gt;</code> can be hashed in …\nControls what data we do or do not hash. Whenever a …\nThis is a companion trait to <code>StableOrd</code>. Some types like …\nStable 128-bits Sip Hasher\nHashing result of <code>SipHasher128</code>\nTrait for marking a type as having a sort order that is …\nMarker to ensure that implementors have carefully …\nImplement this for types that can be turned into stable …\nConvert the finalized state of a <code>StableHasher</code> and construct\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nImplement HashStable by just calling <code>Hash::hash()</code>. Also …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGrows the stack on demand to prevent stack overflow. Call …\nThe <code>Steal</code> struct is intended to used as the value for a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>Svh</code> given the hash. If you actually want to …\nA boolean type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nThis makes locks panic if they are already held. It is …\nA type which allows mutation using a lock until the value …\nA guard holding shared access to a <code>FreezeLock</code> which is in …\nA guard holding mutable access to a <code>FreezeLock</code> which is in …\nA thread-safe reference-counting pointer. ‘Arc’ stands …\nAn RAII mutex guard returned by <code>MutexGuard::map</code>, which can …\nAn RAII read lock guard returned by <code>RwLockReadGuard::map</code>, …\nAn RAII write lock guard returned by <code>RwLockWriteGuard::map</code>…\nA synchronization primitive which can nominally be written …\nRAII structure used to release the shared read access of a …\nRepresents a list of threads which can access worker …\nTypes that can be transferred across thread boundaries.\nTypes for which it is safe to share references between …\n<code>Weak</code> is a version of <code>Arc</code> that holds a non-owning reference …\nHolds worker local values for each possible thread in a …\nRAII structure used to release the exclusive write access …\nReturns a reference to the underlying allocator.\nReturns a reference to the underlying allocator.\nProvides a raw pointer to the data.\nReturns a raw pointer to the object <code>T</code> pointed to by this …\nReturns a mutable pointer to the underlying <code>bool</code>.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nConverts to <code>Arc&lt;[T]&gt;</code>.\nConverts to <code>Arc&lt;T&gt;</code>.\nMakes a clone of the <code>Arc</code> pointer.\nMakes a clone of the <code>Weak</code> pointer that points to the same …\nComparison for two <code>Arc</code>s.\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nCreates a new <code>Arc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.\nCreates an empty str inside an Arc\nCreates an empty CStr inside an Arc\nCreates an empty <code>[T]</code> inside an Arc\nConstructs a new <code>Weak&lt;T&gt;</code>, without allocating memory. …\nCreates a new empty cell.\nCreates an <code>AtomicBool</code> initialized to <code>false</code>.\nAttempt to downcast the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a …\nDowncasts the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete …\nCreates a new <code>Weak</code> pointer to this allocation.\nDrops the <code>Arc</code>.\nDrops the <code>Weak</code> pointer.\nEquality for two <code>Arc</code>s.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nLogical “and” with a boolean value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nLogical “nand” with a boolean value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nLogical “not” with a boolean value.\nLogical “or” with a boolean value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nLogical “xor” with a boolean value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a <code>T</code> into an <code>Arc&lt;T&gt;</code>\nAllocate a reference-counted slice and fill it by cloning <code>v</code>…\nConverts an <code>OsString</code> into an Arc&lt;OsStr&gt; by moving the …\nConverts an atomically reference-counted string slice into …\nConverts a <code>PathBuf</code> into an Arc&lt;Path&gt; by moving the <code>PathBuf</code> …\nCreate an atomically reference-counted pointer from a …\nAllocate a reference-counted <code>str</code> and copy <code>v</code> into it.\nReturns the argument unchanged.\nAllocate a reference-counted <code>str</code> and copy <code>v</code> into it.\nCopies the string into a newly allocated Arc&lt;OsStr&gt;.\nMove a boxed object to a new, reference-counted allocation.\nConverts a <code>CString</code> into an Arc&lt;CStr&gt; by moving the <code>CString</code> …\nConverts a <code>&amp;CStr</code> into a <code>Arc&lt;CStr&gt;</code>, by copying the contents …\nConverts a <code>Path</code> into an <code>Arc</code> by copying the <code>Path</code> data into …\nConverts a <code>[T; N]</code> into an <code>Arc&lt;[T]&gt;</code>.\nAllocate a reference-counted slice and move <code>v</code>’s items …\nReturns the argument unchanged.\nCreate a new cell with its contents set to <code>value</code>.\nReturns the argument unchanged.\nConverts a <code>bool</code> into an <code>AtomicBool</code>.\nReturns the argument unchanged.\nConverts an <code>u32</code> into an <code>AtomicU32</code>.\nReturns the argument unchanged.\nConverts an <code>u64</code> into an <code>AtomicU64</code>.\nReturns the argument unchanged.\nConverts an <code>usize</code> into an <code>AtomicUsize</code>.\nReturns the argument unchanged.\nTakes each element in the <code>Iterator</code> and collects it into an …\nGet atomic access to a <code>&amp;mut bool</code>.\nGet atomic access to a <code>&amp;mut u32</code>.\nGet atomic access to a <code>&amp;mut u64</code>.\nGet atomic access to a <code>&amp;mut usize</code>.\nGet atomic access to a <code>&amp;mut [bool]</code> slice.\nGet atomic access to a <code>&amp;mut [u32]</code> slice.\nGet atomic access to a <code>&amp;mut [u64]</code> slice.\nGet atomic access to a <code>&amp;mut [usize]</code> slice.\nCreates a new <code>AtomicBool</code> from a pointer.\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nConstructs an <code>Arc&lt;T&gt;</code> from a raw pointer.\nConverts a raw pointer previously created by <code>into_raw</code> back …\nConstructs an <code>Arc&lt;T, A&gt;</code> from a raw pointer.\nConverts a raw pointer previously created by <code>into_raw</code> back …\n‘Greater than or equal to’ comparison for two <code>Arc</code>s.\nGets the reference to the underlying value.\nReturns a mutable reference into the given <code>Arc</code>, if there …\nGets the mutable reference to the underlying value.\nReturns a mutable reference to the underlying <code>bool</code>.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nGets the mutable reference of the contents of the cell, …\nGets the mutable reference of the contents of the cell, …\nGet non-atomic access to a <code>&amp;mut [AtomicBool]</code> slice.\nGet non-atomic access to a <code>&amp;mut [AtomicU32]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU64]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicUsize]</code> slice\nReturns a mutable reference into the given <code>Arc</code>, without …\nGets the contents of the cell, initializing it with <code>f</code> if …\nGets the contents of the cell, initializing it with <code>f</code> if …\nGreater-than comparison for two <code>Arc</code>s.\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nSame as HashMap::insert, but it may panic if there’s …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nConsumes the <code>OnceLock</code>, returning the wrapped value. Returns\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the <code>Arc</code>, returning the wrapped pointer.\nConsumes the <code>Weak&lt;T&gt;</code> and turns it into a raw pointer.\nConsumes the <code>Arc</code>, returning the wrapped pointer and …\nConsumes the <code>Weak&lt;T&gt;</code>, returning the wrapped pointer and …\n‘Less than or equal to’ comparison for two <code>Arc</code>s.\nLoads a value from the bool.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nThis module implements a lock which only uses …\nThis lock protects writes to the <code>data</code> and <code>frozen</code> fields.\nLess-than comparison for two <code>Arc</code>s.\nMakes a mutable reference into the given <code>Arc</code>.\nInequality for two <code>Arc</code>s.\nConstructs a new <code>Arc&lt;T&gt;</code>.\nConstructs a new <code>Weak&lt;T&gt;</code>, without allocating any memory. …\nCreates a new empty cell.\nCreates a new <code>AtomicBool</code>.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nConstructs a new <code>Arc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the …\nConstructs a new <code>Arc&lt;T&gt;</code> in the provided allocator.\nConstructs a new <code>Weak&lt;T, A&gt;</code>, without allocating any …\nConstructs a new <code>Arc</code> with uninitialized contents.\nConstructs a new <code>Arc</code> with uninitialized contents in the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nThis module defines parallel operations that are …\nThis gives access to a fresh parallel guard in the closure …\nPartial comparison for two <code>Arc</code>s.\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>…\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator. …\nReturns <code>true</code> if the two <code>Arc</code>s point to the same allocation …\nReturns <code>true</code> if the two <code>Weak</code>s point to the same allocation …\nSets the contents of this cell to <code>value</code>.\nStores a value into the bool.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nGets the number of strong (<code>Arc</code>) pointers to this …\nGets the number of strong (<code>Arc</code>) pointers pointing to this …\nStores a value into the bool, returning the previous value.\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nTakes the value out of this <code>OnceLock</code>, moving it back to an …\nSets the contents of this cell to <code>value</code> if the cell was …\nConstructs a new <code>Arc&lt;T&gt;</code>, returning an error if allocation …\nConstructs a new <code>Arc&lt;T, A&gt;</code> in the provided allocator, …\nConstructs a new <code>Arc</code> with uninitialized contents, …\nConstructs a new <code>Arc</code> with uninitialized contents, in the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>, return an error if …\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator, …\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nIf we have the only reference to <code>T</code> then unwrap it. …\nAttempts to upgrade the <code>Weak</code> pointer to an <code>Arc</code>, delaying …\nGets the number of <code>Weak</code> pointers to this allocation.\nGets an approximation of the number of <code>Weak</code> pointers …\nA type which allows mutation using a lock until the value …\nA guard holding shared access to a <code>FreezeLock</code> which is in …\nA guard holding mutable access to a <code>FreezeLock</code> which is in …\nClones the inner value along with the frozen state.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the inner value if frozen.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis lock protects writes to the <code>data</code> and <code>frozen</code> fields.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe value representing a locked state for the <code>Cell</code>.\nA lock which only uses synchronization if …\nA guard holding mutable access to a <code>Lock</code> which is in a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis acquires the lock assuming synchronization is in a …\nThe synchronization mode of the lock. This is explicitly …\nIndicates if synchronization is used via <code>mode_union.sync</code> …\nIndicates if the cell is locked. Only used if <code>Lock.mode</code> is …\nA lock implementation that’s only used if <code>Lock.mode</code> is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA guard used to hold panics that occur during a parallel …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis gives access to a fresh parallel guard in the closure …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe registry associated with the thread. This allows the …\nRepresents a list of threads which can access worker …\nA pointer to the <code>RegistryData</code> which uniquely identifies a …\nA thread local which contains the identifer of <code>REGISTRY</code> …\nHolds worker local values for each possible thread in a …\nGets the registry associated with the current thread. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the identifer of this registry.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the worker-local values for each thread\nCreates a new worker local where the <code>initial</code> closure …\nCreates a registry which can hold up to <code>thread_limit</code> …\nRegisters the current thread with the registry so worker …\nVerifies that the current thread is associated with the …\nNumber of unused (always zero) <strong>least-significant bits</strong> in …\nNumber of least-significant bits in the return value of …\nA <code>Copy</code> tagged pointer.\nThis describes the pointer type encapsulated by <code>TaggedPtr</code> …\nThis describes tags that the <code>TaggedPtr</code> struct can hold.\nA tagged pointer that supports pointers that implement <code>Drop</code>…\nReturns the number of bits available for use for tags in a …\nReturns the correct <code>Tag::BITS</code> constant for a set of tag …\nRe-creates the original pointer, from a raw pointer …\nRe-creates the tag from the integer returned by <code>into_usize</code>.\nTurns this pointer into a raw, non-null pointer.\nTurns this tag into an integer.\nThis is semantically a pair of <code>pointer: P</code> and <code>tag: T</code> …\nA <code>Copy</code> tagged pointer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTags <code>pointer</code> with <code>tag</code>.\nPack pointer <code>ptr</code> that comes from <code>P::into_ptr</code> with a <code>tag</code>, …\nThis is semantically a pair of <code>pointer: P</code> and <code>tag: T</code> …\nRetrieves the pointer.\nRetrieves the original raw pointer from <code>self.packed</code>.\nSets the tag to a new value.\nRetrieves the tag.\nThis provides a reference to the <code>P</code> pointer itself, rather …\nA tagged pointer that supports pointers that implement <code>Drop</code>…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTags <code>pointer</code> with <code>tag</code>.\nSets the tag to a new value.\nRetrieves the tag.\nThis is used to avoid TempDir being dropped on error paths …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIndicate that <code>a &lt; b</code> (where <code>&lt;</code> is this relation)\nLists all the base edges in the graph: the initial …\nChecks whether <code>a &lt; target</code> (transitively)\nCompute the transitive closure derived from the edges, and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nApplies the (partial) function to each edge and returns a …\nApplies the (partial) function to each edge and returns a …\nReturns the set of bounds <code>X</code> such that:\nViewing the relation as a graph, computes the “mutual …\nPare down is used as a step in the LUB computation. It …\nGiven an element A, returns the maximal set {B} of …\nPicks what I am referring to as the “postdominating” …\nThinking of <code>x R y</code> as an edge <code>x -&gt; y</code> in a graph, this …\nA trait implemented for storage types (like …\nSnapshots are tokens that should be created/consumed …\nA trait which extends <code>UndoLogs</code> to allow snapshots to be …\nA trait which allows undo actions (<code>T</code>) to be pushed which …\nA basic undo log.\nReturns the slice of actions that were taken since the …\nRemoves all items from the undo log.\nCommit: keep the changes that have been made since the …\nExtends the undo log with many undos.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if <code>self</code> has made any changes since snapshot …\nTrue if a snapshot has started, false otherwise\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHow many open snapshots this undo log currently has\nPushes a new “undo item” onto the undo log. This …\nRollback (undo) the changes made to <code>storage</code> since the …\nStarts a new snapshot. That snapshot must eventually …\nThis no-op hasher expects only a single <code>write_u64</code> call. It…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA convenient helper for unification values which must be …\nDefines the type to return when merging of two values …\nBacking store for an in-place unification table. Not …\nA unification table that uses an “in-place” vector.\nA struct which can never be instantiated. Used for the …\nAt any time, users may snapshot a unification table.  The …\nLargely internal trait implemented by the unification table\nTable of unification keys and their values. You must …\nThis trait is implemented by any type that can serve as a …\nTrait implemented for <strong>values</strong> associated with a unification …\nValue of a unification key. We implement Tarjan’s …\nCommits all changes since the last snapshot. Of course, …\nGiven a key, returns the (current) root key.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the number of keys created so far.\nCreates a fresh key with the given value.\nYou should return first the key that should be used as …\nReturns the current value for the given key. If the key has\nReserve memory for <code>num_new_keys</code> to be created. Does not …\nClears all unifications that have been performed, …\nReverses all changes since the last snapshot. Also removes …\nStarts a new snapshot. Each snapshot must be either rolled …\nObtains current value for key without any pointer chasing; …\nGiven two values, produce a new value that combines them. …\nSets the value of the key <code>a_id</code> to <code>b</code>, attempting to merge …\nUnions together two variables, merging their values. If …\nUnions two keys without the possibility of failure; only …\nUnions a key and a value without the possibility of …\nGiven two keys, indicates whether they have been unioned …\nReturns the keys of all variables created since the …\nCreates a <code>UnificationTable</code> using an external <code>undo_log</code>, …\nThis is a collection type that tries very hard to not …\nA marker trait specifying that <code>Self</code> can consume …\n<code>UnordItems</code> is the order-less version of <code>Iterator</code>. It only …\nThis is a map collection type that tries very hard to not …\nThis is a set collection type that tries very hard to not …\nExtend this unord collection with the given <code>UnordItems</code>. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the items of this set in stable sort order (as …\nReturns the entries of this map in stable sort order (as …\nReturns the items of this set in stable sort order (as …\nReturns the entries of this map in stable sort order (as …\nReturns the items of this set in stable sort order (as …\nReturns the entries of this map in stable sort order (as …\nReturns the items of this set in stable sort order (as …\nReturns the entries of this map in stable sort order (as …\nReturns the values of this map in stable sort order (as …\nA work queue is a handy data structure for tracking work …\nReturns the argument unchanged.\nAttempt to enqueue <code>element</code> in the work queue. Returns …\nCalls <code>U::from(self)</code>.\nAttempt to pop an element from the work queue.\nCreates a new work queue that starts empty, where elements …")