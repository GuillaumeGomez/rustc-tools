searchState.loadedDescShard("rustc_ast_pretty", 0, "This pretty-printer is a direct reimplementation of Philip …\nIndented relative to the indentation level of the previous …\nHow to break. Described in more detail in the module docs.\nTarget line width.\nEvery line is allowed at least this much space, even if …\nVertically aligned under whatever column this block begins …\nRing-buffer of tokens and calculated sizes\nConsistent breaking box\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInconsistent breaking box\nLevel of indentation of current line\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe token most recently popped from the left boundary of …\nRunning size of stream “…left”\nBuffered indentation to avoid writing trailing whitespace\nStack of blocks-in-progress being flushed by print\n“raw box”\nBe very careful with this!\nRunning size of stream “…right”\nPseudo-stack, really a ring too. Holds the …\nNumber of spaces left on line\nSynthesizes a comment that was not textually present in …\nA view onto a finite range of an infinitely long sequence …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAST pretty printing.\nPrint the token kind precisely, without converting <code>$crate</code> …\nPrint the token precisely, without converting <code>$crate</code> into …\nThis trait is used for both AST and HIR pretty-printing.\nReturns <code>None</code> if the first <code>col</code> chars of <code>s</code> contain a …\nDoes <code>expr</code> need parentheses when printed in a condition …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRequires you to pass an input filename and reader so that …\nPrints an expr using syntax that’s acceptable in a …\nPrints <code>expr</code> or <code>(expr)</code> when <code>needs_par</code> holds.\nPretty-prints an item.\nPrint a <code>let pat = expr</code> expression.\nThis doesn’t deserve to be called “pretty” printing, …\nShould two consecutive tokens be printed with a space …\nPrint the token kind precisely, without converting <code>$crate</code> …\nPrint the token precisely, without converting <code>$crate</code> into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTransform this fixup into the one that should apply when …\nThis is almost equivalent to <code>leftmost_subexpression_in_stmt</code>…\nThis is the difference between:\nPrint expression such that it can be parsed as a match arm.\nDetermine whether parentheses are needed around the given …\nCreate the initial fixup for printing an expression as the …\nCreate the initial fixup for printing an expression as the …\nCreate the initial fixup for printing an expression in …\nThis is the difference between:\nPrint expression such that it can be parsed back as a …\nTransform this fixup into the one that should apply when …\nDetermine whether parentheses are needed around the given …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")