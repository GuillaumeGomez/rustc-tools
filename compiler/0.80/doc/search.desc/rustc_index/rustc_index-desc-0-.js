searchState.loadedDescShard("rustc_index", 0, "Represents some newtyped <code>usize</code> wrapper.\nA view into contiguous <code>T</code>s, indexed by <code>I</code> rather than by …\nAn owned contiguous collection of <code>T</code>s, indexed by <code>I</code> rather …\nCreates a struct type <code>S</code> that can be used as an index with …\nType size assertion. The first argument is a type and the …\nA fixed-size 2D bit matrix type with a dense …\nA fixed-size bitset type with a dense representation.\nChunkSize is small to keep <code>Chunk</code> small. The static …\nA fixed-size bitset type with a partially dense, partially …\nSize of the domain representable by this type, e.g. 64 for …\nValue which represents the <code>FiniteBitSet</code> having no bits set.\nValue which represents the <code>FiniteBitSet</code> having every bit …\nA fixed-sized bitset type represented by an integer type. …\nIntegral type used to represent the bit set.\nA resizable bitset type with a dense representation.\nA fixed-size bitset type with a hybrid representation: …\nA chunk that has a mix of zeros and ones, which are …\nValue for one as the integral type.\nA chunk that is all ones; we don’t represent the ones …\nA fixed-column-size, variable-row-size 2D bit matrix with …\nA fixed-size bitset type with a sparse representation and …\nValue for zero as the integral type.\nA chunk that is all zeros; we don’t represent the zeros …\nDoes this bitwise operation change <code>out_vec</code>?\nPerform a checked left shift on the integral type.\nPerform a checked right shift on the integral type.\nThe chunks. Each one contains exactly CHUNK_BITS values, …\nClear all elements.\nSets all columns at <code>row</code> to false. Has no effect if <code>row</code> does\nUnsets the <code>index</code>th bit.\nClear excess bits in the final word.\nWARNING: this implementation of clone_from will panic if …\nReturns <code>true</code> if <code>self</code> contains <code>elem</code>.\nReturns <code>true</code> if <code>self</code> contains <code>elem</code>.\nDo the bits from <code>row</code> contain <code>column</code>? Put another way, is …\nDo the bits from <code>row</code> contain <code>column</code>? Put another way, is …\nReturns if the <code>index</code>th bit is set.\nCount the number of set bits in the set.\nCount the number of bits in the set.\nCount the number of 1s in the chunk.\nReturns the number of elements in <code>row</code>.\nGets the domain size.\nEnsure that the set can hold at least <code>min_domain_size</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new matrix, with <code>row</code> used as the value for every …\nInsert <code>elem</code>. Returns whether the set has changed.\nInsert <code>elem</code>. Returns whether the set has changed.\nReturns <code>true</code> if the set has changed.\nSets the cell at <code>(row, column)</code> to true. Put another way, …\nSets the cell at <code>(row, column)</code> to true. Put another way, …\nSets all bits to true.\nSets all bits to true.\nSets every cell in <code>row</code> to true.\nInsert all bits in the given row.\nSets <code>self = self &amp; other</code> and return <code>true</code> if <code>self</code> changed. …\nSets <code>self = self &amp; other</code> and return <code>true</code> if <code>self</code> changed. …\nSets <code>self = self &amp; other</code> and return <code>true</code> if <code>self</code> changed. …\nSets <code>self = self &amp; other</code> and return <code>true</code> if <code>self</code> changed. …\nIntersects <code>row</code> with <code>set</code>. <code>set</code> can be either <code>BitSet</code> or …\nReturns those indices that are true in rows <code>a</code> and <code>b</code>. This …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the set empty?\nIs the set empty?\nIterates over the indices of set bits in a sorted order.\nIterates through all the columns set to true in a given …\nIterates through all the columns set to true in a given …\nUnderlying iterator over the words.\nReturns the previous element present in the bitset from …\nCreates a new bitset with a given <code>domain_size</code> and chunk …\nCreates a new <code>rows x columns</code> matrix, initially empty.\nCreates a new empty sparse bit matrix with no rows or …\nCreates a new, empty bitset with a given <code>domain_size</code>.\nCreates a new, empty bitset with a given <code>domain_size</code>.\nCreates a new, empty bitset.\nCreates a new, filled bitset with a given <code>domain_size</code>.\nCreates a new, filled bitset with a given <code>domain_size</code>.\nThe offset (measured in bits) of the current word.\nThe range of bits for a given row.\nReturns <code>true</code> if the set has changed.\nReturns <code>true</code> if the set has changed.\nReturns <code>true</code> if the set has changed.\nSets the cell at <code>(row, column)</code> to false. Put another way, …\nSet <code>self = self | other</code>. In contrast to <code>union</code> returns <code>true</code> …\nSets the <code>index</code>th bit.\nSets the <code>i</code>th to <code>j</code>th bits.\nSets <code>self = self - other</code> and returns <code>true</code> if <code>self</code> changed. …\nSets <code>self = self - other</code> and returns <code>true</code> if <code>self</code> changed. …\nSets <code>self = self - other</code> and returns <code>true</code> if <code>self</code> changed. …\nSets <code>self = self - other</code> and returns <code>true</code> if <code>self</code> changed. …\nSubtracts <code>set</code> from <code>row</code>. <code>set</code> can be either <code>BitSet</code> or …\nIs <code>self</code> is a (non-strict) superset of <code>other</code>?\nConverts to a dense set, consuming itself in the process.\nSets <code>self = self | other</code> and returns <code>true</code> if <code>self</code> changed …\nSets <code>self = self | other</code> and returns <code>true</code> if <code>self</code> changed …\nSets <code>self = self | other</code> and returns <code>true</code> if <code>self</code> changed …\nSets <code>self = self | other</code> and returns <code>true</code> if <code>self</code> changed …\nUnions <code>row</code> with <code>set</code>. <code>set</code> can be either <code>BitSet</code> or …\nAdds the bits from <code>with</code> to the bits from row <code>write</code>, and …\nAdds the bits from row <code>read</code> to the bits from row <code>write</code>, and\nAdds the bits from row <code>read</code> to the bits from row <code>write</code>, and\nReturns the domain size of the bitset.\nA copy of the current word, but with any already-visited …\nGets a slice of the underlying words.\nRepresents some newtyped <code>usize</code> wrapper.\nStores a set of intervals on the indices.\nThis data structure optimizes for cases where the stored …\nEquivalent to <code>range.iter().find(|i| !self.contains(i))</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if we increased the number of elements …\nReturns true if we increased the number of elements …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterates through intervals stored in the set, in order.\nReturns the maximum (last) element present in the set from …\nA view into contiguous <code>T</code>s, indexed by <code>I</code> rather than by …\nInvert a bijective mapping, i.e. <code>invert(map)[y] = x</code> if …\nGives the next index that will be assigned when <code>push</code> is …\nReturns mutable references to two distinct elements, <code>a</code> and …\nReturns mutable references to three distinct elements.\nAn owned contiguous collection of <code>T</code>s, indexed by <code>I</code> rather …\nGrows the index vector so that it contains an entry for …\nReturns the argument unchanged.\nCreates a new vector with a copy of <code>elem</code> for each index in …\nCreates a new IndexVec with n copies of the <code>elem</code>.\nCreate an <code>IndexVec</code> with <code>n</code> elements, where the value of each\nConstructs a new <code>IndexVec&lt;I, T&gt;</code> from a <code>Vec&lt;T&gt;</code>.\nCalls <code>U::from(self)</code>.\nConstructs a new, empty <code>IndexVec&lt;I, T&gt;</code>.\nPushes an element to the array returning the index where …")