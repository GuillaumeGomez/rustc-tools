searchState.loadedDescShard("rustc_trait_selection", 1, "Calls <code>U::from(self)</code>.\nCode for the ‘normalization’ query. This consists of a …\nResult of the normalization.\nIf Some(T), a type autoderef reported an error on.\nTypes that are required to be alive in order for this type …\nIf, during the computation of the dtorck constraint, we …\nIf <code>true</code>, <code>steps</code> has been truncated due to reaching the …\nThe valid autoderef steps that could be found.\nReturns a set of constraints that needs to be satisfied in …\nThis returns true if the type <code>ty</code> is “trivial” for …\nEvaluate a given predicate, capturing overflow and …\nHelper function that canonicalizes and runs the query. If …\nEvaluates whether the predicate can be satisfied (by any …\nEvaluates whether the predicate can be satisfied in the …\nEvaluates whether the predicate can be satisfied in the …\n<code>true</code> if the type results from a dereference of a raw …\nIf Some(T), a type autoderef reported an error on.\nIf <code>true</code>, <code>steps</code> has been truncated due to reaching the …\nThe valid autoderef steps that could be found.\nResult of the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nResult of the normalization.\nNormalize <code>value</code> in the context of the inference context, …\n“Query type ops” are type ops that are implemented …\n“Type ops” are used in NLL to perform some particular …\nThe output from performing a type op\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAny region constraints from performing the type op.\nUsed for error reporting to be able to rerun the query\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nProcesses the operation and all resulting obligations, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe output from the type op.\nIn the new trait solver, we already do caching in the …\nPerforms the actual query with the canonicalized key – …\nGive query the option for a simple fast path that never …\nThe core of the <code>type_op_ascribe_user_type</code> query: for …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nProcesses the operation and all resulting obligations, …\nCalls <code>U::from(self)</code>.\nExecutes <code>op</code> and then scrapes out all the “old style” …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nWhen we have an implied bound that <code>T: &#39;a</code>, we can further …\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIt is unknown whether there is an impl.\nImplementation of an <code>AsyncFn</code>-family trait by one of the …\nImplementation of the <code>AsyncFnKindHelper</code> helper trait, which\nImplementation of an <code>AsyncIterator</code> trait by one of the …\nA builtin implementation for some specific traits, used in …\nWhen does the builtin impl for <code>T: Trait</code> apply?\nImplementation of a <code>Fn</code>-family trait by one of the …\nImplementation of <code>const Destruct</code>, optionally from a custom …\nImplementation of a <code>Coroutine</code> trait by one of the …\nEvaluation is known to be ambiguous – it <em>might</em> hold for …\nEvaluation failed because of recursion involving inference …\nEvaluation failed.\nEvaluation successful.\nEvaluation successful, but need to rerun because opaque …\nEvaluation successful, but there were unevaluated region …\nThe result of trait evaluation. The order is important …\nImplementation of a <code>Fn</code>-family trait by one of the anonymous\nImplementation of a <code>Future</code> trait by one of the coroutine …\nImplementation of an <code>Iterator</code> trait by one of the …\nThere is no built-in impl. There may be some other …\nMatching <code>dyn Trait</code> with a supertrait of <code>Trait</code>. The index …\nIndicates that trait evaluation caused overflow and in …\nThis is a trait matching with a projected type as <code>Self</code>, …\nA cache value for the provisional cache: contains the …\nThe “provisional evaluation cache” is used to store …\nThe selection process begins by considering all impls, …\nPerform trait upcasting coercion of <code>dyn Trait</code> to a …\nImplementation of transmutability trait.\nThe impl is conditional on <code>T1, T2, ...: Trait</code>.\nEmits notes when the overlap is caused by complex …\nIf <code>true</code>, then there were candidates that might or might …\nAssembles the trait which are built-in to the language …\nSearches for unsizing that might apply to <code>obligation</code>.\nGiven an obligation like <code>&lt;SomeTrait for T&gt;</code>, searches the …\nSearches for impls that might apply to <code>obligation</code>.\nSearches for impls that might apply to <code>obligation</code>.\nChecks for the artificial impl that the compiler will …\nImplements one of the <code>Fn()</code> family for a fn pointer.\nReplace all regions inside the coroutine interior with …\nDetermines whether can we safely cache the result of …\nReturns <code>true</code> if the global caches can be used.\nCandidate assembly.\nReturns <code>DropVictim::Yes</code> if <code>victim</code> should be dropped in …\nIf there is any previous entry on the stack that precisely …\nChecks that the recursion limit has not been exceeded.\nFor defaulted traits, we use a co-inductive strategy to …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThis handles the case where an <code>auto trait Foo</code> impl is …\nConfirmation.\nFor default impls, we need to break apart a type into its …\nThe number of parent frames plus one (thus, the topmost …\nThe depth-first number of this node in the search graph –…\nnext “depth first number” to issue – just a counter\nEnables tracking of intercrate ambiguity causes. See the …\nIn the case of closure types and fn pointers, we currently …\nFurther evaluates <code>candidate</code> to decide whether all type …\nEvaluates the predicates in <code>predicates</code> recursively. This …\nEvaluates whether the obligation <code>obligation</code> can be …\nComputes the evaluation result of <code>op</code>, discarding any …\nfilter_impls filters candidates that have a positive impl …\nfilter_reservation_impls filter reservation impl for any …\nLooks at the item bounds of the projection or opaque type. …\nThe trait predicate from <code>obligation</code> but “freshened” …\nFreshener used specifically for entries on the obligation …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck the provisional cache for any result for …\nReturns the obligations that are implied by instantiating …\nInsert a provisional result into the cache. The result came\nIf <code>intercrate</code> is set, we remember predicates which were …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMap from cache key to the provisionally evaluated thing. …\nEquates the trait in <code>obligation</code> with trait bound. If the …\nReturns <code>Ok</code> if <code>poly_trait_ref</code> being true implies that the …\nReturn <code>Yes</code> if the obligation’s predicate type applies to …\nNormalize <code>where_clause_trait_ref</code> and try to match it …\nTemporary migration for #89190\nGet the next DFN in sequence (basically a counter).\nInvoked when the node at depth <code>depth</code> completed without …\nInvoked when the node with dfn <code>dfn</code> does not get a …\nAttempts to satisfy the obligation. If successful, this …\nThe mode that trait queries run in, which informs our …\nStarts out equal to <code>depth</code> – if, during evaluation, we …\nThe various <code>impl&lt;T: FnPtr&gt; Trait for T</code> in libcore are more …\nGets the intercrate ambiguity causes collected since …\nIndicates that attempting to evaluate this stack entry …\nA list of candidates that definitely apply to the current …\nSee <code>confirm_auto_impl_candidate</code>.\nThe stack of args that we assume to be true because a …\n<code>false</code> if there are no <em>further</em> obligations.\nA type “A” <em>matches</em> “B” if the fresh types in B …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf the self type is an alias type, e.g. an opaque type or …\nAt codegen time, all monomorphic projections will succeed. …\nWe failed due to ambiguity. This ambiguity can either be a …\nA builtin impl generated by the compiler. When adding a …\nTrait solving during coherence. There are a few notable …\nA candidate that is registered only during coherence to …\nContains the error value\nAdditional constraints returned on success.\nWhy a specific goal has to be proven.\nA user written impl.\nWe’re proving a where-bound of an impl.\nInstantiating a higher-ranked goal and re-proving it.\nWhy we failed to evaluate a goal.\nSome built-in impl we don’t need to differentiate. This …\nOrdinary trait solving, using everywhere except for …\nA built-in impl for trait objects. The index is only used …\nContains the success value\nWe gave up due to an overflow, most often by hitting the …\nAn assumption from the environment.\nOpaques that are defined in the inference context before a …\nDepending on the stage of compilation, we want projection …\nA built-in implementation of <code>Upcast</code> for trait objects to …\nUnsizing a tuple like <code>(A, B, ..., X)</code> to <code>(A, B, ..., Y)</code> if <code>X</code>…\nAt type-checking time, we refuse to project any associated …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAdditional constraints returned by this query.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nData structure used to inspect trait solver behavior.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUse this function to merge the certainty of multiple …\nWe added a goal to the <code>EvalCtxt</code> which will get proven the …\nWhen evaluating a goal we also store the original values …\nA call to …\nA call to <code>probe</code> while proving the current goal. This is …\nProbe entered when normalizing the self ty during …\nTry to unify an opaque type with an existing key in the …\nA self-contained computation during trait solving. This …\nWhat kind of probe we’re in. In case the probe …\nA trait goal was satisfied by an impl candidate.\nThe root inference context while proving a goal.\nLooking for param-env candidates that satisfy the trait …\nSome <code>data</code> together with information about how they relate …\nA candidate for proving a trait or alias-relate goal.\nTrying to normalize an alias by at least one step in …\nUsed in the probe that wraps normalizing the non-self type …\nDuring upcasting from some source object to target object …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe actual evaluation of the goal, always <code>ProbeKind::Root</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhat happened inside of this probe in chronological order.\nChildren of a given impl, grouped into blanket/non-blanket …\nA per-trait graph of impls in specialization order. At the …\nInformation about the most specialized definition of an …\nA node in the specialization graph is either an impl or a …\nWhat kind of overlap check are we doing – this exists …\nThe 1.0 rules (either types fail to unify, or where …\nJust check for negative impls, not for “where clause not …\nFeature-gated test: Stable, <em>or</em> there is an explicit …\nWalk up the specialization ancestors of a given impl, …\nBlanket impls associated with the trait.\nThe “root” impls are found by looking up the trait’s …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe node in the specialization graph containing the …\nThe “top-most” (ie. least specialized) specialization …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert a local impl into the specialization graph. If an …\nInsert a local impl into the specialization graph. If an …\nAttempt to insert an impl into this set of children, while …\nInsert an impl into this set of children without comparing …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this definition is known to not be further …\nTries to find the associated item that implements …\nThe associated item described by this <code>LeafDef</code>.\nFinds the bottom-most (ie. most specialized) definition of …\nImpls of the trait.\nThe parent of a given impl, which is the <code>DefId</code> of the …\nAll impls have a parent; the “root” impls have as …\nInsert cached metadata mapping from a child impl back to …\nInsert cached metadata mapping from a child impl back to …\nRemoves an impl from this set of children. Used when …\nInformation pertinent to an overlapping impl error.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nAttempt to fulfill all obligations of <code>target_impl</code> after …\nCalls <code>U::from(self)</code>.\nQuery provider for <code>specialization_graph_of</code>.\nIs <code>impl1</code> a specialization of <code>impl2</code>?\nGiven the generic parameters for the requested impl, …\nLike translate_args, but obligations from the parent …\nThe impl was inserted as a new child in this group of …\nChildren of a given impl, grouped into blanket/non-blanket …\nA per-trait graph of impls in specialization order. At the …\nThe result of attempting to insert an impl into a group of …\nInformation about the most specialized definition of an …\nA node in the specialization graph is either an impl or a …\nWhat kind of overlap check are we doing – this exists …\nThe impl should replace existing impls [X1, ..], because …\nThe impl is a specialization of an existing child.\nThe 1.0 rules (either types fail to unify, or where …\nJust check for negative impls, not for “where clause not …\nFeature-gated test: Stable, <em>or</em> there is an explicit …\nWalk up the specialization ancestors of a given impl, …\nLocate the definition of an associated type in the …\nBlanket impls associated with the trait.\nThe “root” impls are found by looking up the trait’s …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe node in the specialization graph containing the …\nThe “top-most” (ie. least specialized) specialization …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempt to insert an impl into this set of children, while …\nInsert a local impl into the specialization graph. If an …\nInsert an impl into this set of children without comparing …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe associated item described by this <code>LeafDef</code>.\nImpls of the trait.\nAll impls have a parent; the “root” impls have as …\nInsert cached metadata mapping from a child impl back to …\nRemoves an impl from this set of children. Used when …\nDescribes how to elaborate an obligation into a …\n“Elaboration” is the process of identifying all the …\nA filter around an iterator of predicates that makes it …\nThe inverse of <code>BoundVarReplacer</code>: replaces placeholders …\n“Trait alias expansion” is the process of expanding a …\nStores information about the expansion of a trait via a …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nIf <code>item</code> is a trait alias and its predicate has not yet …\nFilter to only the supertraits of trait predicates, i.e. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInstantiate all bound parameters of the impl subject with …\nAdds a predicate to the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdds diagnostic labels to <code>diag</code> for the expansion path of a …\nReturns <code>Some</code> if we <em>were</em> able to replace bound vars. If …\nComputes the def-ids of the transitive supertraits of …\nA specialized variant of <code>elaborate</code> that only elaborates …\nCasts a trait reference into a reference to one of its …\nExecutes <code>f</code> on <code>value</code> after replacing all escaping bound …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTurns option of iterator into an iterator (this is just …\nPrepare the segments for a vtable\nHelper for <code>prepare_vtable_segments</code> that returns <code>ControlFlow</code>…\nGiven a <code>dyn Subtrait</code> and <code>dyn Supertrait</code> trait object, find …\nGiven a trait <code>trait_ref</code>, iterates the vtable entries that …\nControls whether we “elaborate” supertraits and so …\nReturns the requirements for <code>clause</code> to be well-formed.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nPushes all the predicates needed to validate that <code>ty</code> is WF …\nPushes the obligations required for an alias (except …\nPushes the obligations required for an inherent alias to …\nPushes the obligations required for <code>trait_ref</code> to be WF …\nPoints the cause span of a super predicate at the relevant …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven an object type like <code>SomeTrait + Send</code>, computes the …\nReturns the set of obligations needed to make <code>arg</code> …\nGiven a set of predicates that apply to an object type, …\nReturns the obligations that make this trait reference …\nCompute the predicates that are required for a type to be …")