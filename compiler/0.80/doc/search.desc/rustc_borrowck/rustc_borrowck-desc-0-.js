searchState.loadedDescShard("rustc_borrowck", 0, "This query borrow-checks the MIR to (further) ensure it is …\nThe places might partially overlap - in this case, we give …\nRaw content of Fluent resource for this crate, generated …\nFrom the RFC: “A <em>deep</em> access means that all data …\nThe places are disjoint, so we know all extensions of them …\nAccess is Deep only when there is a Drop implementation …\nThe places have the same type, and are either completely …\nWe want use of immutable upvars to cause a “write to …\nWhen checking permissions for a place access, this flag is …\nThe degree of overlap between 2 places for borrow-checking.\nFrom the RFC: “A <em>read</em> means that the existing data may be\nKind of read access to a value (For informational purposes …\nKind of access to a value: read or write (For …\nFor two-phase borrows, we distinguish a reservation (which …\nFrom the RFC: “A <em>shallow</em> access means that the immediate …\nAssociate some local constants with the <code>&#39;tcx</code> lifetime\nFrom the RFC: “A <em>write</em> means that the data may be …\nKind of write access to a value (For informational …\nChecks an access to the given place to see if it is …\nThis field keeps track of when borrow errors are reported …\nAdds a suggestion when a closure is invoked twice with a …\nAdds an explanatory note if the move error occurs in a …\nAdds a suggestion to errors where an <code>impl Trait</code> is …\nAdds the place into the used mutable variables set\nAnnotate argument and return type of function and closure …\nAnnotate the first argument and return type of a function …\nAppends end-user visible description of the <code>local</code> place to …\nThe set of borrows extracted from the MIR\nFinds the span of arguments of a closure (within …\nSignal an error due to an attempt to move out of the …\nChecks the permissions for the given place and read or …\nChecks whether a borrow of this place is invalidated when …\nReports an error if this is a borrow of local data. This …\nSubslices correspond to multiple move paths, so we iterate …\nDescribe the reason for the fake borrow that was assigned …\nGiven an expression, check if it is a method call …\nFinds the spans of a captured place within a closure or …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nA public API provided for the Rust compiler consumers. …\nEnd-user visible description of <code>place</code> if one can be found. …\nEnd-user visible description of the <code>field</code>nth field of <code>base</code>\nEnd-user visible description of the <code>field_index</code>nth field …\nEnd-user visible description of <code>place</code> if one can be found. …\nReturns the description of the root place for a …\nEnd-user visible description of <code>place</code> if one can be found. …\nBorrow checker diagnostics.\nPerform the actual borrow checking.\nTargeted error when encountering an <code>FnMut</code> closure where an …\nSuggest using <code>while let</code> for call <code>next</code> on an iterator in a …\nReturns structured explanation for <em>why</em> the borrow contains …\nThis fields keeps track of the <code>Span</code>s that we have used to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWalks the MIR adding to the set of <code>used_mut</code> locals that …\nFrom the <code>hir::Ty</code> of an async function’s lowered return …\nReturn the name of the provided <code>Ty</code> (that must be a …\nReturns the name of the provided <code>Ty</code> (that must be a …\nChecks for the case where <code>fr</code> maps to something that the …\nFinds an argument that contains <code>fr</code> and label it with a …\nChecks for arguments appearing in the (closure) return …\nFinds a closure upvar that contains <code>fr</code> and label it with a …\nMaps from an internal MIR region vid to something that we …\nAttempts to highlight the specific part of a type …\nAttempts to highlight the specific part of a type in an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if a closure is inferred to be an <code>FnMut</code> …\nUser cannot make signature of a trait mutable without …\nWhether this value can be written or borrowed mutably. …\nIf <code>place</code> is a field projection, and the field is being …\nDetermine how the borrow was later used. First span …\nNames of local (user) variables (extracted from …\nThis keeps track of whether local variables are free-ed …\nMap from MIR <code>Location</code> to <code>LocationIndex</code>; created when MIR …\nWe’ve found an enum/struct/union type with the generic …\nCurrently MoveData does not store entries for all places in\nFinds the spans associated to a move or copy of move_place …\nThe counter for generating new region names.\nThe entry point of the NLL borrow checker.\nThe borrowck rules for proving disjointness are applied …\nFunctions dedicated to fact generation for the …\nResults of Polonius analysis.\nFrom the NLL RFC: “Shallow prefixes are found by …\nReturns an iterator over the prefixes of <code>place</code> (inclusive) …\nRecord the region names generated for each region in the …\nRegion inference context. This contains the results from …\nWith the new solver we prepopulate the opaque type storage …\nThis means that some data referenced by <code>borrow</code> needs to …\nReports an error specifically for when data is escaping a …\nReport a specialized error when <code>FnMut</code> closures return a …\nReports a region inference error for the general case with …\nReports an illegal reassignment; for example, an …\nReport an error because the universal region <code>fr</code> was …\nProduces nice borrowck error diagnostics for all the …\nThis field keeps track of when borrow conflict errors are …\nHelper to retrieve span(s) of given borrow from the …\nWe have <code>S { foo: val, ..base }</code>, and we suggest instead …\nWhen encountering a lifetime error caused by the return …\nIn a move error that occurs on a call within a loop, we …\nSuggest <code>map[k] = v</code> =&gt; <code>map.insert(k, v)</code> and the like.\nSuggest using closure argument instead of capture.\nGenerate a synthetic region named <code>&#39;N</code>, where <code>N</code> is the next …\nConverts a region inference variable into a <code>ty::Region</code> that\nReturns the <code>RegionVid</code> corresponding to the region returned …\nWe’ve found an enum/struct/union type with the generic …\nThis pass type-checks the MIR to ensure it is not broken.\nThis field keeps track of errors reported in the checking …\nCode to extract the universally quantified regions …\nInformation about upvars not necessarily preserved in …\nThis field keeps track of all the local variables that are …\nIf the function we’re checking is a closure, then we’…\nChecks if a borrowed value was captured by a trait object. …\nLocation where a two-phase borrow is activated, if a borrow\nLocation where the borrow is activated.\nLocations which activate borrows. NOTE: a given location …\nPlace to which the borrow was stored\nPlace from which we are borrowing\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf this is a two-phase borrow, then we will record it as …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhat kind of borrow this is\nMap from local to all the borrows on that local.\nThe fundamental map relating bitvector indexes to the …\nWhen we encounter a 2-phase borrow statement, it will …\nThe region for which this borrow is live\nLocation where the borrow reservation starts. In many …\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nA set of NLL region constraints. These include “outlives…\nZero value of the index.\nZero value of the index.\nThis method handles Universe errors by rewriting the …\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nWhat caused this constraint?\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nComputes cycles (SCCs) in the graph of regions. In …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf this constraint is promoted from closure requirements.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nConstructs a “normal” graph from the constraint set; …\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhere did this constraint arise?\nLike <code>graph</code>, but constraints a reverse graph where <code>R1: R2</code> …\nThe <code>Span</code> associated with the creation of this constraint. …\nRegion that must be outlived.\nThe region SUP must outlive SUB…\nVariance diagnostic information\nThe construct graph organizes the constraints by their …\nMarker trait that controls whether a <code>R1: R2</code> constraint …\nIn normal mode, a <code>R1: R2</code> constraint results in an edge …\nThis struct brings together a constraint set and a …\nIn reverse mode, a <code>R1: R2</code> constraint results in an edge …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a “dependency graph” where each region …\nCreates a “dependency graph” where each region …\nGiven a region <code>R</code>, iterate over all constraints <code>R: R1</code>.\nGiven a region <code>R</code>, iterate over all regions <code>R1</code> such that …\nGiven the constraint set from which this graph was built …\nA <code>Body</code> with information computed by the borrow checker. …\n<code>Borrows</code> stores the data used in the analyses that track …\nOptions determining the output behavior of …\nMaps between a MIR Location, which identifies a particular …\nWhen checking if a place conflicts with another place, …\nThe recommended option. Retrieves the maximal amount of …\nImplies <code>PoloniusInputFacts</code>, and additionally runs Polonius …\nRetrieve the <code>Body</code> along with the <code>BorrowSet</code> and …\nA mir body that contains region identifiers.\nThe set of borrows occurring in <code>body</code> with data about them.\nWhat caused this constraint?\n<code>cfg_edge(point1, point2)</code> for each edge <code>point1 -&gt; point2</code> in …\n<code>child_path(child, parent)</code> when the path <code>child</code> is the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe constraint-set, but in graph form, making it easy to …\nThe SCC computed from <code>constraints</code> and the constraint …\nThe outlives constraints computed by the type-check.\nContains the definition for every region variable. Region …\n<code>drop_of_var_derefs_origin(var, origin)</code> when the type of <code>var</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf this constraint is promoted from closure requirements.\nThis function computes borrowck facts for the given body. …\nReturns <code>true</code> if we can safely ignore borrows of this place.\nPolonius input facts. Populated when using …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThese reflect the <code>&#39;a: &#39;b</code> relations that are either …\nThe liveness constraints added to each region. For most …\n<code>loan_invalidated_at(point, loan)</code> indicates that the <code>loan</code> …\n<code>loan_issued_at(origin, loan, point)</code> indicates that the <code>loan</code>…\n<code>loan_killed_at(loan, point)</code> when some prefix of the path …\nThe table that maps Polonius points to locations in the …\nWhere did this constraint arise?\nThe “R0 member of [R1..Rn]” constraints, indexed by …\nRecords the member constraints that we applied to each scc.\nPolonius output facts. Populated when using …\n<code>path_accessed_at_base(path, point)</code> when the <code>path</code> was …\n<code>path_assigned_at_base(path, point)</code> when the <code>path</code> was …\n<code>path_is_var(path, var)</code> the root path <code>path</code> starting in …\n<code>path_moved_at_base(path, point)</code> when the <code>path</code> was moved at …\n<code>placeholder(origin, loan)</code> describes a placeholder <code>origin</code>, …\nHelper function for checking if places conflict with a …\nShould the Polonius input facts be computed?\nShould we run Polonius and collect the output facts?\nThe mir bodies of promoteds.\nContext generated during borrowck, intended to be passed to\nReverse of the SCC constraint graph –  i.e., an edge …\nThe final inferred values of the region variables; we …\nThe <code>Span</code> associated with the creation of this constraint. …\nRegion that must be outlived.\n<code>subset_base(origin1, origin2, point)</code> when we require …\nThe region SUP must outlive SUB…\nType constraints that we check after solving.\n<code>universal_region(origin)</code> – this is a “free region” …\nInformation about how the universally quantified regions in\nInformation about the universally quantified regions in …\nMap universe indexes to information on why we created it.\n<code>use_of_var_derefs_origin(variable, origin)</code>: References …\n<code>var_defined_at(var, point)</code> when the variable <code>var</code> is …\n<code>var_dropped_at(var, point)</code> when the variable <code>var</code> is used …\n<code>var_used_at(var, point)</code> when the variable <code>var</code> is used for …\nVariance diagnostic information\nThe transient state of the dataflow analyses used by the …\nThe results of the dataflow analyses used by the borrow …\n<code>Borrows</code> stores the data used in the analyses that track …\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKill any borrows that conflict with <code>place</code>.\nAdd all borrows to the kill set, if those borrows are out …\nReturns the lowest statement in <code>start..=end</code>, where the …\nLoans are in scope while they are live: whether they are …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nhelper struct for explain_captures()\nThe access is caused by capturing a variable for a closure.\nA call to <code>Fn(..)::call(..)</code>, desugared from …\nThe access is caused by using a variable as the receiver …\nA normal method call of the form <code>receiver.foo(a, b, c)</code>\nA call to an operator trait, desugared from operator …\nThis access has a single span associated to it: common …\nThis access is caused by a <code>match</code> or <code>if let</code> pattern.\nThe span(s) associated to a use of a place.\nAdd a span label to the arguments of the closure, if it …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nPrint diagnostics to explain why values are borrowed.\nReturns <code>false</code> if this place is not used in a closure.\nReturns <code>false</code> if this place is not used in a coroutine.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEnable/Disable tuple fields. For example <code>x</code> tuple. if it’…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains utilities for generating suggestions for borrowck …\nError reporting machinery for lifetime errors.\nReturns the span of <code>self</code>, in the case of a <code>ClosureUse</code> …\nReturns the span of <code>self</code>, in the case of a <code>ClosureUse</code> …\nAdd a span label to the use of the captured variable, if …\nAdd a subdiagnostic to the use of the captured variable, …\nThe <code>Span</code> of the <code>Target</code> associated type in the <code>Deref</code> impl …\nThe type <code>T::Deref</code> we are dereferencing to\nThe span of the args of the closure, including the <code>move</code> …\nThe span of the use resulting in capture kind Check …\nThis is true if the captured variable was from a coroutine.\nThe span of the method call on the variable\nThe definition span of the method being called\nThe span of the use resulting in the captured path Check …\nThe span of the variable being moved\nAny other reason.\nRelating two types which have binders.\nCreated from performing a <code>TypeOp</code>.\nWhat operation a universe was created for.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns an error to be reported if rerunning the type op …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLook for <code>break</code> expressions within any arbitrary …\nGiven a set of spans representing statements initializing …\nDetect whether one of the provided spans is a statement …\nWhich case a StorageDeadOrDrop is for.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAnnotate the provided diagnostic with information about …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndex of the “move out” that we found. The <code>MoveData</code> can\n<code>true</code> if we traversed a back edge while walking from the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nFind all uses of (including assignments to) a <code>Local</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIllegal move due to attempt to move from behind a …\nIllegal move due to attempt to move out of a slice or …\nIllegal move due to attempt to move from field of an ADT …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe place the reference refers to: if erroneous code was …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven a field that needs to be mutable, returns a span …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf the type is a <code>Coroutine</code>, <code>Closure</code>, or <code>CoroutineClosure</code>\nIf possible, suggest replacing <code>ref</code> with <code>ref mut</code>.\n’a = ’b\nOutlives(a, [b, c, d, …]) =&gt; ’a: ’b + ’c + ’d + …\nCollects information about outlives constraints that …\n’a: ’static i.e. ’a = ’static and the user should …\nThe different things we could suggest.\nIf there is a suggestion to emit, add a diagnostic to the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAdd the outlives constraint <code>fr: outlived_fr</code> to the set of …\nCompiles a list of all suggestions to be printed in the …\nThe list of outlives constraints that need to be added. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nEmit an intermediate note on the given <code>Diag</code> if the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> iff the <code>RegionNameSource</code> is a valid source …\nReturns a name for the region if it is suggestable. See …\nHigher-ranked subtyping error.\nInformation about the various region constraints involved …\nAny other lifetime error.\nA collection of errors encountered during region …\nA generic bound failure for a type test (<code>T: &#39;a</code>).\nAn unexpected hidden region for an opaque type.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe region element that erroneously must be outlived by …\nThe origin of the region.\nThe hidden type.\nIndicates whether this is a reported error. We currently …\nThe opaque type.\nThe placeholder free region.\nThe region that should outlive <code>shorter_fr</code>.\nThe unexpected region.\nThe placeholder region.\nThe region that should be shorter, but we can’t prove it.\nThe span for the member constraint.\nThe region corresponding to an argument.\nAn anonymous region from an async fn.\nAn anonymous region from an impl self type or trait\nThe region corresponding to the return type of a closure.\nThe region corresponding to a closure upvar.\nThe region from a type yielded by a coroutine.\nThe anonymous region corresponds to a region where the …\nThe anonymous region corresponds to a <code>&#39;_</code> in the generics …\nThe anonymous region corresponds to a reference that was …\nA bound (not free) region that was instantiated at the def …\nA free region that the user has a name (<code>&#39;a</code>) for.\nThe anonymous region corresponds to a region where the …\nA name for a particular region used in emitting …\nDescribes what to highlight to explain to the user that we…\nDenotes the source of a region that is named by a …\nThe <code>&#39;static</code> region.\nThe free region corresponding to the environment of a …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of the region (interned).\nWhere the region comes from.\nBuffer of diagnostics to be reported. A mixture of error …\nThis field keeps track of move errors that are to be …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nA (kinda) newtype of <code>RegionVid</code> so we can implement <code>Atom</code> on …\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\n<code>cfg_edge(point1, point2)</code> for each edge <code>point1 -&gt; point2</code> in …\n<code>child_path(child, parent)</code> when the path <code>child</code> is the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\n<code>drop_of_var_derefs_origin(var, origin)</code> when the type of <code>var</code>…\nReturns <code>true</code> if there is a need to gather <code>AllFacts</code> given …\nReturns <code>true</code> if there is a need to gather <code>AllFacts</code> given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThese reflect the <code>&#39;a: &#39;b</code> relations that are either …\n<code>loan_invalidated_at(point, loan)</code> indicates that the <code>loan</code> …\n<code>loan_issued_at(origin, loan, point)</code> indicates that the <code>loan</code>…\n<code>loan_killed_at(loan, point)</code> when some prefix of the path …\n<code>path_accessed_at_base(path, point)</code> when the <code>path</code> was …\n<code>path_assigned_at_base(path, point)</code> when the <code>path</code> was …\n<code>path_is_var(path, var)</code> the root path <code>path</code> starting in …\n<code>path_moved_at_base(path, point)</code> when the <code>path</code> was moved at …\n<code>placeholder(origin, loan)</code> describes a placeholder <code>origin</code>, …\n<code>subset_base(origin1, origin2, point)</code> when we require …\n<code>universal_region(origin)</code> – this is a “free region” …\n<code>use_of_var_derefs_origin(variable, origin)</code>: References …\n<code>var_defined_at(var, point)</code> when the variable <code>var</code> is …\n<code>var_dropped_at(var, point)</code> when the variable <code>var</code> is used …\n<code>var_used_at(var, point)</code> when the variable <code>var</code> is used for …\nMaps between a MIR Location, which identifies a particular …\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nCompactly stores a set of <code>R0 member of [R1...Rn]</code> …\nRepresents a <code>R0 member of [R1..Rn]</code> constraint\nZero value of the index.\nGiven a linked list starting at <code>source_list</code> and another …\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nReturns the “choice regions” for a given member …\nStores the <code>R1..Rn</code> regions for <em>all</em> sets. For any given …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nStores the data about each <code>R0 member of [R1..Rn]</code> …\nThe span where the hidden type was instantiated.\nIndex of <code>Rn</code> in <code>choice_regions</code> vector from …\nStores the first “member” constraint for a given <code>R0</code>. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nThe hidden type in which <code>R0</code> appears. (Used in error …\nExtracts the value of this index as a <code>usize</code>.\nIterate down the constraint indices associated with a given\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemap the “member region” key using <code>map_fn</code>, producing …\nThe region <code>R0</code>.\nPushes a member constraint into the set.\nIndex of <code>R1</code> in <code>choice_regions</code> vector from …\nThe output of <code>nll::compute_regions</code>. This includes the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nComputes the (non-lexical) regions from the input MIR.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRewrites the regions in the MIR to use NLL variables, also …\nControl for the path borrow checking code\nReturns <code>true</code> if the borrow represented by <code>kind</code> is allowed …\nDetermines if a given borrow is borrowing local data This …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEncapsulates the idea of iterating over every borrow that …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf <code>place</code> is a field projection, and the field is being …\nReturns <code>true</code> if we can safely ignore borrows of this place.\nWhen checking if a place conflicts with another place, …\nChecks whether the <code>borrow_place</code> conflicts with the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHelper function for checking if places conflict with a …\nEmit facts about CFG points and edges, as well as …\nWhen requested, emit most of the facts needed by polonius:\nEmit facts about loan invalidations.\nEmit facts needed for move/init analysis: moves and …\nEmit universal regions facts, and their relations.\nSimulates an access to a place.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nSimulates consumption of an operand.\nGenerates a new <code>loan_invalidated_at(L, B)</code> fact.\nEmit <code>loan_invalidated_at</code> facts.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSimulates mutation of a place.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEmit <code>loan_killed_at</code> and <code>cfg_edge</code> facts at the same time.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRecords the borrows on the specified local as <code>killed</code>.\nRecords the borrows on the specified place as <code>killed</code>. For …\nDoesn’t stop until it returns the base case (a Local or …\nStops at any dereference.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEach time that <code>apply_member_constraint</code> is successful, it …\nN.B., the variants in <code>Cause</code> are intentionally ordered. …\npoint inserted because Local was dropped at the given …\npoint inserted because Local was live at the given Location\nWhen we have an unmet lifetime constraint, we try to …\nAn annotation for region graph SCCs that tracks the values …\nA “type test” corresponds to an outlives constraint …\nAdds annotations for <code>#[rustc_regions]</code>; see …\nOnce region solving has completed, this function will …\nInvoked for each <code>R0 member of [R1..Rn]</code> constraint.\nLike <code>universal_upper_bound</code>, but returns an approximation …\nTries to find the best constraint to blame for the fact …\nIf <code>r2</code> represents a placeholder region, then this returns …\nChecks if Polonius has found any unexpected free region …\nOnce regions have been propagated, this method is used to …\nChecks the final value for the free region <code>fr</code> to see if it …\nChecks that we can prove that <code>longer_fr: shorter_fr</code>. If we …\nOnce regions have been propagated, this method is used to …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCompute the reverse SCC-based constraint graph (lazily).\nComputes the value of the SCC <code>scc_a</code>, which has not yet been\nThe constraint-set, but in graph form, making it easy to …\nAccess to the SCC constraint graph. This can be used to …\nThe SCC computed from <code>constraints</code> and the constraint …\nThe outlives constraints computed by the type-check.\nContains the definition for every region variable. Region …\nWrite out the region constraint graph.\nWrite out the region constraint graph.\nAs part of generating the regions, if you enable …\nWrite out our state into the <code>.mir</code> files.\nEvaluate whether <code>sup_region == sub_region</code>.\nEvaluate whether <code>sup_region: sub_region</code>.\nTests if <code>test</code> is true when applied to <code>lower_bound</code> at <code>point</code>.\nIf this is ’static or an early-bound region, then this is\nWalks the graph of constraints (where <code>&#39;a: &#39;b</code> is considered …\nTries to find the terminator of the loop in which the …\nFinds a good <code>ObligationCause</code> to blame for the fact that <code>fr1</code>…\nFinds some region R such that <code>fr1: R</code> and <code>R</code> is live at …\nReturns the lowest statement index in <code>start..=end</code> which is …\nDebugging aid: Invokes the <code>with_msg</code> callback repeatedly …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe type <code>T</code> that must outlive the region.\nSearch the argument types for one that references fr …\nGiven the index of an argument, finds its name (if any) …\nSearch the upvars (if any) to find one that references fr. …\nGiven the index of an upvar, finds its name and the span …\nThis module provides linkage between …\nReturns <code>true</code> if during the annotated SCC reaches a …\nResolve any opaque types that were encountered while …\nInitializes the region variables for each universally …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the <code>loan_idx</code> is live at the given <code>location</code>…\nReturns whether the given region is considered live at all …\nThe liveness constraints added to each region. For most …\nThe region <code>&#39;x</code> that the type must outlive.\nThe largest universe of a placeholder reached from this …\nThe “member constraint index” – we can find out …\nThe “R0 member of [R1..Rn]” constraints, indexed by …\nRecords the member constraints that we applied to each scc.\nThe SCC that was affected. (The “member region”.)\nThe “best option” that <code>apply_member_constraint</code> found …\nThe smallest universe index reachable form the nodes of …\nThe smallest-indexed universe reachable from and/or in …\nMap the regions in the type to named regions. This is …\nCreates a new region inference context with a total of …\nThis is a conservative normalization procedure. It takes …\nWhat kind of variable is this – a free region? …\nReturns an iterator over all the outlives constraints.\nPropagate the region constraints: this will grow the values\nWe have a constraint <code>fr1: fr2</code> that is not satisfied, where …\nReturns <code>true</code> if the region <code>r</code> contains the point <code>p</code>.\nGet the region definition of <code>r</code>.\nGet the region outlived by <code>longer_fr</code> and live at <code>element</code>.\nAccess to the region graph, built from the outlives …\nReturns access to the value of <code>r</code> for debugging purposes.\nReturns access to the value of <code>r</code> for debugging purposes.\nReturns an iterator over all the region indices.\nThe representative Region Variable Id for this SCC. We …\nIs the current representative existentially quantified?\nIs the current representative a placeholder?\nReverse of the SCC constraint graph –  i.e., an edge …\nReturns the representative <code>RegionVid</code> for a given SCC. See …\nThe minimum universe of any variable reachable from this …\nThe final inferred values of the region variables; we …\nPerforms region inference and report errors if we see any …\nThe span to blame.\nGiven a universal region in scope on the MIR, returns the …\nInvoked when we have some type-test (e.g., <code>T: &#39;X</code>) that we …\nWhen we promote a type test <code>T: &#39;r</code>, we have to replace all …\nAttempt to propagate a region error (e.g. <code>&#39;a: &#39;b</code>) that is …\nType constraints that we check after solving.\nInformation about how the universally quantified regions in\nInformation about the universally quantified regions in …\nWhich universe is this region variable defined in? This is …\nMap universe indexes to information on why we created it.\nReturns <code>true</code> if all the elements in the value of <code>scc_b</code> are …\nCheck if the SCC of <code>r</code> contains <code>upper</code>.\nA test which, if met by the region <code>&#39;x</code>, proves that this …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes if an opaque type requires a lifetime parameter …\nEqual parameters will have the same name. Computed Lazily. …\nOpaque type parameter validity check as documented in the …\nThis logic duplicates most of <code>check_opaque_meets_bounds</code>. …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nGiven the fully resolved, instantiated type for an opaque …\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFor each SCC, the range of <code>universal_regions</code> that use that …\nAll of the universal regions, in grouped so that …\nFind all universal regions that are required to outlive …\nData used to compute the loans that are live at a given …\nRecords the CFG locations where each region is live. When …\nA point in the control-flow graph.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nA single integer representing a <code>ty::Placeholder</code>.\nMaps from <code>ty::PlaceholderRegion</code> values that are used in …\nA placeholder (e.g., instantiated from a …\nAn individual element in a region value – the value of a …\nStores the full values for a set of regions (in contrast to\nA universally quantified region from the root universe …\nZero value of the index.\nRecords <code>region</code> as being live at all the control-flow …\nAdds all the control-flow points to the values for <code>r</code>.\nAdds the given element to the value for the given region. …\nRecords <code>region</code> as being live at the given <code>location</code>.\nRecords <code>region</code> as being live at all the given <code>points</code>.\nAdds all elements in <code>r_from</code> to <code>r_to</code> (because e.g., …\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns <code>true</code> if the region <code>r</code> contains the given element.\nReturns <code>true</code> if <code>sup_region</code> contains all the CFG points that\nThe map from locations to points.\nReturns all the elements contained in a given region’s …\nReturns the lowest statement index in <code>start..=end</code> which is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nThe set of loans that flow into a given region. When …\nReturns the <code>PlaceholderIndex</code> for the inserted …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether <code>region</code> is marked live at the given <code>location</code>…\nWhen using <code>-Zpolonius=next</code>, returns whether the <code>loan_idx</code> …\nThe set of loans that are live at a given point in the CFG.\nReturns an iterator of all the points where <code>region</code> is live.\nWhich regions are live. This is exclusive with the …\nIterate through each region that has a value in this set.\nWhen using <code>-Zpolonius=next</code>, for each point: the loans …\nReturns the locations contained within a given region <code>r</code>.\n<code>self[to] |= values[from]</code>, essentially: that is, take all …\nCreates a new set of “region values” that tracks …\nPlaceholders represent bound regions – so something like …\nReturns all the elements contained in a given region’s …\nFor each region: the points where it is live.\nFor debugging purposes, returns a pretty-printed string of …\nFor debugging purposes, returns a pretty-printed string of …\nFor debugging purposes, returns a pretty-printed string of …\nReturns a “pretty” string value of the region. Meant …\nIterate through each region that has a value in this set.\nReturns just the universal regions that are contained in a …\nCreate an empty map of regions to locations where they’…\nCreate an empty map of regions to locations where they’…\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUsed to determine the representative of a component in the …\nReplaces all free regions appearing in the MIR with fresh …\nReplaces all regions appearing in <code>value</code> with fresh …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndicates that a type constraint should always be true. …\nRuns <code>infcx.instantiate_opaque_types</code>. Unlike other <code>TypeOp</code>s, …\nThe <code>Locations</code> type summarizes <em>where</em> region constraints are …\nA collection of region constraints that must be satisfied …\nHolder struct for passing results from MIR typeck to the …\nAn outlives constraint that only has to hold at a single …\nThe MIR type checker. Visits the MIR and enforces all the …\nVerifies that MIR types are sane to not crash further …\nAdds the constraints that arise from a borrow expression …\n<em>Incorrectly</em> skips the WF checks we normally do in …\nCheck explicit closure signature annotation, e.g., …\nEquate the inferred type and the annotated type for user …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAdd sufficient constraints to ensure <code>a == b</code>. See also …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven some operation <code>op</code> that manipulates types, proves …\nThis module contains code to equate the input/output types …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIn general, the type-checker is not responsible for …\nEach time we add a placeholder to <code>placeholder_indices</code>, we …\nMaps from a <code>ty::Placeholder</code> to the corresponding …\nCreates a <code>Region</code> for a given <code>PlaceholderRegion</code>, or returns …\nAdds sufficient constraints to ensure that <code>a R b</code> where <code>R</code> …\nIf this rvalue supports a user-given type annotation, then …\nChecks that the types internal to the <code>place</code> match up with …\nGets a span representing the location.\nTry to relate <code>sub &lt;: sup</code>\nType checks the given <code>mir</code> in the context of the inference …\nUser type annotations are shared between the main MIR and …\nGiven an instance of the closure type, this method …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEach RBP <code>GK: &#39;a</code> is assumed to be true. These encode …\nPlaceholder regions need to be converted eagerly because …\nAs part of computing the free region relations, we also …\nUpdate the type of a single local, which should represent …\nRegisters the <code>OutlivesBound</code> items from <code>outlives_bounds</code> in …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns <code>true</code> if fr1 is known to equal fr2.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is the <code>&lt;=</code> relation; that is, if <code>a: b</code>, then <code>b &lt;= a</code>, …\nReturns the <em>non-transitive</em> set of known <code>outlives</code> …\nHelper for <code>non_local_upper_bounds</code> and …\nFinds a “lower bound” for <code>fr</code> that is not local. In …\nFinds an “upper bound” for <code>fr</code> that is not local. In …\nReturns <code>true</code> if fr1 is known to outlive fr2.\nStores the outlives relations that are known to hold from …\nGiven two universal regions, returns the postdominating …\nReturns a vector of free regions <code>x</code> such that <code>fr1: x</code> is …\nRecords in the <code>outlives_relation</code> (and …\nVisitor looking for regions that should be live within …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCombines liveness analysis with initialization analysis to …\nCalls <code>U::from(self)</code>.\nSome variable is “regular live” at <code>location</code> – i.e., …\nSome variables are “regular live” at <code>location</code> – …\nComputes all regions that are (currently) known to outlive …\nWe sometimes have <code>args</code> within an rvalue, or within a call. …\nWe sometimes have <code>region</code>s within an rvalue, or within a …\nWe sometimes have <code>ty</code>s within an rvalue, or within a call. …\nA map that cross references each local with the locations …\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nHead of a linked list of <strong>definitions</strong> of each variable – …\nHead of a linked list of <strong>drops</strong> of each variable – these …\nHead of a linked list of <strong>uses</strong> of each variable – use in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFor every potentially drop()-touched region <code>region</code> in <code>local</code>…\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContextual state for the type-liveness coroutine.\nAdds the definitions of <code>local</code> into <code>self.defs</code>.\nSome variable with type <code>live_ty</code> is “drop live” at …\nAdd extra drop facts needed for Polonius.\nStores the result that all regions in <code>value</code> are live for …\nMIR we are analyzing.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nComputes all points where local is “drop live” – …\nExecutes one iteration of the drop-live analysis loop.\nComputes all points where local is “use live” – …\nSet of points that define the current local.\nCache for the results of <code>dropck_outlives</code> query.\nPoints where the current variable is “drop live” – …\nLocations where drops may occur.\nRuns dropck for locals whose liveness isn’t relevant. …\nDefines the <code>PointIndex</code> mapping\nResults of dataflow tracking which variables (and paths) …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if the local variable (or some part of it) is …\nReturns <code>true</code> if the path <code>mpi</code> (or some part of it) is …\nReturns <code>true</code> if the local variable (or some part of it) is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndex indicating where each variable is assigned, used, or …\nMapping to/from the various indices used for …\nClear the value of fields that are “per local variable”…\nStack used when doing (reverse) DFS.\nThis is the heart of the liveness computation. For each …\nCurrent type-checker, giving us our inference context etc.\nPoints where the current variable is “use live” – …\nHow are we relating <code>a</code> and <code>b</code>?\nWhat category do we assign the resulting <code>&#39;a: &#39;b</code> …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhere (and why) is this relation taking place?\nInformation so that error reporting knows what types we …\nThe MIR is a closure. The signature is found via …\nThe MIR represents some form of constant. The signature …\nThe MIR is a coroutine. The signature is that coroutines …\nThe MIR is a special kind of closure that returns …\nThe “defining type” for this MIR. The key feature of …\nAn <strong>external</strong> region is only relevant for closures, …\nThe MIR is a fn item with the given <code>DefId</code> and args. The …\nA <strong>global</strong> region is one that can be named from anywhere. …\nThe MIR represents an inline const. The signature has no …\nA <strong>local</strong> lifetime is one about which we know the full set …\nAs part of the NLL unit tests, you can annotate a function …\nGiven a reference to a closure type, extracts all the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nBuilds a hashmap that maps from the universal regions that …\nReturns the “defining type” of the current MIR; see …\nThe “defining” type for this function, with all …\nWe create region variables such that they are ordered by …\nSee <code>first_extern_index</code>.\nReplaces all free regions in <code>value</code> with region vids, as …\nIterates over the late-bound regions defined on <code>mir_def_id</code> …\nIterates over the late-bound regions defined on <code>mir_def_id</code> …\nA special region vid created to represent the current MIR …\nThe vid assigned to <code>&#39;static</code>\nThe vid assigned to <code>&#39;static</code>. Used only for diagnostics.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nNumber of implicit inputs – notably the “environment”\nFor those regions that may appear in the parameter …\nInitially, the <code>UniversalRegionIndices</code> map contains only the\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>r</code> is classified as a local region.\nReturns <code>true</code> if <code>r</code> is a member of this set of universal …\nReturns the number of universal regions created in any …\nGets an iterator over all the early-bound regions that …\nCreates a new and fully initialized <code>UniversalRegions</code> that …\nReturns the number of global plus external universal …\nThe total number of universal region variables …\nClassifies <code>r</code> as a universal region, returning <code>None</code> if this …\nWhether we’ve encountered an error region. If we have, …\nSee <code>UniversalRegionIndices::to_region_vid</code>.\nConverts <code>r</code> into a local inference variable: <code>r</code> can either …\nReturns an iterator over all the RegionVids corresponding …\nThe fully liberated input types of this function, with all …\nThe return type of this function, with all regions …\nReturns a list of all the upvar types for this MIR. If …\nMIR visitor for collecting used mutable variables. The ’…\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")