<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Union-find implementation. The main type is `UnificationTable`."><title>rustc_data_structures::unify - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5ca6ca2a1f83705a.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="rustc_data_structures" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-dev" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../rustc_data_structures/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../rustc_data_structures/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2><a href="../../rustc_data_structures/index.html">rustc_data_structures</a><span class="version">1.82.0-dev</span></h2></div><h2 class="location"><a href="#">Module unify</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In crate rustc_data_structures</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">rustc_data_structures</a>::<wbr><a class="mod" href="#">unify</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="https://docs.rs/ena/latest/src/ena/lib.rs.html#24">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Union-find implementation. The main type is <code>UnificationTable</code>.</p>
<p>You can define your own type for the <em>keys</em> in the table, but you
must implement <code>UnifyKey</code> for that type. The assumption is that
keys will be newtyped integers, hence we require that they
implement <code>Copy</code>.</p>
<p>Keys can have values associated with them. The assumption is that
these values are cheaply cloneable (ideally, <code>Copy</code>), and some of
the interfaces are oriented around that assumption. If you just
want the classical “union-find” algorithm where you group things
into sets, use the <code>Value</code> type of <code>()</code>.</p>
<p>When you have keys with non-trivial values, you must also define
how those values can be merged. As part of doing this, you can
define the “error” type to return on error; if errors are not
possible, use <code>NoError</code> (an uninstantiable struct). Using this
type also unlocks various more ergonomic methods (e.g., <code>union()</code>
in place of <code>unify_var_var()</code>).</p>
<p>The best way to see how it is used is to read the <code>tests.rs</code> file;
search for e.g. <code>UnitKey</code>.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.InPlace.html" title="struct rustc_data_structures::unify::InPlace">InPlace</a></div><div class="desc docblock-short">Backing store for an in-place unification table.
Not typically used directly.</div></li><li><div class="item-name"><a class="struct" href="struct.NoError.html" title="struct rustc_data_structures::unify::NoError">NoError</a></div><div class="desc docblock-short">A struct which can never be instantiated. Used
for the error type for infallible cases.</div></li><li><div class="item-name"><a class="struct" href="struct.Snapshot.html" title="struct rustc_data_structures::unify::Snapshot">Snapshot</a></div><div class="desc docblock-short">At any time, users may snapshot a unification table.  The changes
made during the snapshot may either be <em>committed</em> or <em>rolled back</em>.</div></li><li><div class="item-name"><a class="struct" href="struct.UnificationTable.html" title="struct rustc_data_structures::unify::UnificationTable">UnificationTable</a></div><div class="desc docblock-short">Table of unification keys and their values. You must define a key type K
that implements the <code>UnifyKey</code> trait. Unification tables can be used in two-modes:</div></li><li><div class="item-name"><a class="struct" href="struct.VarValue.html" title="struct rustc_data_structures::unify::VarValue">VarValue</a></div><div class="desc docblock-short">Value of a unification key. We implement Tarjan’s union-find
algorithm: when two keys are unified, one of them is converted
into a “redirect” pointing at the other. These redirects form a
DAG: the roots of the DAG (nodes that are not redirected) are each
associated with a value of type <code>V</code> and a rank. The rank is used
to keep the DAG relatively balanced, which helps keep the running
time of the algorithm under control. For more information, see
<a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">http://en.wikipedia.org/wiki/Disjoint-set_data_structure</a>.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.EqUnifyValue.html" title="trait rustc_data_structures::unify::EqUnifyValue">EqUnifyValue</a></div><div class="desc docblock-short">A convenient helper for unification values which must be equal or
else an error occurs. For example, if you are unifying types in a
simple functional language, this may be appropriate, since (e.g.)
you can’t unify a type variable bound to <code>int</code> with one bound to
<code>float</code> (but you can unify two type variables both bound to
<code>int</code>).</div></li><li><div class="item-name"><a class="trait" href="trait.UnificationStore.html" title="trait rustc_data_structures::unify::UnificationStore">UnificationStore</a></div></li><li><div class="item-name"><a class="trait" href="trait.UnificationStoreBase.html" title="trait rustc_data_structures::unify::UnificationStoreBase">UnificationStoreBase</a></div><div class="desc docblock-short">Largely internal trait implemented by the unification table
backing store types. The most common such type is <code>InPlace</code>,
which indicates a standard, mutable unification table.</div></li><li><div class="item-name"><a class="trait" href="trait.UnificationStoreMut.html" title="trait rustc_data_structures::unify::UnificationStoreMut">UnificationStoreMut</a></div></li><li><div class="item-name"><a class="trait" href="trait.UnifyKey.html" title="trait rustc_data_structures::unify::UnifyKey">UnifyKey</a></div><div class="desc docblock-short">This trait is implemented by any type that can serve as a type
variable. We call such variables <em>unification keys</em>. For example,
this trait is implemented by <code>IntVid</code>, which represents integral
variables.</div></li><li><div class="item-name"><a class="trait" href="trait.UnifyValue.html" title="trait rustc_data_structures::unify::UnifyValue">UnifyValue</a></div><div class="desc docblock-short">Trait implemented for <strong>values</strong> associated with a unification
key. This trait defines how to merge the values from two keys that
are unioned together. This merging can be fallible. If you attempt
to union two keys whose values cannot be merged, then the error is
propagated up and the two keys are not unioned.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.InPlaceUnificationTable.html" title="type rustc_data_structures::unify::InPlaceUnificationTable">InPlaceUnificationTable</a></div><div class="desc docblock-short">A unification table that uses an “in-place” vector.</div></li><li><div class="item-name"><a class="type" href="type.UnificationStorage.html" title="type rustc_data_structures::unify::UnificationStorage">UnificationStorage</a></div></li><li><div class="item-name"><a class="type" href="type.UnificationTableStorage.html" title="type rustc_data_structures::unify::UnificationTableStorage">UnificationTableStorage</a></div></li></ul></section></div></main></body></html>